[{"pageContent":"# JSON训练集的Plugin工具\n\n## 1、 思路\n\n1. 书写插件，获取ast语法树\n2. 对code进行拼接，生成jsonl文件\n3. 排除资源文件和nodemodule库\n4. 考虑插件兼容性 自定义文件后缀 生成json文件\n5. 生成缓存文件json，打包时对比hash值，判断是否拼接json文件（如果部署本地ai再考虑这个做法）,阿里云训练集限制100个\n6. 打包完成后上传json文件\n7. express后端接收后上传阿里云oss\n8. 使用 <a href=\"https://help.aliyun.com/zh/model-studio/developer-reference/model-customization-file-management-service?spm=a2c4g.11186623.help-menu-2400256.d_3_5_1.3a57b514rotTBZ&scm=20140722.H_2712476._.OR_help-T_cn~zh-V_1\" target=\"_blank\">模型调优</a>接口进行调优\n9. 在前端接入对话框 后续继承ai能力\n\n\n## 2、 ai提升需求\n\n1. 在`transform`钩子中添加方法，过滤出常见的代码文件和`md`,`mdx`，对于code进行处理 生成jsonl训练集，\n2. 不要用nodemodule里面的包\n3. 在每一个训练集开头附上相对根目录的文件路径\n4. 训练集分`react`和`vue`,以及`js`和`ts`，生成相关jsonl训练集\n5. 在`transform`钩子中添加方法，过滤出常见的代码文件和`md`,`mdx`，进行切分操作，对于code进行处理 生成jsonl训练集，\n6. 需要制作缓存 \n7. 通过流的形式传输 等所有文件遍历完成后再写成一个jsonl训练集\n8. 如何处理\n\n```ts\n   messages: [\n        {\n          role: 'system',\n          content: '你是一个代码文档助手，回答必须基于提供的代码库内容'\n        },\n        {\n          role: 'user',\n          content: `根据${path.basename(filePath)}的${block.name}部分，${generateQuestion(block)}`\n        },\n        {\n          role: 'assistant',\n          content: generateAnswer(block, filePath)\n        }]\nfunction generateQuestion(block: CodeBlock): string {\n  switch(block.type) {\n    case 'function':\n      return `请解释${block.name}函数的作用和参数`;\n    case 'component':\n      return `如何使用${block.name}组件？`;\n    case 'markdown':\n      return `总结${block.name}章节的主要内容`;\n  }\n}\nfunction generateAnswer(block: CodeBlock, filePath: string): string {\n  const sourceRef = `（来源：${path.basename(filePath)}#${block.name}）`;\n  \n  if (block.type === 'markdown') {\n    return `文档内容：${block.content.slice(0, 200)}... ${sourceRef}`;\n  }\n  \n  return `代码片段：\n\\`\\`\\`${block.type === 'function' ? 'typescript' : 'jsx'}\n${block.content}\n\\`\\`\\`\n${block.comments.join('\\n')} ${sourceRef}`;\n}\n```\n\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/AIGC/JSON训练集的Plugin工具.mdx"}},{"pageContent":"# langchains速记\n\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/AIGC/langchins速记.mdx"}},{"pageContent":"## 1、grid\n\n### justify-self 属性、align-self 属性以及 place-self 属性\n\n[justify-self 属性/ align-self 属性/ place-self 属性演示地址](https://link.juejin.cn?target=https%3A%2F%2Fcodepen.io%2Fgpingfeng%2Fpen%2FZEQZEJK%3Feditors%3D1100)\n\n`justify-self` 属性设置单元格内容的水平位置（左中右），跟 `justify-items` 属性的用法完全一致，但只作用于单个项目\n\n`align-self` 属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致\n\njustify-content,align-content也能生效\n\ngrid 布局简写row在前\n\n- /* <'grid-template'> values */\\\n- /* <'grid-template-rows'> /\n- /* [ auto-flow && dense? ] <'grid-auto-rows'>? /  <'grid-template-columns'> values */\n- /* Global values */\n\n\n\n```\ngrid = \n  <'grid-template'>                                   |\n  <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>?  |\n  [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>  \n```\n\n|                           grid简写                           |                    案例                    |\n| :----------------------------------------------------------: | :----------------------------------------: |\n| /* [ auto-flow && dense? ] <'grid-auto-rows'>? /  <'grid-template-columns'> values */ | grid: auto-flow dense 1fr 2fr/200px 200px; |\n| /* <'grid-template-rows'> /    [ auto-flow && dense? ] <'grid-auto-columns'>? values */ |     grid: repeat(3, 60px) / auto-flow;     |\n|                /* <'grid-template'> values */                |        grid: 1fr 2fr /2fr 1fr 1fr;         |\n\n\n\n|                      grid-template简写                       |                             案例                             |\n| :----------------------------------------------------------: | :----------------------------------------------------------: |\n|     /* 为 grid-template-rows / grid-template-columns */      |             grid-template: 100px 1fr / 50px 1fr;             |\n| /* 为 grid-template-areas grid-template-rows / grid-template-column */ | grid-template:<br/> \"head head\" 30px<br/>   \"nav  main\" 1fr <br/>   \"nav  foot\" 30px <br/>    / 200px 300px;<br/>} |\n\n### 1.1  grid-template-columns\n\n每一位数字都代表当前列；  grid-template-columns: 1fr 2fr 1fr;3列，中间一列代表2等分列；fr代表百分比；repeat()表示网格轨道的重复部分，以一种更简洁的方式去表示大量而且重复列的表达式。\n\n\n\n### 1.2grid-template-rows \n\n`grid-template-rows` 该属性是基于 [网格行](https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_Row) 的维度，去定义网格线的名称和网格轨道的尺寸大小。\n\n它会根据 grid-template-columns多退少补\n\n### 1.3repeat\n\n```\n/* <track-repeat> values */\nrepeat(4, [col-start] 1fr [col-end])\n在子元素中设置grid-column-start开始位置column\n在子元素中设置grid-column-end结束位置column\n在子元素中设置grid-row-start开始位置row\n在子元素中设置grid-row-end结束位置row\n```\n\n[`max-content`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/repeat#max-content)\n\n代表占据网格轨道的网格项目所分配的最大内容区域的最大值。\n\n[`min-content`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/repeat#min-content)\n\n代表占据网格轨道的网格项目所分配的最小内容区域的最小值。\n\n[`auto`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/repeat#auto)\n\n作为最大值，等同于 `max-content`。作为最小值，它代表占据网格轨道的网格项目的最小尺寸的最大值（如同[`min-width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/min-width)/[`min-height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/min-height)所指定的)）。\n\n[`auto-fill`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/repeat#auto-fill)\n\n如果网格容器在相关轴上具有确定的大小或最大大小，则重复次数是最大可能的正整数，不会导致网格溢出其网格容器。如果定义了，将每个轨道视为其最大轨道尺寸大小函数 ( `grid-template-rows` 或 `grid-template-columns`用于定义的每个独立值。否则，作为最小轨道尺寸函数，将网格间隙加入计算。如果重复次数过多，那么重复值是 `1` 。否则，如果网格容器在相关轴上具有确定的最小尺寸，重复次数是满足该最低要求的可能的最小正整数。否则，指定的轨道列表仅重复一次。\n\n[`auto-fit`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/repeat#auto-fit)\n\n行为与 `auto-fill` 相同，除了放置网格项目后，所有空的重复轨道都将折叠。空轨道是指没有流入网格或跨越网格的网格项目。（如果所有轨道都为空，则可能导致所有轨道被折叠。）\n\n折叠的轨道被视为具有单个固定轨道大小函数为 `0px`，两侧的槽都折叠了。\n\n为了找到自动重复的轨道数，用户代理将轨道大小限制为用户代理指定的值（例如 `1px`），以避免被零除。\n\n注：如果有剩余空间的话，`auto-fill` 会创建额外的空列。而 `auto-fit` 则以最后一个 Gird 项目结束 Gird 容器，不管是否还有额外的空间存在。\n\n### 1.4gap\n\n[CSS](https://developer.mozilla.org/zh-CN/docs/Web/CSS) **`gap`** [简写属性](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties)用于设置行与列之间的间隙（[网格间距](https://developer.mozilla.org/zh-CN/docs/Glossary/Gutters)）。\n\n规范的早期版本将该属性命名为 `grid-gap`，且为了保持与旧网站的兼容性，浏览器仍然会接受 `grid-gap` 作为 `gap` 的别名。\n\n### 1.5grid-area\n\nCSS 属性 **`grid-area`** 是一种对于 [`grid-row-start` (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row-start)、[`grid-column-start` (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column-start)、[`grid-row-end` (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row-end) 和 [`grid-column-end` (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column-end) 的简写，通过基线（line），跨度（span）或没有（自动）的网格放置在 [grid row](https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_Row) 中指定一个网格项的大小和位置，继而确定 [grid area](https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_Areas) 的边界。\n\n### 1.6网格行grid-column-start， grid-column-end   注 再整理\n\n列之间的线称为列线，行之间的线称为行线，如果三条列线三条行线会组成6个网格\n\n如需放置某个项目，您可以引用行号（line numbers），或使用关键字 \"span\" 来定义该项目将跨越多少列。\n\n\n\n 给第一个item 添加类item1，从第一列线开始第三列线结束，说明item1此时占据两个网格项的长度， 此时界面就会变成。\n\n.item1 {\n        grid-column-start: 1;\n        grid-column-end: 3;\n       //也可以写成\n        grid-column: 1 / 3;\n     }\n//等价于\n.item1{\n        grid-column: 1 / span 2;//表示从第一列开始  占两格  相当于从第1列开始 第3列结束\n     }\n\n###  1.7grid-area属性\n\ngrid-area属性可以用作 grid-row-start、grid-column-start、grid-row-end 和 grid-column-end 属性的简写属性。\n\n  .item1 {\n        //列线从第一条到第三条，行线从第一条到第三条\n        grid-area: 1 / 1 / 3 / 3;\n    }\n\n这个是命名\n\n### 1.8grid-template-areas\n\ngrid-template-areas 属性在网格布局中规定区域。您可以使用 grid-area 属性命名网格项目，然后在 grid-template-areas 属性中引用该名称。\n\n这个是使用\n\n//基线参考资料\n\nhttps://blog.csdn.net/Tonghanhan/article/details/130289704\n\n#### 1.9grid-auto-flow\n\n**`grid-auto-flow`** 属性控制着自动布局算法怎样运作，精确指定在网格中被自动布局的元素怎样排列。\n\n```\ngrid-auto-flow: row;\ngrid-auto-flow: column;\ngrid-auto-flow: dense;\ngrid-auto-flow: row dense;\ngrid-auto-flow: column dense;\n```\n\n[`row`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-flow#row)\n\n该关键字指定自动布局算法按照通过逐行填充来排列元素，在必要时增加新行。如果既没有指定 `row` 也没有 `column`，则默认为 `row`。\n\n[`column`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-flow#column)\n\n该关键字指定自动布局算法通过逐列填充来排列元素，在必要时增加新列。\n\n[`dense`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-flow#dense)\n\n该关键字指定自动布局算法使用一种“稠密”堆积算法，如果后面出现了稍小的元素，则会试图去填充网格中前面留下的空白。这样做会填上稍大元素留下的空白，但同时也可能导致原来出现的次序被打乱。\n\n如果省略它，使用一种「稀疏」算法，在网格中布局元素时，布局算法只会「向前」移动，永远不会倒回去填补空白。这保证了所有自动布局元素「按照次序」出现，即使可能会留下被后面元素填充的空白。\n\n#### 2.0grid-auto-rows \n\n属性为网格容器中的行设置尺寸。\n\n该属性只会影响未设置尺寸的行。\n\n**隐式和显示网格**：显式网格包含了你在 `grid-template-columns` 和 `grid-template-rows` 属性中定义的行和列。如果你在网格定义之外又放了一些东西，或者因为内容的数量而需要的更多网格轨道的时候，网格将会在隐式网格中创建行和列\n\n假如有多余的网格（也就是上面提到的隐式网格），那么它的行高和列宽可以根据 `grid-auto-columns` 属性和 `grid-auto-rows` 属性设置。它们的写法和` grid-template-columns` 和 `grid-template-rows` 完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行\n\n#### 2.1grid-template \n\n所简写属性：[`grid-template-rows`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-rows)、[`grid-template-columns`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-columns)与[`grid-template-areas`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-areas)\n\n以/分割 前面的每一行代表实际的一行基线分布情况 后面的值是row的值 <track-list> values \n\n/后面的就是整体column的分布情况\n\n```css\n#page {\n  display: grid;\n  width: 100%;\n  height: 200px;\n  grid-template:\n \"head head\" 30px\n   \"nav  main\" 1fr \n   \"nav  foot\" 30px \n    / 200px 300px;\n}\n```","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/css/grid.md"}},{"pageContent":"import Base from './svg/base'\nimport AnimationSvg from './svg/animationSvg'\n\n# svg\n\n## 基础\n\n```tsx\n<svg width=\"500\" height=\"500\" viewBox=\"0 0 500 500\">\n  <filter id=\"blur\">\n    <feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"5\" />\n  </filter>\n  <circle cx=\"170\" cy=\"60\" r=\"50\" fill=\"green\" filter=\"url(#blur)\" />\n</svg>\n```\n\n<Base />\n\n```tsx\n<svg width=\"500\" height=\"500\" viewBox=\"0 0 500 500\" xmlns=\"http://www.w3.org/2000/svg\"\n  xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n  <defs>\n    <mask id=\"mask\">\n      <image width=\"500\" height=\"500\" xlink:href=\"/images/mask.png\" />\n    </mask>\n  </defs>\n  <image mask=\"url(#mask)\" width=\"500\" height=\"500\" xlink:href=\"/images/wolp1.png\" />\n</svg>\n```\n### xmlns、xmlns:xlink、xlink:href。\nxmlns 和 xmlns:xlink 是 XML 命名空间的属性，而 xlink:href 是 XLink 规范中的属性。它们之间的区别如下：\n\n1. xmlns 属性用于定义 XML 文档中的默认命名空间。它指定了 XML 元素和属性的命名空间，如果没有指定其他命名空间，则默认使用该命名空间。\n\n2. xmlns:xlink 属性也是用于定义 XML 文档中的命名空间，但它是为了支持 XLink（XML 链接）规范而定义的。xmlns:xlink 属性指定了用于解析和处理 XLink 链接的命名空间。\n\n20 xlink:href 是 XLink 规范中的属性，用于指定链接的目标。它是在具有 XLink 命名空间的 XML 文档中使用的属性，通过该属性可以指定链接的目标资源。\n\n综上所述，xmlns 属性用于定义默认命名空间，xmlns:xlink 属性用于定义 XLink 命名空间，而 xlink:href 属性用于指定 XLink 链接的目标资源。\n\n## 动画\n\n<AnimationSvg />\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/css/svg.mdx"}},{"pageContent":"# Electron\n\n# 1、electron生命周期\n\n- `will-finish-launching` 在应用完成基本启动进程之后触发。\n- `ready` 当 electron 完成初始化后触发。\n- `window-all-closed` 所有窗口都关闭的时候触发，在 windows 和 linux 里，所有窗口都退出的时候**通常**是应用退出的时候。\n- `before-quit` 退出应用之前的时候触发。\n- `will-quit` 即将退出应用的时候触发。\n- `quit` 应用退出的时候触发。\n\n# 2、进程通讯\n\n### 1、渲染-主\n\n使用 [`ipcRenderer.send`](https://electron.nodejs.cn/docs/latest/api/ipc-renderer) API 发送一条消息，然后由 [`ipcMain.on`](https://electron.nodejs.cn/docs/latest/api/ipc-main) API 接收该消息\n\npreload是前后端沟通的桥梁\n\n渲染进程 => preload => 主进程\n\n流程\n\n1. 定义main文件中，我们的主线程需要做什么，规定好preload中 传入的channel字段\n2. 书写preload文件  ipcRenderer.send api 定义传入channel和参数\n3. 渲染进程发送消息，通过事件 对挂载在window上的api进行调用\n\n```js\nmain 主线程文件\nfunction createWindow () {\n  const mainWindow = new BrowserWindow({\n    webPreferences: {\n      preload: path.join(__dirname, 'preload.js')\n    }\n  })//引入preload\n\t//接收子组件传递信息\n  ipcMain.on(channel, (event, args ) => {\n    channel 字符串 从preload中传入的文本\n    event ipc主事件，\n    args 参数\n  })\n//读取html文件\n  mainWindow.loadFile('index.html')\n}\n```\n\n```js\n//preload.js文件 \ncontextBridge.exposeInMainWorld('electronAPI', {\n  setTitle: (payload) => ipcRenderer.send('set-title', payload)\n})\n//此时，你将能够在渲染器进程中使用 window.electronAPI.setTitle() 函数。\n```\n\n```js\n//js文件调用\nbtn.addEventListener('click', () => {\n  window.electronAPI.setTitle(payload)\n})\n\n```\n\n### 2、双向\n\n通过使用 [`ipcRenderer.invoke`](https://electron.nodejs.cn/docs/latest/api/ipc-renderer#ipcrendererinvokechannel-args) 与 [`ipcMain.handle`](https://electron.nodejs.cn/docs/latest/api/ipc-main#ipcmainhandlechannel-listener) 配对来完成\n\n渲染进程=>preload=>ipcRender.invoke=>主线程=>ipcMain.handle返回值=>preload=>渲染进程返回\n\n1. 主线程中，通过ipcMain.handle接收preload中invoke的消息，然后将此函数作为他的回调，返回值作为promise返回到原始的invoke调用\n2. 通过repload加载ipcRender.invoke，该函数会在渲染进程进行调用\n3. 渲染进程，执行preload的api，他抛出一个promise，这个值是我们在主线程返回的值\n\n```javascript\n//main.js (Main Process)\nipcMain.handle('channel', callback)\n返回值是ipcRender的值\n```\n\n```js\n//preload.js (Preload Script)\ncontextBridge.exposeInMainWorld('electronAPI', {\n  api: () => ipcRenderer.invoke('dialog:openFile')\n})\n```\n\n```js\n//renderer.js \nbtn.addEventListener('click', async () => {\n  const filePath = await window.electronAPI.api()\n})\n```\n\n### 3、主线程到渲染器\n\n消息需要通过渲染器进程的 [`WebContents`](https://electron.nodejs.cn/docs/latest/api/web-contents) 实例发送到渲染器进程。此 WebContents 实例包含一个 [`send`](https://electron.nodejs.cn/docs/latest/api/web-contents#contentssendchannel-args) 方法，其使用方式与 `ipcRenderer.send` 相同。\n\n```js\n//main文件\n//窗口创建后会有一个webContens的对象，发送\n mainWindow.webContents.send('channel', payload),\n```\n\n```js\n//preload\n//接收信息\ncontextBridge.exposeInMainWorld('electronAPI', {\n  handler: (callback) => ipcRenderer.on('channel', (_event, value) => callback(value))\n})\n//接收一个回调，并且传入参数\n```\n\n```js\n//rendere.js\nwindow.electronAPI.handler(function)\n```\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/electron/electron.md"}},{"pageContent":"---\ntitle: 01-认识Web和Web标准\npublish: true\n---\n`<ArticleTopAd></ArticleTopAd>`\n\n## Web、网页、浏览器\n\n### Web\n\nWeb（World Wide Web）即全球广域网，也称为万维网。\n\n我们常说的 `Web端`就是网页端。\n\n### 网页\n\n**网页是构成网站的基本元素**。网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及Flash等。\n\n我们在浏览器上输入网址后，打开的任何一个页面，都是属于网页。\n\n### 浏览器\n\n浏览器是网页运行的平台，常见的浏览器有谷歌（Chrome）、Safari、火狐（Firefox）、IE、Edge、Opera等。\n\n关于浏览器的详细介绍，可以看下一篇文章：《浏览器的介绍》。\n\n## Web标准\n\n### W3C组织\n\n**W3C**：World Wide Web Consortium，万维网联盟组织，用来制定web标准的机构（组织）。\n\nW3C 万维网联盟是国际最著名的标准化组织。1994年成立后，至今已发布近百项相关万维网的标准，对万维网发展做出了杰出的贡献。\n\nW3C 组织就类似于现实世界中的联合国。\n\n为什么要遵循WEB标准呢？因为很多浏览器的浏览器内核不同，导致页面解析出来的效果可能会有差异，给开发者增加无谓的工作量。因此需要指定统一的标准。\n\n### Web 标准\n\n**Web标准**：制作网页要遵循的规范。\n\nWeb标准不是某一个标准，而是由W3C组织和其他标准化组织制定的一系列标准的集合。\n\n**1、Web标准包括三个方面**：\n\n- 结构标准（HTML）：用于对网页元素进行整理和分类。\n- 表现标准（CSS）：用于设置网页元素的版式、颜色、大小等外观样式。\n- 行为标准（JS）：用于定义网页的交互和行为。\n\n根据上面的Web标准，可以将 Web前端分为三层，如下。\n\n**2、Web前端分三层**：\n\n- HTML（HyperText Markup Language）：超文本标记语言。从**语义**的角度描述页面的**结构**。相当于人的身体组织结构。\n- CSS（Cascading Style Sheets）：层叠样式表。从**审美**的角度美化页面的**样式**。相当于人的衣服和打扮。\n- JavaScript（简称JS）：从**交互**的角度描述页面的**行为**，实现业务逻辑和页面控制。相当于人的动作，让人有生命力。\n\n**3、打个比方**：（拿黄渤举例）\n\nHTML 相当于人的身体组织结构：\n\n![](http://img.smyhvae.com/20200322_1250.png)\n\nCSS 相当于人的衣服和打扮：\n\n![](http://img.smyhvae.com/20200322_1251.png)\n\nJS 相当于人的行为：\n\n![](http://img.smyhvae.com/20200322_2220.gif)\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/html/01-认识Web和Web标准.md"}},{"pageContent":"---\ntitle: \npublish: true\n---\n`<ArticleTopAd></ArticleTopAd>`\n\n## 重点: 学习html一定要会查询文档\n\n[mdn](https://developer.mozilla.org/zh-CN/)\n\n[菜鸟教程](https://www.runoob.com/html/html-tutorial.html)\n\n[w3cSchool](https://www.w3school.com.cn/)\n\n## 编辑器相关\n\n前端开发的编辑器软件，我首先推荐 VS Code，其次推荐Sublime Text。\n\n有人说 WebStorm 也不错？但真实情况是，自从VS Code 问世之后，用 WebStorm 的人越来越少了。\n\nPS：文件的后缀名不能决定文件格式，只能决定打开文件打开的方式。\n\n### VS Code 的使用\n\n详情请移步至：[第一次使用VS Code时你应该知道的一切配置](https://github.com/qianguyihao/Web/blob/master/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/01-VS%20Code%E7%9A%84%E4%BD%BF%E7%94%A8.md)\n\n### Sublime Text 的使用\n\n详情请移步至：[Sublime Text使用技巧](https://github.com/qianguyihao/Mac/blob/master/03-%E5%85%A8%E5%B9%B3%E5%8F%B0%E8%BD%AF%E4%BB%B6/Sublime%20Text%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.md)\n\n## HTML的概述\n\n### HTML的概念\n\n**HTML** 全称为 HyperText Markup Language，译为 `<font color=#0000ff>`**超文本标记语言** `</font>`。\n\nHTML 不是一种编程语言，是一种描述性的**标记语言**。\n\n**作用**：HTML是负责描述文档**语义**的语言。\n\n### 概念：超文本\n\n所谓的超文本，有两层含义：\n\n（1）图片、音频、视频、动画、多媒体等内容，被称为超文本，因为它们超出了文本的限制。\n\n（2）不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件进行连接。即：超级链接文本。\n\n### 概念：标记语言\n\nHTML 不是一种编程语言，是一种描述性的**标记语言**。这主要有两层含义：\n\n（1）**标记语言是一套标记标签**。比如：标签 `<a>`表示超链接、标签 `<img>`表示图片、标签 `<h1>`表示一级标题等等，它们都是属于 HTML 标签。\n\n说的通俗一点就是：网页是由网页元素组成的，这些元素是由 HTML 标签描述出来，然后通过浏览器解析，就可以显示给用户看了。\n\n（2）编程语言是有编译过程的，而标记语言没有编译过程，HTML标签是直接由浏览器解析执行。\n\n### HTML是负责描述文档语义的语言\n\nHTML 格式的文件是一个纯本文文件（就是用txt文件改名而成），用一些标签来描述语义，这些标签在浏览器页面上是无法直观看到的，所以称之为“超文本标记语言”。\n\n接下来，我们需要学习 HTML 中的很多“标签对儿”，这些“标签对儿”能够给文本不同的语义。\n\n比如，面试的时候问你，`<h1>` 标签有什么作用？\n\n- 正确答案：给文本增加主标题的语义。\n- 错误答案：给文字加粗、加黑、变大。\n\n关乎“语义”的更深刻理解，等接下来我们学习了各种标签，就明白了。\n\n## HTML的历史\n\n![html中标签发展趋势](http://img.smyhvae.com/20151001_1001.png)\n\n其中，我们专门来对XHTML做一个介绍。\n\n**XHTML介绍：**\nXHTML：Extensible Hypertext Markup Language，可扩展超文本标注语言。\nXHTML的主要目的是为了 `<font color=\"blue\">`**取代HTML** `</font>`，也可以理解为HTML的升级版。\nHTML的标记书写很不规范，会造成其它的设备(ipad、手机、电视等)无法正常显示。\nXHTML与HTML4.0的标记基本上一样。\nXHTML是 `<font color=\"blue\">`**严格的、纯净的** `</font>`HTML。\n\n我们稍后将对XHTML的编写规范进行介绍。\n\n## HTML的专有名词\n\n- 网页 ：由各种标记组成的一个页面就叫网页。\n- 主页(首页) : 一个网站的起始页面或者导航页面。\n- 标记： 比如 `<p>`称为开始标记 ，`</p>`称为结束标记，也叫标签。每个标签都规定好了特殊的含义。\n- 元素：比如 `<p>内容</p>`称为元素.\n- 属性：给每一个标签所做的辅助信息。\n- XHTML：符合XML语法标准的HTML。\n- DHTML：dynamic，动态的。`javascript + css + html`合起来的页面就是一个 DHTML。\n- HTTP：超文本传输协议。用来规定客户端浏览器和服务端交互时数据的一个格式。SMTP：邮件传输协议，FTP：文件传输协议。\n\n## 书写第一个 HTML 页面\n\n我们打开 VS Code 软件，新建一个文件，名叫 `test.html`（注意，文件名是 `test`，后缀名是 `html`），保存到本地。\n\n紧接着，在文件里，输入 `html:5`，然后按一下键盘上的 `Tab`键，就可以自动生成如下内容：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n```\n\n上面的内容，就是 html 页面的骨架。我们在此基础之上，新增几个标签，完整代码如下：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <h3>我是三级标题</h3>\n    <img src=\"\" alt=\"\" />\n    <a href=\"https://www.jd.com\">我是超链接，可以点击一下</a>\n  </body>\n</html>\n```\n\n标签写完之后，我们用 chrome 浏览器打开上面这个 `test.html`文件，看看页面效果：\n\n到此，第一个简单的 HTML 页面就写完了。是不是很有成就感？\n\n## HTML结构详解\n\nHTML标签通常是成对出现的（`<font color=\"blue\">`**双边标记** `</font>`），比如 `<div>` 和 `</div>`；也有少部分单标签（`<font color=\"blue\">`**单边标记** `</font>`），如：`<br />`、`<hr />`和 `<img src=\"images/1.jpg\" />`等。\n\n属性与标记之间、各属性之间需要以空格隔开。属性值以双引号括起来。\n\n#### html骨架标签分类\n\n| 标签名              |    定义    | 说明                                                    |\n| ------------------- | :--------: | :------------------------------------------------------ |\n| `<html></html>`   |  HTML标签  | 页面中最大的标签，我们成为根标签                        |\n| `<head></head>`   | 文档的头部 | 注意在head标签中我们必须要设置的标签是title             |\n| `<title></title>` | 文档的标题 | 让页面拥有一个属于自己的网页标题                        |\n| `<body></body>`   | 文档的主体 | 元素包含文档的所有内容，页面内容 基本都是放到body里面的 |\n\n### 快速生成 html 的骨架\n\n**方式1**：在 VS Code 中新建 html 文件，输入 `html:5`，按 `Tab`键后，自动生成的代码如下：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n```\n\n**方式2**：在Sublime Text中安装 `Emmet`插件。新建html文件，输入 `html:5`，按 `Tab`键后，自动生成的代码如下：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n```\n\n**方式3**：在Sublime Text中安装 `Emmet`插件。新建html文件，输入 `html:xt`，按 `Tab`键后，自动生成的代码如下：\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\n  <head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n```\n\n上面的方式2和方式3中，我们会发现，第一行的内容有些不太一样，这就是我们接下来要讲的**文档声明头**。\n\n### 1、文档声明头\n\n任何一个标准的HTML页面，第一行一定是一个以 `<!DOCTYPE ……>`开头的语句。这一行，就是文档声明头，即 DocType Declaration，简称DTD。\n\n**DTD可告知浏览器文档使用哪种 HTML 或 XHTML 规范**。\n\n#### HTML4.01有哪些规范呢？\n\n**HTML4.01**这个版本是IE6开始兼容的。**HTML5是IE9开始兼容的**。如今，手机、移动端的网页，就可以使用HTML5了，因为其兼容性更高。\n\n说个题外话，html1 至 html3 是美国军方以及高等研究所用的，并未对外公开。\n\nHTML4.01里面有两大种规范，每大种规范里面又各有3种小规范。所以一共6种规范（见下图）。\n\nHTML4.01里面规定了**普通**和**XHTML**两大种规范。HTML觉得自己有一些规定不严谨，比如，标签是否可以用大写字母呢？`<H1></H1>`所以，HTML就觉得，把一些规范严格的标准，又制定了一个XHTML1.0。在XHTML中的字母X，表示“严格的”。\n\n总结一下，HTML4.01一共有6种DTD。说白了，HTML的第一行语句一共有6种情况：\n\n![](http://img.smyhvae.com/20170629_1600.png)\n\n下面对上图中的三种小规范进行解释：\n\n**strict**：\n\n表示“严格的”，这种模式里面的要求更为严格。这种严格体现在哪里？有一些标签不能使用。\n比如，u标签，就是给一个本文加下划线，但是这和HTML的本质有冲突，因为HTML最好是只负责语义，不要负责样式，而u这个下划线是样式。所以，在strict中是不能使用u标签的。\n\n那怎么给文本增加下划线呢？今后将使用css属性来解决。\n\nXHTML1.0更为严格，因为这个体系本身规定比如标签必须是小写字母、必须严格闭合标签、必须使用引号引起属性等等。\n\n**Transitional**：表示“普通的”，这种模式就是没有一些别的规范。\n\n**Frameset**：表示“框架”，在框架的页面使用。\n\n在sublime输入的html:xt，x表示XHTML，t表示transitional。\n\n在HTML5中极大的简化了DTD，也就是说HTML5中就没有XHTML了。HTML5的DTD（文档声明头）如下：\n\n```\n<!DOCTYPE html>\n```\n\n### 2、页面语言 `lang`\n\n下面这行标签，用于指定页面的语言类型：\n\n```html\n<html lang=\"en\"></html>\n```\n\n最常见的语言类型有两种：\n\n- en：定义页面语言为英语。\n- zh-CN：定义页面语言为中文。\n\n### 3、头标签 `head`\n\n#### html5 的比较完整的骨架：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\" />\n    <meta name=\"Author\" content=\"\" />\n    <meta name=\"Keywords\" content=\"厉害很厉害\" />\n    <meta\n      name=\"Description\"\n      content=\"网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。\"\n    />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n```\n\n面试题：\n\n- 问：网页的head标签里面，表示的是页面的配置，有什么配置？\n- 答：字符集、关键词、页面描述、页面标题、IE适配、视口、iPhone小图标等等。\n\n头标签内部的常见标签如下：\n\n- `<title>`：指定整个网页的标题，在浏览器最上方显示。\n- `<base>`：为页面上的所有链接规定默认地址或默认目标。\n- `<meta>`：提供有关页面的基本信息\n- `<body>`：用于定义HTML文档所要显示的内容，也称为主体标签。我们所写的代码必须放在此标签內。\n- `<link>`：定义文档与外部资源的关系。\n\n**meta 标签**：\n\nmeta表示“元”。“元”配置，就是表示基本的配置项目。\n\n常见的几种 meta 标签如下：\n\n（1）字符集 charset：\n\n```html\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\" />\n```\n\n字符集用meta标签中的 `charset`定义，charset就是character set（即“字符集”），即**网页的编码方式**。\n\n**字符集**(Character set)是多个字符的集合。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。\n\n上面这行代码非常关键， 是必须要写的代码，否则可能导致乱码。比如你保存的时候，meta写的和声明的不匹配，那么浏览器就是乱码。\n\nutf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312等。关于“编码方式”，我们在下一段会详细介绍。\n\n（2）视口 viewport：\n\n```html\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n```\n\n`width=device-width` ：表示视口宽度等于屏幕宽度。\n\nviewport 这个知识点，初学者还比较难理解，以后学 Web 移动端的时候会用到。\n\n（3）定义“关键词”：\n\n举例如下：\n\n```html\n<meta name=\"Keywords\" content=\"网易,邮箱,游戏,新闻,体育,娱乐,女性,亚运,论坛,短信\" />\n```\n\n这些关键词，就是告诉搜索引擎，这个网页是干嘛的，能够提高搜索命中率。让别人能够找到你，搜索到你。\n\n（4）定义“页面描述”：\n\nmeta除了可以设置字符集，还可以设置关键字和页面描述。\n\n只要设置Description页面描述，那么百度搜索结果，就能够显示这些语句，这个技术叫做**SEO**（search engine optimization，搜索引擎优化）。\n\n设置页面描述的举例：\n\n```html\n<meta\n  name=\"Description\"\n  content=\"网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。\"\n/>\n```\n\n效果如下：\n\n![](http://img.smyhvae.com/20170629_1743.png)\n\n上面的几种 `<meta>`标签都不用记，但是另外还有一个 `<meta>`标签是需要记住的：\n\n```html\n<meta http-equiv=\"refresh\" content=\"3;http://www.baidu.com\" />\n```\n\n上面这个标签的意思是说，3秒之后，自动跳转到百度页面。\n\n**title 标签**:\n\n用于设置网页标题：\n\n```html\n<title>网页的标题</title>\n```\n\ntitle标签也是有助于SEO搜索引擎优化的。\n\n**base标签**：\n\n```html\n<base href=\"/\" />\n```\n\nbase 标签用于指定基础的路径。指定之后，所有的 a 链接都是以这个路径为基准。\n\n### 4、`<body>`标签\n\n`<body>`标签的属性有：\n\n- `bgcolor`：设置整个网页的背景颜色。\n- `background`：设置整个网页的背景图片。\n- `text`：设置网页中的文本颜色。\n- `leftmargin`：网页的左边距。IE浏览器默认是8个像素。\n- `topmargin`：网页的上边距。\n- `rightmargin`：网页的右边距。\n- `bottommargin`：网页的下边距。\n\n`<body>`标签另外还有一些属性，这里用个例子来解释：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_39.png)\n\n上方代码中，当我们对 `点我点我`这几个字使用超链时，`link`属性表示默认显示的颜色、`alink`属性表示鼠标点击但是还没有松开时的颜色、`vlink`属性表示点击完成之后显示的颜色。效果如下：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_05.gif)\n\n## 计算机编码介绍\n\n计算机，不能直接存储文字，存储的是编码。\n\n计算机只能处理二进制的数据，其它数据，比如：0-9、a-z、A-Z，这些字符，我们可以定义一套规则来表示。假如：A用110表示，B用111表示等。\n\n**ASCII码：**\n美国发布的，用1个字节(8位二进制)来表示一个字符，共可以表示2^8=256个字符。\n美国的国家语言是英语，只要能表示0-9、a-z、A-Z、特殊符号。\n\n**ANSI编码：**\n**每个国家为了显示本国的语言，都对ASCII码进行了扩展**。用2个字节(16位二进制)来表示一个汉字，共可以表示2^16＝65536个汉字。例如：\n中国的ANSI编码是GB2312编码(简体)，对6763汉字进行编码，含600多特殊字符。另外还有GBK(简体)。\n日本的ANSI编码是JIS编码。\n台湾的ANSI编码是BIG5编码（繁体）。\n\n**GBK：**\n对GB2312进行了扩展，用来显示罕见的、古汉语的汉字。现在已经收录了2.1万左右。并提供了1890个汉字码位。K的含义就是“扩展”。\n\n**Unicode编码(统一编码)：**\n用4个字节(32位二进制)来表示一个字符，想法不错，但效率太低。例如，字母A用ASCII表示的话一个字节就够，可用Unicode编码的话，得用4个字节表示，造成了空间的极大浪费。A的Unicode编码是0000 0000 0000 0000 0000 0000 0100 0000\n\n**UTF-8(Unicode Transform Format)编码：**\n根据字符的不同，选择其编码的长度。比如：一个字符A用1个字节表示，一个汉字用2个字节表示。\n\n毫无疑问，开发中，都用**UTF-8**编码吧，准没错。\n\n**中文能够使用的字符集两种：**\n\n- 第一种：UTF-8。UTF-8是国际通用字库，里面涵盖了所有地球上所有人类的语言文字，比如阿拉伯文、汉语、鸟语……\n- 第二种：GBK（对GB2312进行了扩展）。gb2312 是国标，是中国的字库，里面**仅**涵盖了汉字和一些常用外文，比如日文片假名，和常见的符号。\n\n字库规模： UTF-8（字很全） > gb2312（只有汉字）\n\n**重点1：避免乱码**\n\n我们用meta标签声明的当前这个html文档的字库，一定要和保存的文件编码类型一样，否则乱码（重点）。\n\n拿 sublime编辑器举例，当我们不设置的时候，sublime默认类型就是UTF-8。而一旦更改为gb2312的时候，就一定要记得设置一下sublime的保存类型： `文件→ set File Encoding to → Chinese Simplified(GBK)`。VS Code 的道理一样。\n\n**重点2：UTF-8和gb2312的比较**\n\n保存大小：UTF-8（更臃肿、加载更慢） > gb2312 （更小巧，加载更快）\n\n总结：\n\n- UTF-8：字多，有各种国家的语言，但是保存尺寸大，文件臃肿；\n- gb2312：字少，只用中文和少数外语和符号，但是尺寸小，文件小巧。\n\n列出2个使用情形：\n\n1） 你们公司是做日本动漫的，经常出现一些日语动漫的名字，网页要使用UTF-8。如果用gb2312将无法显示日语。\n2） 你们公司就是中文网页，极度的追求网页的显示速度，要使用gb2312。如果使用UTF-8将每个汉字多一个byte，所以5000个汉字，多5kb。\n\n我们亲测：\n\n- qq网、网易、搜狐都是使用gb2312。这些公司，都追求显示速度。\n- 新华网藏语频道，使用的是UTF-8，保证字符集的数量。\n\n我们是怎么查看网页的编码方式的呢？在浏览器中打开网页，右键，选择“查看网页源代码”，找到meta标签中的charset属性即可。\n\n那么，我们为什么可以查看网页的源代码呢？因为这个打开的html网页已经存到我的临时文件夹里了，临时文件夹里的html是纯文本文件，纯文本文件自然可以查看网页的源代码。\n\n## HTML的规范\n\n- HTML不区分大小写，但HTML的标签名、类名、标签属性、大部分属性值建议统一用小写。\n- HTML页面的后缀名是html或者htm(有一些系统不支持后缀名长度超过3个字符，比如dos系统)\n\n### 1、编写XHTML的规范：\n\n（1）所有标记元素都要正确的嵌套，不能交叉嵌套。正确写法举例：`<h1><font></font></h1>`\n\n（2）所有的标记都必须小写。\n\n（3）所有的标签都必须闭合。\n\n- 双标签：`<span></span>`\n- 单标签：`<br>` 建议写成 `<br />` `<hr>` 建议转成 `<hr />`，还有 `<img src=“URL” />`\n\n（4）所有的属性值必须加引号。`<font  color=\"red\"></font>`\n\n（5）所有的属性必须有值。`<hr noshade=\"noshade\">`、`<input  type=\"radio\" checked=\"checked\" />`\n\n（6）XHTML文档开头必须要有DTD文档类型定义。\n\n### 2、HTML的基本语法特性\n\n#### （1）HTML对换行不敏感，对tab不敏感\n\nHTML只在乎标签的嵌套结构，嵌套的关系。谁嵌套了谁，谁被谁嵌套了，和换行、tab无关。换不换行、tab不tab，都不影响页面的结构。\n\n也就是说，HTML不是依靠缩进来表示嵌套的，而是看标签的嵌套关系。但是，我们发现有良好的缩进，代码更易读。建议大家都正确缩进标签。\n\n百度为了追求极致的显示速度，所有HTML标签都没有换行、都没有缩进（tab），HTML和换不换行无关，标签的层次依然清晰，只不过程序员不可读了。如下图所示：\n\n![](http://img.smyhvae.com/20170629_2226.png)\n\n#### （2）空白折叠现象\n\nHTML中所有的**文字之间**，如果有空格、换行、tab都将被折叠为一个空格显示。\n\n举例如下：\n\n![](http://img.smyhvae.com/20170629_2230.jpg)\n\n#### （3）标签要严格封闭\n\n标签不封闭的结果是灾难性的。\n\n标签不封闭的举例如下：\n\n![](http://img.smyhvae.com/20170629_2245.jpg)\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/html/02-初识HTML.md"}},{"pageContent":"---\ntitle: 04-HTML标签：排版标签\npublish: true\n---\n`<ArticleTopAd></ArticleTopAd>`\n\n## 本文主要内容\n\n排版标签：\n\n- `<h1>`\n- `<p>`\n- `<hr />`\n- `<br />`\n- `<div>`\n- `<span>`\n- `<center>`\n- `<pre>`\n\n下面来详细介绍一下排版标签。\n\n## 标题标签\n\n标题使用 `<h1>`至 `<h6>`标签进行定义。`<h1>`定义最大的标题，`<h6>`定义最小的标题。具有align属性，属性值可以是：left、center、right。\n\n代码举例：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t<title>Document</title>\n</head>\n<body>\n\t<h1>H1：千古壹号，永不止步</h1>\n\t<h2>H3：千古壹号，永不止步</h2>\n\t<h3>H3：千古壹号，永不止步</h3>\n\t<h4>H4：千古壹号，永不止步</h4>\n\t<h5>H5：千古壹号，永不止步</h5>\n\t<h6>H6：千古壹号，永不止步</h6>\n</body>\n</html>\n\n```\n\n效果演示：\n\n![](http://img.smyhvae.com/20200402_1050.png)\n\n## HTML 注释\n\nHTML 注释的格式如下：\n\n```html\n<!-- 我是 html 注释  -->\n```\n\n## 段落标签 `<p>`\n\n段落，是英语“paragraph“缩写。\n\n**作用**：可以把 HTML 文档分割为若干段落。在网页中如果要把文字有条理地显示出来，离不开段落标签。就如同我们平常写文章一样，整个网页也可以分为若干个段落。\n\n代码举例：\n\n```html\n<p>This is a paragraph</p>\n<p>This is another paragraph</p>\n```\n\n属性：\n\n- `align=\"属性值\"`：对齐方式。属性值包括left center right。\n\n属性举例：\n\n![Paste_Image.png](http://img.smyhvae.com/2015-10-01-cnblogs_html166440-1dcd2ad6e6353559.png)\n\nHTML标签是分等级的，HTML将所有的标签分为两种：\n\n- **文本级标签**：p、span、a、b、i、u、em。文本级标签里只能放**文字、图片、表单元素**。（a标签里不能放a和input）\n- **容器级标签**：div、h系列、li、dt、dd。容器级标签里可以放置任何东西。\n\n从学习p的第一天开始，就要牢牢记住：**p标签是一个文本级标签，p里面只能放文字、图片、表单元素**。其他的一律不能放。\n\n错误写法：（尝试把 h 放到 p 里）\n\n```html\n\t<p>\n\t\t我是一个小段落\n\t\t<h1>我是一级标题</h1>\n\t</p>\n```\n\n网页效果如下：\n\n![](http://img.smyhvae.com/20170630_1102.png)\n\n上图显示，浏览器不允许你这么做，我们使用Chrome的F12审查元素发现，浏览器自己把p封闭掉了，不让你去包裹h1。\n\nPS：Chrome浏览器是HTML5支持度最好的浏览器。提供了非常好的开发工具，非常适合我们开发人员使用。审查元素功能的快捷键是F12。\n\n## 水平线标签 `<hr />`\n\n> horizontal 单词的发音：[ˌhɒrɪˈzɒntl]。\n\n水平分隔线（horizontal rule）可以在视觉上将文档分隔成各个部分。在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。\n\n代码举例：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t<title>Document</title>\n</head>\n<body>\n\t<p>自古情深留不住</p>\n\t<hr />\n\t<p>总是套路得人心</p>\n</body>\n</html>\n```\n\n运行效果：\n\n![](http://img.smyhvae.com/20200401_1930.png)\n\n属性介绍：\n\n- `align=\"属性值\"`：设定线条置放位置。属性值可选择：left right center。\n- `size=\"2\" `：设定线条粗细。以像素为单位，内定为2。\n- `width=\"500\"`或 `width=\"70%\"`：设定线条长度。可以是绝对值（单位是像素）或相对值。如果设置为相对值的话，内定为100%。\n- `color=\"#0000FF\"`：设置线条颜色。\n- `noshade`：不要阴影，即设定线条为平面显示。若没有这个属性则表明线条具阴影或立体。\n\n属性效果演示：\n\n![Paste_Image.png](http://img.smyhvae.com/2015-10-01-cnblogs_html_05.png)\n\n## 换行标签 `<br />`\n\n如果希望某段文本强制换行显示，就需要使用换行标签。\n\n```html\nThis <br/> is a para<br/>graph with line breaks\n```\n\n效果如下：\n\n![](http://img.smyhvae.com/2015-10-01-cnblogs_html03.png)\n\n## `<div>`和 `<span>`标签\n\ndiv和span是非常重要的标签，div的语义是division“分割”； span的语义就是span“范围、跨度”。想必你应该听说过“div + css”布局。\n\n### div和span的介绍\n\n- **div标签**：可以把标签中的内容分割为独立的区块。必须单独占据一行。\n- **span标签**：和div的作用一致，但不换行。\n\n代码举例：\n\n![Paste_Image.png](http://img.smyhvae.com/2015-10-01-cnblogs_html_08.png)\n\ndiv标签的属性：\n\n- `align=\"属性值\"`：设置块儿的位置。属性值可选择：left、right、 center。\n\n### div和span的区别\n\n`<span>`和 `<div>`唯一的区别在于：`<span>`是不换行的，而 `<div>`是换行的。\n\n如果单独在网页中插入这两个元素，不会对页面产生任何的影响。这两个元素是专门为定义CSS样式而生的。或者说，DIV+CSS来实现各种样式。\n\ndiv在浏览器中，默认是不会增加任何的效果的，但是语义变了，div中的所有元素是一个小区域。\ndiv标签是一个**容器级**标签，里面什么都能放，甚至可以放div自己。\n\nspan也是表达“小区域、小跨度”的标签，但只是一个**文本级**的标签。\n就是说，span里面只能放置文字、图片、表单元素。 span里面不能放p、h、ul、dl、ol、div。\n\nspan举例：\n\n```html\n<p>\n\t简介简介简介简介简介简介简介简介\n\t<span>\n\t\t<a href=\"\">详细信息</a>\n\t\t<a href=\"\">购买</a>\n\t</span>\n</p>\n\n```\n\ndiv举例：\n\n```html\n<div class=\"header\">\n\t<div class=\"logo\"></div>\n\t<div class=\"nav\"></div>\n</div>\n<div class=\"content\">\n\t<div class=\"guanggao\"></div>\n\t<div class=\"dongxi\"></div>\n</div>\n<div class=\"footer\"></div>\n```\n\n我们亲切地称这种模式叫做“**div+css**”：**div标签负责布局、结构、分块，css负责样式**。\n\n## 内容居中标签 `<center>`\n\n此时center代表是一个标签，而不是一个属性值了。只要是在这个标签里面的内容，都会居于浏览器的中间。\n效果演示：\n\n![Paste_Image.png](http://img.smyhvae.com/2015-10-01-cnblogs_html_06.png)\n\n到了HTML5里面，center标签不建议使用，建议使用css布局来实现。\n\n## 预定义（预格式化）标签 `<pre>`\n\n含义：将保留标签内部所有的空白字符(空格、换行符)，原封不动地输出结果（告诉浏览器不要忽略空格和空行）。\n\n说明：真正排网页过程中，`<pre>`标签几乎用不着。\n效果演示：\n\n![Paste_Image.png](http://img.smyhvae.com/2015-10-01-cnblogs_html_07.png)\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/html/03-HTML标签：排版标签.md"}},{"pageContent":"---\ntitle: 05-HTML标签：字体标签和超链接\npublish: true\n---\n`<ArticleTopAd></ArticleTopAd>`\n\n## 本文主要内容\n\n字体标签： `<font>`、 `<b>`、 `<u>` 、`<sup>` 、`<sub>`\n\n超链接 `<a>`\n\n## 字体标签\n\n### 特殊字符（转义字符）\n\n- `&nbsp;`：空格\t（non-breaking spacing，不断打空格）\n- `&lt;`：小于号 `<`（less than）\n- `&gt;`：大于号 `>`（greater than）\n- `&amp;`：符号 `&`\n- `&quot;`：双引号\n- `&apos;`：单引号\n- `&copy;`：版权 `©`\n- `&trade;`：商标 `™`\n- `&#32464;`：文字 `绐`。其实，`#32464`是汉字 `绐`的unicode编码。\n\n比如说，你想把 `<p>`作为一个文本在页面上显示，直接写 `<p>`是肯定不行的，因为这代表的是一个段落标签，所以这里需要用到**转义字符**。应该这么写：\n\n```html\n这是一个HTML语言的<p>标签\n```\n\n正确的效果如下：\n\n![Paste_Image.png](http://img.smyhvae.com/2015-10-01-cnblogs_html_11.png)\n\n错误的效果如下：\n\n![Paste_Image.png](http://img.smyhvae.com/2015-10-01-cnblogs_html_12.png)\n\n其实我们只要记住前三个符号就行了，其他的在需要的时候查一下就行了。而且，EditPlus软件中是可以直接点击这些符号进行选择的：\n\n![Paste_Image.png](http://img.smyhvae.com/2015-10-01-cnblogs_html_13.png)\n\n来一张表格，方便需要的时候查询：\n\n| 特殊字符 | 描述           | 字符的代码   |\n| :------- | :------------- | :----------- |\n|          | 空格符         | `&nbsp;`   |\n| <        | 小于号         | `&lt;`     |\n| >        | 大于号         | `&gt;`     |\n| &        | 和号           | `&amp;`    |\n| ￥       | 人民币         | `&yen;`    |\n| ©       | 版权           | `&copy;`   |\n| ®       | 注册商标       | `&reg;`    |\n| °       | 摄氏度         | `&deg;`    |\n| ±       | 正负号         | `&plusmn;` |\n| ×       | 乘号           | `&times;`  |\n| ÷       | 除号           | `&divide;` |\n| ²       | 平方2（上标2） | `&sup2;`   |\n| ³       | 立方3（上标3） | `&sup3;`   |\n\n### 下划线、中划线、斜体\n\n- `<u>`：下划线标记\n- `<s>`或 `<del>`：中划线标记（删除线）\n- `<i>`或 `<em>`：斜体标记\n\n效果：\n\n![Paste_Image.png](http://img.smyhvae.com/2015-10-01-cnblogs_html_15.png)\n\n上面的这几个标签，常用于做一些小装饰、小图标。比如：\n\n![](http://img.smyhvae.com/20180118_2340.png)\n\n这张图中，我们通过查看京东网站的代码发现，箭头处的小图标都是用的标签 `<i>`。\n\n### 粗体标签 `<b>`或 `<strong>`（已废弃）\n\n效果：\n\n![Paste_Image.png](http://img.smyhvae.com/2015-10-01-cnblogs_html_14.png)\n\n### 字体标签 `<font>`（已废弃）\n\n属性：\n\n- `color=\"红色\"`或 `color=\"#ff00cc\"`或 `color=\"new rgb(0,0,255)\"`：设置字体颜色。\n  设置方式：单词 \\  #ff00cc \\   rgb(0,0,255)\n- `size`：设置字体大小。 取值范围只能是：1至7。取值时，如果取值大于7那就按照7来算，如果取值小于1那就按照1来算。如果想要更大的字体，那就只能通过css样式来解决。\n- `face=\"微软雅黑\"`：设置字体类型。\n\n举例：\n\n```html\n<font face=\"微软雅黑\" color=\"#FF0000\" size=\"10\">vae</font>\n```\n\n效果：\n\n![Paste_Image.png](http://img.smyhvae.com/2015-10-01-cnblogs_html_10.png)\n\n### 上标 `<sup>`   下标 `<sub>`\n\n上小标这两个标签容易混淆，怎么记呢？这样记：`b`的意思是 `bottom：底部`\n举例：\n\n```html\nO<sup>2</sup>    5<sub>3</sub>\n```\n\n效果：\n\n![Paste_Image.png](http://img.smyhvae.com/2015-10-01-cnblogs_html_16.png)\n\n## 三、超链接\n\n超链接有三种形式，下面分别讲讲。\n\n### 1、外部链接：链接到外部文件\n\n举例：\n\n```html\n<a href=\"02页面.html\">点击进入另外一个文件</a>\n```\n\na是英语 `anchor`“锚”的意思，就好像这个页面往另一个页面扔出了一个锚。是一个文本级的标签。\n\nhref（hypertext reference）：超文本地址。读作“喝瑞夫”，不要读作“喝夫”。\n\n效果：\n\n![Paste_Image.png](http://img.smyhvae.com/2015-10-01-cnblogs_html_17.png)\n\n当然，我们也可以直接点进链接，访问一个网址。代码举例如下：\n\n```html\n<a href=\"http://www.baidu.com\" target=\"_blank\">点我点我</a>\n```\n\n### 2、锚链接\n\n**锚链接**：给超链接起一个名字，作用是**在本页面或者其他页面的的不同位置进行跳转**。比如说，在网页底部有一个向上箭头，点击箭头后回到顶部，这个就可以利用锚链接。\n\n首先我们要创建一个**锚点**，也就是说，使用 `name`属性或者 `id`属性给那个特定的位置起个名字。效果如下：\n\n![Paste_Image.png](http://img.smyhvae.com/2015-10-01-cnblogs_html_18.png)\n\n上图中解释：\n\n第11行代码表示，顶部这个锚的名字叫做name1。\n然后在底部设置超链接，点击时将回到顶部（此时，网页中的url的末尾也出现了 `#name1`）。注意**上图中红框部分的 `#`号不要忘记了**，表示跳到名为name1的特定位置，这是规定。如果少了 `#`号，点击之后，就会跳到name1这个文件或者name1这个文件夹中去。\n\n如果我们将上图中的第28行代码写成：\n\n```html\n<a href=\"a.html#name1\">回到顶部</a>\n```\n\n那就表示，点击之后，跳转到 `a.html`页面的 `name1锚点`中去。\n\n说明：name属性是HTML4.0以前使用的，id属性是HTML4.0后才开始使用。为了向前兼容，因此，name和id这两个属性都要写上，并且值是一样的。\n\n### 3、邮件链接\n\n代码举例：\n\n```html\n<a href=\"mailto:xxx@163.com\">点击进入我的邮箱</a>\n```\n\n效果：点击之后，会弹出outlook，作用不大。\n\n### 超链接的属性\n\n- `href`：目标URL\n- `title`：悬停文本。\n- `name`：主要用于设置一个锚点的名称。\n- `target`：告诉浏览器用什么方式来打开目标页面。`target`属性有以下几个值：\n  - `_self`：在同一个网页中显示（默认值）\n  - `_blank`：**在新的窗口中打开**。\n  - `_parent`：在父窗口中显示\n  - `_top`：在顶级窗口中显示\n\n`title`属性举例：\n\n```html\n<a href=\"09_img.html\" title=\"很好看哦\">结婚照</a>\n```\n\n效果如下：\n\n![](http://img.smyhvae.com/20170630_1415.png)\n\n`target`属性举例：\n\n```html\n<a href=\"1.html\" title=\"悬停文本\" target=\"_blank\">链接的内容</a>\n```\n\nblank就是“空白”的意思，就表示新建一个空白窗口。为啥有一个_ ，就是规定，无需解释。\n也就是说，如果不写 `target=”_blank”`那么就是在相同的标签页打开，如果写了 `target=”_blank”`，就是在新的空白标签页中打开。\n\n#### 备注1：分清楚img和a标签的各自的属性\n\n区别如下：\n\n```html\n<img src=\"1.jpg\" />\n<a href=\"1.html\"></a>\n```\n\n#### 备注2：a是一个文本级的标签\n\n比如一个段落中的所有文字都能够被点击，那么应该是p包裹a：\n\n```html\n<p>\n\t<a href=\"\">段落段落段落段落段落段落</a>\n</p>\n```\n\n而不是a包裹p：\n\n```html\n<a href=\"\">\n\t<p>\n\t\t段落段落段落段落段落段落\n\t</p>\n</a>\n```\n\na的语义要小于p，a就是可以当做文本来处理，所以p里面相当于放的就是纯文字。\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/html/04-HTML标签：字体标签和超链接.md"}},{"pageContent":"---\ntitle: 06-HTML标签：图片标签\npublish: true\n---\n\n`<ArticleTopAd></ArticleTopAd>`\n\n## img标签介绍\n\n### 介绍\n\nimg: 英文全称 image（图像），代表的是一张图片。\n\n如果要想在网页中显示图像，就可以使用img 标签，它是一个单标签。语法如下：\n\n```html\n<img src=\"图片的URL\" />\n```\n\n### 能插入的图片类型\n\n- 能够插入的图片类型是：jpg(jpeg)、gif、png、bmp等。\n- 不能往网页中插入的图片格式是：psd、ai等。\n\nHTML页面不是直接插入图片，而是插入图片的引用地址，所以要先把图片上传到服务器上。\n\n## img标签的 `src`属性\n\n这里涉及到图片的一个属性：\n\n- `src`属性：指图片的路径。英文名称 source。\n\n在写**图片的路径**时，有两种写法：相对路径、绝对路径\n\n### 写法一：图片的相对路径\n\n相对当前页面所在的路径。两个标记 `.` 和 `..` 分表代表当前目录和上一层目录。\n\n举例1：\n\n```html\n<!-- 当前目录中的图片 -->\n<img src=\"2.jpg\" />\n<img src=\"./2.jpg\" />\n\n<!-- 上一级目录中的图片 -->\n<img src=\"../2.jpg\" />\n```\n\n相对路径不会出现这种情况：\n\n```html\naaa/../bbb/1.jpg\n```\n\n`../`要么不写，要么就写在开头。\n\n举例2：\n\n```html\n<img src=\"images/1.jpg\" />\n```\n\n上方代码的意思是说，当前html页面有一个并列的文件夹 `images`，在文件夹 `images`中存放了一张图片 `1.jpg`\n效果：\n\n![Paste_Image.png](http://img.smyhvae.com/20151001_19.jpg)\n\n相对路径的面试题。现有如下文件层级图：\n\n![](http://img.smyhvae.com/20170630_1133.png)\n\n问题：如果想在index.html中插入1.png，那么对应的img语句是？\n\n分析：\n\n现在document是最大的文件夹，里面有两个文件夹work和photo。work中又有一个文件夹叫做myweb。myweb文件夹里面有index.html。 所以index.html在myweb文件夹里面，上一级就是work文件夹，上两级就是document文件夹。通过document文件夹当做一个中转站，进入photo文件夹，看到了1.png。\n\n答案：\n\n```html\n<img src=\"../../photo/1.png\" />\n```\n\n### 写法二：图片的绝对路径\n\n绝对路径包括以下两种：\n\n（1）以盘符开始的绝对路径。举例：\n\n```html\n<img src=\"C:\\Users\\qianguyihao\\Desktop\\html\\images\\1.jpg\" />\n```\n\n（2）网络路径。举例：\n\n```html\n<img src=\"http://img.smyhvae.com/20200122_200901.png\" />\n```\n\n大家打开上面的img中的链接，可能有彩蛋哦。\n\n### 相对路径和绝对路径的总结\n\n相对路径的好处：站点不管拷贝到哪里，文件和图片的相对路径关系都是不变的。相对路径使用有一个前提，就是网页文件和你的图片，必须在一个服务器上。\n\n**总结一下**：\n\n无论是在 a 标签还是 img 标签上，如果要用路径。只有两种路径能用，就是相对路径和绝对路径：\n\n- 相对路径从自己出发，找到别人。\n- 绝对路径，就是 `http://`或者 `https://`开头的路径。\n\n## img标签的其他属性\n\n### width、height 属性\n\n- `width`：图像的宽度。\n- `height`：图像的高度。\n\nwidth和height，在 HTML5 中的单位是 CSS 像素，在 HTML 4 中既可以是像素，也可以是百分比。可以只指定 width 和 height 中的一个值，浏览器会根据原始图像进行缩放。\n\n**重要提示**：如果要想保证图片等比例缩放，请只设置width和height中其中一个。\n\n### Alt 属性\n\n- `alt`：当图片不可用（无法显示）的时候，代替图片显示的内容。alt是英语 alternate “替代”的意思，代表替换资源。\n\n`Alt`属性效果演示：\n\n![Paste_Image.png](http://img.smyhvae.com/2015-10-01-cnblogs_html_21.png)\n\n如上图所示：当图片 src 不可用的时候，显示文字。这样做，至少能让用户知道，这个图片大概是什么内容。\n\n### title 属性\n\n- `title`：**提示性文本**。鼠标悬停时出现的文本。\n\ntitle 属性不该被用作一幅图片在 alt 之外的补充说明信息。如果一幅图片需要小标题，使用 figure 或 figcaption 元素。\n\ntitle 元素的值一般作为提示条(tooltip)呈现给用户，在光标于图片上停下后显示出来。尽管这确实能给用户提供更多的信息，您不该假定用户真的能看到：用户可能只有键盘或触摸屏。如果要把特别重要的信息提供给用户，可以选择上面提供的一种方法将其内联显示，而不是使用 title。\n\n举例：\n\n```html\n<img src=\"images/1.jpg\" width=\"300\" height=\"`188\" title=\"这是美女\" />\n```\n\n效果：\n\n![Paste_Image.png](http://img.smyhvae.com/2015-10-01-cnblogs_html_20.png)\n\n### align 属性\n\n- 图片的 `align`属性：**图片和周围文字的相对位置**。属性取值可以是：bottom（默认）、center、top、left、right。\n\n如果想实现图文混排的效果，请使用align属性，取值为left或right。\n\n我们来分别看一下这 `align`属性的这几个属性值的区别。\n\n1、`align=\"\"`，图片和文字底端对齐。即默认情况下的显示效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_19.png)\n\n2、`align=\"center\"`：图片和文字水平方向上居中对齐。显示效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_21.png)\n\n3、`align=\"top\"`：图片与文字顶端对齐。显示效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_22.png)\n\n4、`align=\"left\"`：图片在文字的左边。显示效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_23.png)\n\n5、`align=\"right\"`：图片在文字的右边。显示效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_24.png)\n\n### 其他已废弃的属性\n\n- `Align`（已废弃）：指图片的水平对齐方式，属性值可以是：top、middle、bottom、left、center、right。该属性已废弃，替换为 `vertical-align`这个CSS属性。\n- `border`（已废弃）：给图片加边框，单位是像素，边框的颜色默认黑色。该属性已废弃，替换为 `border`这个CSS属性。\n- `Hspace`（已废弃）：指图片左右的边距。\n- `Vspace`（已废弃）：指图片上下的边距。\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/html/05-HTML标签：图片标签.md"}},{"pageContent":"---\ntitle: 07-HTML标签图文详解（二）\n---\n`<ArticleTopAd></ArticleTopAd>`\n\n## 本文主要内容\n\n- 列表标签：`<ul>`、`<ol>`、`<dl>`\n- 表格标签：`<table>`\n- 框架标签及内嵌框架 `<iframe>`\n- 表单标签：`<form>`\n- 多媒体标签\n- 滚动字幕标签：`<marquee>`\n\n## 列表标签\n\n列表标签分为三种。\n\n### 1、无序列表 `<ul>`，无序列表中的每一项是 `<li>`\n\n英文单词解释如下：\n\n- ul：unordered list，“无序列表”的意思。\n- li：list item，“列表项”的意思。\n\n例如：\n\n```html\n<ul>\n\t<li>默认1</li>\n\t<li>默认2</li>\n\t<li>默认3</li>\n</ul>\n```\n\n效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_01.png)\n\n注意：\n\n- li不能单独存在，必须包裹在ul里面；反过来说，ul的“儿子”不能是别的东西，只能有li。\n- 我们这里再次强调，ul的作用，并不是给文字增加小圆点的，而是增加无序列表的“语义”的。\n\n**属性：**\n\n- `type=\"属性值\"`。属性值可以选： `disc`(实心原点，默认)，`square`(实心方点)，`circle`(空心圆)。\n  效果如下：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_02_1.png)\n\n不光是 `<ul>`标签有 `type`属性，`<ul>`里面的 `<li>`标签也有 `type`属性（虽然说这种写法很少见）。效果如下：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_03.png)\n\n注意：项目符号可以是图片，需要通过CSS设置 `<li>`标记的背景图片来实现(CSS中讲)。\n\n当然了，列表之间是可以**嵌套**的。我们来举个例子。代码：\n\n```html\n  <ul>\n\t<li><b>北京市</b>\n\t\t<ul>\n\t\t\t<li>海淀区</li>\n\t\t\t<li>朝阳区</li>\n\t\t\t<li>东城区</li>\n\n\t\t</ul>\n\t</li>\n\n\t<li><b>广州市</b>\n\t\t<ul>\n\t\t\t<li>天河区</li>\n\t\t\t<li>越秀区</li>\n\t\t</ul>\n\t</li>\n  </ul>\n```\n\n效果：\n\n![](http://img.smyhvae.com/2015-10-01-cnblogs_html_40.png)\n\n**css 属性**：\n\n```css\nlist-style-position: inside   /* 给 ul 设置这个属性后，将小圆点包含在 li 元素的内部 */\n```\n\n#### ul标签实际应用场景：\n\n场景1、导航条：\n\n![20211031_1617](https://img.smyhvae.com/20211031_1617.png)\n\n场景2、li 里面放置的内容可能很多：\n\n![](http://img.smyhvae.com/20170704_1719.png)\n\n声明：ul的儿子，只能是li。但是li是一个容器级标签，**li里面什么都能放，甚至可以再放一个ul**。\n\n### 2、有序列表 `<ol>`，里面的每一项是 `<li>`\n\n英文单词：Ordered List。\n\n例如：\n\n```html\n<ol >\n\t<li>呵呵哒1</li>\n\t<li>呵呵哒2</li>\n\t<li>呵呵哒3</li>\n</ol>\n```\n\n效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_04.png)\n\n**属性：**\n\n- `type=\"属性值\"`。属性值可以是：1(阿拉伯数字，默认)、a、A、i、I。结合 `start`属性表示 `从几开始`。\n\n举例：\n\n```html\n<ol type=\"1\">\n\t<li>呵呵</li>\n\t<li>呵呵</li>\n\t<li>呵呵</li>\n</ol>\n\n<ol type=\"a\">\n\t<li>嘿嘿</li>\n\t<li>嘿嘿</li>\n\t<li>呵呵</li>\n</ol>\n\n<ol type=\"i\" start=\"4\">\n\t<li>哈哈</li>\n\t<li>哈哈</li>\n\t<li>哈哈</li>\n</ol>\n\n<ol type=\"I\" start=\"10\">\n\t<li>么么</li>\n\t<li>么么</li>\n\t<li>么么</li>\n</ol>\n```\n\n效果如下：\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_07.png)\n\n和无序列表一样，有序列表也是可以嵌套的哦，这里就不举类似的例子了。\n\nol和ul就是语义不一样，怎么使用都是一样的。\nol里面只能有li，li必须被ol包裹。li是容器级。\n\nol这个东西用的不多，如果想表达顺序，大家一般也用ul。举例如下：\n\n```html\n<ul>\n\t<li>1. 小苹果</li>\n\t<li>2. 月亮之上</li>\n\t<li>3. 最炫民族风</li>\n</ul>\n```\n\n### 3、定义列表 `<dl>`\n\n> 定义列表的作用非常大。\n\n`<dl>`英文单词：definition list，没有属性。dl的子元素只能是dt和dd。\n\n- `<dt>`：definition title 列表的标题，这个标签是必须的\n- `<dd>`：definition description 列表的列表项，如果不需要它，可以不加\n\n备注：dt、dd只能在dl里面；dl里面只能有dt、dd。\n\n举例：\n\n```html\n<dl>\n\t<dt>第一条</dt>\n\t<dd>你若是觉得你有实力和我玩，良辰不介意奉陪到底</dd>\n\t<dd>我会让你明白，我从不说空话</dd>\n\t<dd>我是本地的，我有一百种方式让你呆不下去；而你，无可奈何</dd>\n\n\t<dt>第二条</dt>\n\t<dd>良辰最喜欢对那些自认能力出众的人出手</dd>\n\t<dd>你可以继续我行我素，不过，你的日子不会很舒心</dd>\n\t<dd>你只要记住，我叫叶良辰</dd>\n\t<dd>不介意陪你玩玩</dd>\n\t<dd>良辰必有重谢</dd>\n\n</dl>\n```\n\n效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_09.png)\n\n上图可以看出，定义列表表达的语义是两层：\n\n- （1）是一个列表，列出了几个dd项目\n- （2）每一个词儿都有自己的描述项。\n\n备注：dd是描述dt的。\n\n定义列表用法非常灵活，可以一个dt配很多dd：\n\n```html\n\t<dl>\n\t\t<dt>北京</dt>\n\t\t<dd>国家首都，政治文化中心</dd>\n\t\t<dd>污染很严重，PM2.0天天报表</dd>\n\t\t<dt>上海</dt>\n\t\t<dd>魔都，有外滩、东方明珠塔、黄浦江</dd>\n\t\t<dt>广州</dt>\n\t\t<dd>中国南大门，有珠江、小蛮腰</dd>\n\t</dl>\n```\n\n还可以拆开，让每一个dl里面只有一个dt和dd，这样子感觉清晰一些：\n\n```html\n\t<dl>\n\t\t<dt>北京</dt>\n\t\t<dd>国家首都，政治文化中心</dd>\n\t\t<dd>污染很严重，PM2.0天天报表</dd>\n\t</dl>\n\n\t<dl>\n\t\t<dt>上海</dt>\n\t\t<dd>魔都，有外滩、东方明珠塔、黄浦江</dd>\n\t</dl>\n\n\t<dl>\n\t\t<dt>广州</dt>\n\t\t<dd>中国南大门，有珠江、小蛮腰</dd>\n\t</dl>\n```\n\n真实案例：（京东最下方）\n\n![](http://img.smyhvae.com/20170704_1727.png)\n\n上图中的结构如下：\n\n```html\n<dl>\n\t<dt>购物指南</dt>\n\t<dd>\n\t\t<a href=\"#\">购物流程</a>\n\t\t<a href=\"#\">会员介绍</a>\n\t\t<a href=\"#\">生活旅行/团购</a>\n\t\t<a href=\"#\">常见问题</a>\n\t\t<a href=\"#\">大家电</a>\n\t\t<a href=\"#\">联系客服</a>\n\t</dd>\n</dl>\n<dl>\n\t<dt>配送方式</dt>\n\t<dd>\n\t\t<a href=\"#\">上门自提</a>\n\t\t<a href=\"#\">211限时达</a>\n\t\t<a href=\"#\">配送服务查询</a>\n\t\t<a href=\"#\">配送费收取标准</a>\n\t\t<a href=\"#\">海外配送</a>\n\t</dd>\n</dl>\n\n```\n\n京东商品分类如下：\n\n![](http://img.smyhvae.com/20170704_1729.png)\n\ndt、dd都是容器级标签，想放什么都可以。所以，现在就应该更加清晰的知道：用什么标签，不是根据样子来决定，而是语义（语义本质上是结构）。\n\n## 表格标签\n\n表格标签用 `<table>`表示。\n一个表格 `<table>`是由每行 `<tr>`组成的，每行是由每个单元格 `<td>`组成的。\n所以我们要记住，一个表格是由行组成的（行是由列组成的），而不是由行和列组成的。\n在以前，要想固定标签的位置，唯一的方法就是表格。现在可以通过CSS定位的功能来实现。但是现在在做页面的时候，表格作用还是有一些的。\n\n例如，一行的单元格：\n\n```html\n<table>\n\t<tr>\n\t\t<td></td>\n\t\t<td></td>\n\t\t<td></td>\n\t\t<td></td>\n\t</tr>\n</table>\n```\n\n上面的表格中没有加文字，所以在生成的网页中什么都看不到。\n例如，3行4列的单元格：\n\n```html\n<table>\n\t<tr>\n\t\t<td>千古壹号</td>\n\t\t<td>23</td>\n\t\t<td>男</td>\n\t\t<td>黄冈</td>\n\t</tr>\n\n\t<tr>\n\t\t<td>许嵩</td>\n\t\t<td>29</td>\n\t\t<td>男</td>\n\t\t<td>安徽</td>\n\t</tr>\n\n\t<tr>\n\t\t<td>邓紫棋</td>\n\t\t<td>23</td>\n\t\t<td>女</td>\n\t\t<td>香港</td>\n\t</tr>\n\n</table>\n```\n\n效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_10.png)\n\n上图中的表格好像没看到边框呀，不急，接下来看看 `<table>`标签的属性。\n\n**`<table>`的属性：**\n\n- `border`：边框。像素为单位。\n- `style=\"border-collapse:collapse;\"`：单元格的线和表格的边框线合并（表格的两边框合并为一条）\n- `width`：宽度。像素为单位。\n- `height`：高度。像素为单位。\n- `bordercolor`：表格的边框颜色。\n- `align`：**表格**的水平对齐方式。属性值可以填：left right center。\n  注意：这里不是设置表格里内容的对齐方式，如果想设置内容的对齐方式，要对单元格标签 `<td>`进行设置）\n- `cellpadding`：单元格内容到边的距离，像素为单位。默认情况下，文字是紧挨着左边那条线的，即默认情况下的值为0。\n  注意不是单元格内容到四条边的距离哈，而是到一条边的距离，默认是与左边那条线的距离。如果设置属性 `dir=\"rtl\"`，那就指的是内容到右边那条线的距离。\n- `cellspacing`：单元格和单元格之间的距离（外边距），像素为单位。默认情况下的值为0\n- `bgcolor=\"#99cc66\"`：表格的背景颜色。\n- `background=\"路径src/...\"`：背景图片。\n  背景图片的优先级大于背景颜色。\n- `bordercolorlight`：表格的上、左边框，以及单元格的右、下边框的颜色\n- `bordercolordark`：表格的右、下边框，以及单元格的上、左的边框的颜色\n  这两个属性的目的是为了设置3D的效果。\n- `dir`：公有属性，单元格内容的排列方式(direction)。 可以 取值：`ltr`：从左到右（left to right，默认），`rtl`：从右到左（right to left）\n  既然说 `dir`是共有属性，如果把这个属性放在任意标签中，那表明这个标签的位置可能会从右开始排列。\n\n单元格带边框的效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_11.png)\n\n备注：表格中很细表格边线的制作，CSS的写法：\n\n```css\nstyle=\"border-collapse:collapse;\"\n```\n\n### `<tr>`：行\n\n一个表格就是一行一行组成的。\n\n**属性：**\n\n- `dir`：公有属性，设置这一行单元格内容的排列方式。可以取值：\n  - `ltr`：从左到右（left to right，默认）\n  - `rtl`：从右到左（right to left）\n- `bgcolor`：设置这一行的单元格的背景色。\n  注：没有background属性，即：无法设置这一行的背景图片，如果非要设置，可以用css实现。\n- `height`：一行的高度\n- `align=\"center\"`：一行的内容水平居中显示，取值：left、center、right\n- `valign=\"center\"`：一行的内容垂直居中，取值：top、middle、bottom\n\n### `<td>`：单元格\n\n**属性：**\n\n- `align`：内容的横向对齐方式。属性值可以填：left right center。如果想让每个单元格的内容都居中，这个属性太麻烦了，以后用css来解决。\n- `valign`：内容的纵向对齐方式。属性值可以填：top middle bottom\n- `width`：绝对值或者相对值(%)\n- `height`：单元格的高度\n- `bgcolor`：设置这个单元格的背景色。\n- `background`：设置这个单元格的背景图片。\n\n### 单元格的合并\n\n单元格的属性：\n\n- `colspan`：横向合并。例如 `colspan=\"2\"`表示当前单元格在水平方向上要占据两个单元格的位置。\n- `rowspan`：纵向合并。例如 `rowspan=\"2\"`表示当前单元格在垂直方向上要占据两个单元格的位置。\n\n效果举例：（横向合并）\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_13.png)\n\n效果举例：（纵向合并）\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_15.png)\n\n### `<th>`：加粗的单元格。相当于 `<td>` + `<b>`\n\n- 属性同 `<td>`标签。\n\n### `<caption>`：表格的标题。使用时和 `tr`标签并列\n\n- 属性：`align`，表示标题相对于表格的位置。属性取值可以是：left、center、right、top、bottom\n  效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_16.png)\n\n### 表格的 `<thead>`标签、`<tbody>`标签、`<tfoot>`标签\n\n这三个标签有与没有的区别：\n\n- 1、如果写了，那么这三个部分的**代码顺序可以任意**，浏览器显示的时候还是按照thead、tbody、tfoot的顺序依次来显示内容。如果不写thead、tbody、tfoot，那么浏览器解析并显示表格内容的时候是从按照代码的从上到下的顺序来显示。\n- 2、当表格非常大内容非常多的时候，如果用thead、tbody、tfoot标签的话，那么**数据可以边获取边显示**。如果不写，则必须等表格的内容全部从服务器获取完成才能显示出来。\n\n举例：\n\n```html\n <body>\n\n\t<table border=\"1\">\n\n\t\t<tbody>\n\t\t<tr>\n\t\t\t<td>生命壹号</td>\n\t\t\t<td>23</td>\n\t\t\t<td>男</td>\n\t\t\t<td>黄冈</td>\n\t\t</tr>\n\t\t</tbody>\n\n\t\t<tfoot>\n\t\t<tr>\n\t\t\t<td>许嵩</td>\n\t\t\t<td>29</td>\n\t\t\t<td>男</td>\n\t\t\t<td>安徽</td>\n\t\t</tr>\n\t\t</tfoot>\n\n\t\t<thead>\n\t\t<tr>\n\t\t\t<td>邓紫棋</td>\n\t\t\t<td>23</td>\n\t\t\t<td>女</td>\n\t\t\t<td>香港</td>\n\t\t</tr>\n\t\t</thead>\n\n\t</table>\n\n </body>\n```\n\n效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_17.png)\n\n## 框架标签\n\n如果我们希望在一个网页中显示多个页面，那框架标签就派上用场了。\n\n> - 注意，框架标签不能放在 `<body>`标签里面，因为 `<body>`标签代表的只是一个页面，而框架标签代表的是多个页面。于是：`<frameset>`和 `<body>`只能二选一。\n> - 框架的集合用 `<frameset>`表示，然后在 `<frameset>`集合里放入一个一个的框架 `<frame>`\n\n**补充**：`frameset`和 `frame`已经从 Web标准中删除，建议使用 iframe 代替。\n\n### `<frameset>`：框架的集合\n\n一个框架的集合可以包含多个框架或框架的集合。**属性：**\n\n- `rows`：水平分割，将框架分为上下部分。写法有两种：\n\n1、绝对值写法：`rows=\"200,*\"`  其中 `*`代表剩余的。这里其实包含了两个框架：上面的框架占200个像素，下面的框架占剩下的部分。\n\n2、相对值写法：`rows=\"30%,*\"`  其中 `*`代表剩余的。这里其实包含了两个框架：上面的框架占30%，下面的框架占70%。\n\n注：如果你想将框架分成很多行，在属性值里用逗号隔开就行了。\n\n- `cols`：垂直分割，将框架分为左右部分。写法有两种：\n\n1、绝对值写法：`cols=\"200,*\"`  其中 `*`代表剩余的。这里其实包含了两个框架：左边的框架占200个像素，右边的框架占剩下的部分。\n\n2、相对值写法：`cols=\"30%,*\"`  其中 `*`代表剩余的。这里其实包含了两个框架：左边的框架占30%，右边的框架占70%。\n\n注：如果你想将框架分成很多列，在属性值里用逗号隔开就行了。\n\n效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_26.png)\n\n上图中，如果删掉页面right.html，显示效果如下：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_27.png)\n\n### `<frame>`：框架\n\n一个框架显示一个页面。\n\n**属性：**\n\n- `scrolling=\"no\"`：是否需要滚动条。默认值是true。\n- `noresize`：不可以改变框架大小。默认情况下，单个框架的边界是可以拖动的，这样的话，框架大小就不固定了。如果用了这个属性值，框架大小将固定。\n\n举例：\n\n```html\n<frame src=\"top.html\" noresize></frame>\n```\n\n- `bordercolor=\"#00FF00\"`：给框架的边框定义颜色。这个属性在框架集合 `<frameset>`中同样适用。\n  颜色这个属性在IE浏览器中生效，但是在google浏览器中无效，不知道为啥。\n- `frameborder=\"0\"`或 `frameborder=\"1\"`：隐藏或显示边框（框架线）。\n- `name`：给框架起一个名字。\n\n利用 `name`这个属性，我们可以在框架里进行超链。\n\n举例：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_28.png)\n\n效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_gif3.gif)\n\n## 内嵌框架\n\n内嵌框架用 `<iframe>`表示。`<iframe>`是 `<body>`的子标记。\n\n内嵌框架inner frame：嵌入在一个页面上的框架(仅仅IE、新版google浏览器支持，可能有其他浏览器也支持，暂时我不清楚)。\n\n**属性：**\n\n- `src=\"subframe/the_second.html\"`：内嵌的那个页面\n- `width=800`：宽度\n- `height=“150`：高度\n- `scrolling=\"no\"`：是否需要滚动条。默认值是true。\n- `name=\"mainFrame\"`：窗口名称。公有属性。\n\n效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_29.png)\n\n内嵌框架举例：（在内嵌页面中切换显示不同的压面）\n\n```html\n <body>\n\n \t<a href=\"文字页面.html\" target=\"myframe\">默认显示文字页面</a><br>\n \t<a href=\"图片页面.html\" target=\"myframe\">点击进入图片页面</a><br>\n \t<a href=\"表格页面.html\" target=\"myframe\">点击进入表格页面</a><br>\n\n \t<iframe src=\"文字页面.html\" width=\"400\" height=\"400\" name=\"myframe\"></iframe>\n \t<br>\n \t嘿嘿\n\n </body>\n\n```\n\n效果演示：\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_GIF.gif)\n\n## 表单标签\n\n表单标签用 `<form>`表示，用于与服务器的交互。表单就是收集用户信息的，就是让用户填写的、选择的。\n\n**属性：**\n\n- `name`：表单的名称，用于JS来操作或控制表单时使用；\n- `id`：表单的名称，用于JS来操作或控制表单时使用；\n- `action`：指定表单数据的处理程序，一般是PHP，如：action=“login.php”\n- `method`：表单数据的提交方式，一般取值：get(默认)和post\n\n注意：表单和表格嵌套时，是在 `<form>`标记中套 `<table>`标记。\n\nform标签里面的action属性和method属性，在后续的 ajax文章上再讲。这里简单说一下：action属性就是表示，表单将提交到哪里。 method属性表示用什么HTTP方法提交，有get、post两种。\n\n**get提交和post提交的区别：**\n\nGET方式：\n将表单数据，以\"name=value\"形式追加到action指定的处理程序的后面，两者间用\"?\"隔开，每一个表单的\"name=value\"间用\"&\"号隔开。\n特点：只适合提交少量信息，并且不太安全(不要提交敏感数据)、提交的数据类型只限于ASCII字符。\n\nPOST方式：\n将表单数据直接发送(隐藏)到action指定的处理程序。POST发送的数据不可见。Action指定的处理程序可以获取到表单数据。\n特点：可以提交海量信息，相对来说安全一些，提交的数据格式是多样的(Word、Excel、rar、img)。\n\n**Enctype：**\n表单数据的编码方式(加密方式)，取值可以是：application/x-www-form-urlencoded、multipart/form-data。Enctype只能在POST方式下使用。\n\n- Application/x-www-form-urlencoded：**默认**加密方式，除了上传文件之外的数据都可以\n- Multipart/form-data：**上传附件时，必须使用这种编码方式**。\n\n### `<input>`：输入标签（文本框）\n\n用于接收用户输入。\n\n```html\n<input type=\"text\" />\n```\n\n**属性：**\n\n- **`type=\"属性值\"`**：文本类型。属性值可以是：\n\n  - `text`（默认）\n  - `password`：密码类型\n  - `radio`：单选按钮，名字相同的按钮作为一组进行单选（单选按钮，天生是不能互斥的，如果想互斥，必须要有相同的name属性。name就是“名字”。\n    ）。非常像以前的收音机，按下去一个按钮，其他的就抬起来了。所以叫做radio。\n  - `checkbox`：多选按钮，**name 属性值相同的按钮**作为一组进行选择。\n  - `checked`：将单选按钮或多选按钮默认处于选中状态。当 `<input>`标签设置为 `type=\"radio\"`或者 `type=checkbox`时，可以用这个属性。属性值也是checked，可以省略。\n  - `hidden`：隐藏框，在表单中包含不希望用户看见的信息\n  - `button`：普通按钮，结合js代码进行使用。\n  - `submit`：提交按钮，传送当前表单的数据给服务器或其他程序处理。这个按钮不需要写value自动就会有“提交”文字。这个按钮真的有提交功能。点击按钮后，这个表单就会被提交到form标签的action属性中指定的那个页面中去。\n  - `reset`：重置按钮，清空当前表单的内容，并设置为最初的默认值\n  - `image`：图片按钮，和提交按钮的功能完全一致，只不过图片按钮可以显示图片。\n  - `file`：文件选择框。\n    提示：如果要限制上传文件的类型，需要配合JS来实现验证。对上传文件的安全检查：一是扩展名的检查，二是文件数据内容的检查。\n- **`value=\"内容\"`**：文本框里的默认内容（已经被填好了的）\n- `size=\"50\"`：表示文本框内可以显示**五十个字符**。一个英文或一个中文都算一个字符。\n  注意**size属性值的单位不是像素哦**。\n- `readonly`：文本框只读，不能编辑。因为它的属性值也是readonly，所以属性值可以不写。\n  用了这个属性之后，在google浏览器中，光标点不进去；在IE浏览器中，光标可以点进去，但是文字不能编辑。\n- `disabled`：文本框只读，不能编辑，光标点不进去。属性值可以不写。\n\n> 备注：HTML5中，input的类型又增加了很多（比如date、color，我们会在 html5 中讲到）。\n\n**举例**：\n\n```html\n\t<form>\n\t\t姓名：<input value=\"呵呵\" >逗比<br>\n\t\t昵称：<input value=\"哈哈\" readonly=\"\"><br>\n\t\t名字：<input type=\"text\" value=\"name\" disabled=\"\"><br>\n\t\t密码：<input type=\"password\" value=\"pwd\" size=\"50\"><br>\n\t\t性别：<input type=\"radio\" name=\"gender\" id=\"radio1\" value=\"male\" checked=\"\">男\n\t\t\t  <input type=\"radio\" name=\"gender\" id=\"radio2\" value=\"female\" >女<br>\n\t\t爱好：<input type=\"checkbox\" name=\"love\" value=\"eat\">吃饭\n\t\t\t  <input type=\"checkbox\" name=\"love\" value=\"sleep\">睡觉\n\t\t\t  <input type=\"checkbox\" name=\"love\" value=\"bat\">打豆豆\n\t</form>\n```\n\n效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_33.png)\n\n注意，多个单选框的input标签中，name 的属性值可以相同，但是 **id 的属性值必须是唯一的**。我们知道，html的标签中，id的属性值是唯一的。\n\n**四种按钮的举例**：\n\n```html\n\t<form>\n\t\t<input type=\"button\" value=\"普通按钮\"><br>\n\t\t<input type=\"submit\"  value=\"提交按钮\"><br>\n\t\t<input type=\"reset\" value=\"重置按钮\"><br>\n\t\t<input type=\"image\" value=\"图片按钮1\"><br>\n\t\t<input type=\"image\" src=\"1.jpg\" width=\"800\" value=\"图片按钮2\"><br>\n\t\t<input type=\"file\" value=\"文件选择框\">\n\t</form>\n```\n\n**前端开发工程师，重点关心页面的美、样式、板式、交互。至于数据的提供和比较重的业务逻辑，都是后台工程师做的事情。**\n\n效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_35.png)\n\n### `<select>`：下拉列表标签\n\n`<select>`标签里面的每一项用 `<option>`表示。select就是“选择”，option“选项”。\n\nselect标签和ul、ol、dl一样，都是组标签。\n\n**`<select>`标签的属性：**\n\n- `multiple`：可以对下拉列表中的选项进行多选。属性值为 multiple，也可以没有属性值。也就是说，既可以写成 `multiple=\"\"`，也可以写成 `multiple=\"multiple\"`。\n- `size=\"3\"`：如果属性值大于1，则列表为滚动视图。默认属性值为1，即下拉视图。\n\n**`<option>`标签的属性：**\n\n- `selected`：预选中。没有属性值。\n\n举例：\n\n```html\n\t<form>\n\t\t<select>\n\t\t\t<option>小学</option>\n\t\t\t<option>初中</option>\n\t\t\t<option>高中</option>\n\t\t\t<option>大学</option>\n\t\t\t<option selected=\"\">研究生</option>\n\t\t</select>\n\t\t<br><br><br>\n\n\t\t<select size=\"3\">\n\t\t\t<option>小学</option>\n\t\t\t<option>初中</option>\n\t\t\t<option>高中</option>\n\t\t\t<option>大学</option>\n\t\t\t<option>研究生</option>\n\t\t</select>\n\t\t<br><br><br>\n\n\t\t<select multiple=\"\">\n\t\t\t<option>小学</option>\n\t\t\t<option>初中</option>\n\t\t\t<option selected=\"\">高中</option>\n\t\t\t<option selected=\"\">大学</option>\n\t\t\t<option>研究生</option>\n\t\t</select>\n\t\t<br><br><br>\n\n\t</form>\n```\n\n效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_32.png)\n\n### `<textarea>`标签：多行文本输入框\n\ntext 就是“文本”，area 就是“区域”。\n\n**属性：**\n\n- `rows=\"4\"`：指定文本区域的行数。\n- `cols=\"20\"`：指定文本区域的列数。\n- `readonly`：只读。\n\n举例：\n\n```html\n\t<form>\n\t\t<textarea name=\"txtInfo\" rows=\"4\" cols=\"20\">1、不爱摄影不懂设计的程序猿不是一个好的产品经理。</textarea>\n\t</form>\n```\n\n效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_34.png)\n\n上图的红框部分表示，我在文本区域进行了换行，所以显示的效果也出现了空白。\n\n### 表单的语义化\n\n比如，我们在注册一个网站的信息的时候，有一部分是必填信息，有一部分是选填信息，这个时候可以利用表单的语义化。\n举例：\n\n```html\n\t<form>\n\n\t\t<fieldset>\n\t\t<legend>账号信息</legend>\n\t\t姓名：<input value=\"呵呵\" >逗比<br>\n\t\t密码：<input type=\"password\" value=\"pwd\" size=\"50\"><br>\n\t\t</fieldset>\n\n\t\t<fieldset>\n\t\t<legend>其他信息</legend>\n\t\t性别：<input type=\"radio\" name=\"gender\" value=\"male\" checked=\"\">男\n\t\t\t  <input type=\"radio\" name=\"gender\" value=\"female\" >女<br>\n\t\t爱好：<input type=\"checkbox\" name=\"love\" value=\"eat\">吃饭\n\t\t\t  <input type=\"checkbox\" name=\"love\" value=\"sleep\">睡觉\n\t\t\t  <input type=\"checkbox\" name=\"love\" value=\"bat\">打豆豆\n\t\t</fieldset>\n\n\t</form>\n```\n\n效果：\n\n![](http://img.smyhvae.com/20151002_36.png)\n\n### `<label>`标签\n\n我们先来看下面一段代码：\n\n```html\n<input type=\"radio\" name=\"sex\" /> 男\n<input type=\"radio\" name=\"sex\" /> 女\n\n```\n\n对于上面这样的单选框，我们只有点击那个单选框（小圆圈）才可以选中，点击“男”、“女”这两个文字时是无法选中的；于是，label标签派上了用场。\n\n本质上来讲，“男”、“女”这两个文字和input标签时没有关系的，而label就是解决这个问题的。我们可以通过label把input和汉字包裹起来作为整体。\n\n解决方法如下：\n\n```html\n<input type=\"radio\" name=\"sex\" id=\"nan\" /> <label for=\"nan\">男</label>\n<input type=\"radio\" name=\"sex\" id=\"nv\"  /> <label for=\"nv\">女</label>\n```\n\n上方代码中，让label标签的**for 属性值**，和 input 标签的 **id 属性值相同**，那么这个label和input就有绑定关系了。\n\n当然了，复选框也有label：（任何表单元素都有label）\n\n```html\n<input type=\"checkbox\" id=\"kk\" />\n<label for=\"kk\">10天内免登陆</label>\n```\n\n## 多媒体标签\n\n**声明：**\n多媒体包含：音频、视频、Flash。网页上的多媒体基本都是Flash格式的。\n.wmv、.dat、.mob、.rmvb等视频格式，在网页上不能直接播放，需要安装第三方的插件，才可以播放。不同的浏览器，播客上述视频格式，所使用插件参数又不一样。\n上述格式视频一般文件较大，不利于网络下载播放。\n一般情况下，是将其它的视频格式，转成Flash来在网页上播放。转换软件：格式工厂等。\nFlash格式的视频兼容性非常好，Flash格式的文件很小。\n\n### `<bgsound>`标签：播放背景音乐\n\n**属性：**\n\n- `src=\"音乐文件的路径\"`\n- `loop=\"-1\"`：属性值代表播放次数，-1代表循环播放。\n\n举例：\n\n```html\n <body>\n\t<bgsound src=\"王菲 - 清风徐来.mp3\"></bgsound>\n </body>\n\n```\n\n运行效果：\n打开网页后，在IE 8中播放正常，播放时网页上显示一片空白。在google浏览器中无法播放。\n\n### `<embed>`标签：播放多媒体文件（音频、视频等）\n\n主要应用Netscape浏览器，它不是W3C规范。\n\n> 备注：视频格式可以支持 mp4、wav等，但不是所有视频格式都支持。\n\n**属性：**\n\n- `src=\"多媒体文件的路径\"`\n- `loop=\"-1\"`：属性值代表播放次数，-1代表循环播放。\n- `autostart=\"false\"`：打开网页时，禁止自动播放。默认值是true。\n- `volume=\"100\"`：设置默认的音量大小，测试发现这个值好像不起作用哦。\n- width：指Flash文件的宽度\n- height：指Flash文件的高度\n- quality：指Flash的播放质量，质量有高有低 hight  low\n- pluginspage：如果指定的Flash插件不存在，则从pluginspage指定的地方进行下载。\n- type：指定Flash的文件格式类型\n- wmode：指Flash的背景是否可以透明，取值：transparent是透明的\n\n`<embed>`标签播放音频举例：\n\n```html\n <body>\n\t<embed src=\"王菲 - 清风徐来.mp3\"></embed>\n </body>\n\n```\n\nIE 8中的运行效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_37.png)\n\ngoogle浏览器中的运行效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_38.png)\n\n注：在HTML5中新增了 `<video>`标签播放视频。\n\n### `<object>`标签：播放多媒体文件（音频、视频等）\n\n主要应用IE浏览器，它是W3C规范。\n\n**属性：**\n\n- `classid`：指定Flash插件的ID号，一般存在于注册表中。\n- `codebase`：如果Flash插件不存在，则从codebase指定的地址下载。\n- `<param>`标签的主要作用：设置具体的详细参数。\n\n**总结：在网页中插入Flash时，为了同时兼容多种浏览器，需要将 `<object>`标签和 `<embed>`标签标记一起使用，但使用的顺序是：`<object>`中嵌套 `<embed>`标记。**\n举例：\n\n```html\n<object classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,29,0\" width=\"778\" height=\"202\">\n  <param name=\"movie\" value=\"images/banner.swf\">\n  <param name=\"quality\" value=\"high\">\n  <param name=\"wmode\" value=\"transparent\">\n  <embed src=\"images/banner.swf\" width=\"778\" height=\"202\" quality=\"high\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" type=\"application/x-shockwave-flash\" wmode=\"transparent\"></embed>\n</object>\n```\n\n## `<marquee>`：滚动字幕标签\n\n如果在这个标签里设置了内容，那么，打开网页时，内容会像弹幕一样自动移动。\n**属性：**\n\n- `direction=\"right\"`：移动的目标方向。属性值可以是：`left`（从右向左移动，默认值）、`right`（从左向右移动）、`up`（从下向上移动）、`down`（从上向下移动）。\n- `behavior=\"slide\"`：行为方式。属性值可以是：`slide`（只移动一次）、`scroll`（循环移动，默认值）、`alternate`（循环移动）、。\n  `alternate`和 `scroll`属性值都是循环移动，区别在于：假设在 `direction=\"right\"`的情况下，`behavior=\"scroll\"`表示从左到右、从左到右、从左到右···`behavior=\"alternate\"`表示从左到右、从右到左、从左到右···\n- `scrollamount=\"30\"`：移动的速度\n- `loop=\"3\"`: 循环多少圈。负值表示无限循环\n- `scrolldelay=\"1000\"`：移动一次休息多长时间。单位是毫秒。\n\n举例：\n\n```html\n\t<marquee behavior=\"alternate\" direction=\"down\"  width=\"300\" height=\"200\" bgcolor=\"#8c5dc1\">我来了</marquee>\n```\n\n效果：\n\n![](http://img.smyhvae.com/2015-10-02-cnblogs_html_04.gif)\n\n## html废弃标签介绍\n\nHTML现在只负责语义，而不负责样式。但是HTML一开始，连样式也包办了。这些样式的标签，都已经被废弃。\n\n2004年之前的东西：\n\n```html\n<font size=\"9\" color=\"red\">哈哈</font>\n```\n\n下面这些标签都是css钩子，而不是原意：\n\n```html\n\t<b>加粗</b>\n\t<u>下划线</u>\n\t<i>倾斜</i>\n    <del>删除线</del>\n\t<em>强调</em>\n\t<strong>强调</strong>\n\n```\n\n这些标签，是有着浓厚的样式的作用，干涉了css的作用，所以HTML抛弃了他们。\n\n类似的还有水平线标签：\n\n```html\n<hr />\n```\n\n换行标签：\n\n```\n<br />\n```\n\n但是，网页中99.9999%需要换行的时候，是因为另起了一个段落，所以要用p，而不要用 `<br />`。不到万不得已，不要用br标签。\n\n标准的div+css页面，只会用到种类很少的标签：\n\n```\ndiv  p  h1  span   a   img   ul   ol    dl    input\n```\n\n知道每个标签的特殊用法、属性。比如a标签，img的属性。\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/html/06-html标签图文详解（二）.md"}},{"pageContent":"---\ntitle: 08-HTML5详解\npublish: true\n---\n`<ArticleTopAd></ArticleTopAd>`\n\n## HTML5的介绍\n\n### Web 技术发展时间线\n\n- 1991 HTML\n- 1994 HTML2\n- 1996 CSS1 + JavaScript\n- 1997 HTML4\n- 1998 CSS2\n- 2000 XHTML1（严格的html）\n- 2002 Tableless Web Design（表格布局）\n- 2005 AJAX\n- 2009 HTML5\n- 2014 HTML5 Finalized\n\n2002年的表格布局逐渐被淘汰，是因为：表格是用来承载数据的，并不是用来划分网页结构的。\n\n2009年就已经推出了HTML5的草案，但直到2014年才有定稿，是因为有移动端的推动。\n\nH5草案的前身是叫：Web Application，最早是由[WHATWG](https://baike.baidu.com/item/WHATWG/5803339?fr=aladdin)这个组织在2004年提出的。\n\n2007年被 W3C 组织接纳，并在 2008-01-22 发布 HTML5 的第一个草案。\n\n### 什么是 HTML5\n\nHTML5并不仅仅只是做为HTML标记语言的一个最新版本，更重要的是它**制定了Web应用开发的一系列标准**，成为第一个将Web做为应用开发平台的HTML语言。\n\nHTML5定义了一系列新元素，如新语义标签、智能表单、多媒体标签等，可以帮助开发者创建富互联网应用，还提供了一些Javascript API，如地理定位、重力感应、硬件访问等，可以在浏览器内实现类原生应用。我们甚至可以结合 Canvas 开发网页版游戏。\n\n**`HTML5`的广义概念**：HTML5代表浏览器端技术的一个发展阶段。在这个阶段，浏览器的呈现技术得到了飞跃发展和广泛支持，它包括：HTML5、CSS3、Javascript API在内的一套技术组合。\n\n`HTML5`不等于 `HTML next version`。`HTML5` 包含： `HTML`的升级版、`CSS`的升级版、`JavaScript API`的升级版。\n\n**总结**：`HTML5`是新一代开发 **Web 富客户端**应用程序整体**解决方案**。包括：HTML5，CSS3，Javascript API在内的一套**技术组合**。\n\n**富客户端**：具有很强的**交互性**和体验的客户端程序。比如说，浏览博客，是比较简单的客户端；一个在线听歌的网站、即时聊天网站就是富客户端。\n\n**PS：**\n\n单纯地从技术的角度讲，兼容性问题只会让开发者徒增烦恼。\n\n如果网页端的程序能做到PC客户端的体验，就会对后者构成威胁。\n\n### HTML5 的应用场景\n\n列举几个HTML5 的应用场景：\n\n（1）极具表现力的网页：内容简约而不简单。\n\n（2）网页应用程序：\n\n- 代替PC端的软件：iCloud、百度脑图、Office 365等。\n- APP端的网页：淘宝、京东、美团等。\n- 微信端：公众号、小程序等。\n\n（3）混合式本地应用。\n\n（4）简单的游戏。\n\n### HTML5 新增的内容\n\n![](http://img.smyhvae.com/20180206_1540.png)\n\n![](http://img.smyhvae.com/20180206_1545.png)\n\n![](http://img.smyhvae.com/20180206_1541.png)\n\n## 语义化的标签\n\n### 语义化的作用\n\n语义标签对于我们并不陌生，如 `<p>`表示一个段落、`<ul>`表示一个无序列表。**标签语义化的作用：**\n\n- 能够便于开发者阅读和写出更优雅的代码。\n- 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容。\n- 更好地搜索引擎优化。\n\n总结：HTML的职责是描述一块内容是什么（或其意义），而不是它长什么样子；它的外观应该由CSS来决定。\n\n### H5在语义上的改进\n\n在此基础上，HTML5 增加了大量有意义的语义标签，更有利于搜索引擎或辅助设备理解 HTML 页面内容。HTML5会让HTML代码的内容更结构化、标签更语义化。\n\n我们常见的 css+div 布局是：\n\n![](http://img.smyhvae.com/20180206_1546.png)\n\n在html5中，我们可以这样写：\n\n![](http://img.smyhvae.com/20180206_1550.png)\n\n传统的做法中，我们通过增加类名如 `class=\"header\"`、`class=\"footer\"`，使HTML页面具有语义性，但是不具有通用性。\n\nHTML5 则是通过新增语义标签的形式来解决这个问题，例如 `<header></header>`、`<footer></footer>`等，这样就可以使其具有通用性。\n\n**传统网页布局：**\n\n```html\n<!-- 头部 -->\n<div class=\"header\">\n    <ul class=\"nav\"></ul>\n</div>\n\n<!-- 主体部分 -->\n<div class=\"main\">\n    <!-- 文章 -->\n    <div class=\"article\"></div>\n    <!-- 侧边栏 -->\n    <div class=\"aside\"></div>\n</div>\n\n<!-- 底部 -->\n<div class=\"footer\">\n\n</div>\n```\n\n**H5 的经典网页布局：**\n\n```html\n<!-- 头部 -->\n<header>\n    <ul class=\"nav\"></ul>\n</header>\n\n<!-- 主体部分 -->\n<div class=\"main\">\n    <!-- 文章 -->\n    <article></article>\n    <!-- 侧边栏 -->\n    <aside></aside>\n</div>\n\n<!-- 底部 -->\n<footer>\n\n</footer>\n```\n\n## H5中新增的语义标签\n\n- `<section>` 表示区块\n- `<article>` 表示文章。如文章、评论、帖子、博客\n- `<header>` 表示页眉\n- `<footer>` 表示页脚\n- `<nav>` 表示导航\n- `<aside>` 表示侧边栏。如文章的侧栏\n- `<figure>` 表示媒介内容分组。\n- `<mark>` 表示标记 (用得少)\n- `<progress>` 表示进度 (用得少)\n- `<time>` 表示日期\n\n本质上新语义标签与 `<div>`、`<span>`没有区别，只是其具有表意性，使用时除了在HTML结构上需要注意外，其它和普通标签的使用无任何差别，可以理解成 `<div class=\"nav\">` 相当于 `<nav>`。\n\nPS：单标签不用写关闭符号。\n\n### 新语义标签的兼容性处理\n\nIE8 及以下版本的浏览器不支持 H5 和 CSS3。解决办法：引入 `html5shiv.js`文件。\n\n引入时，需要做if判断，具体代码如下：\n\n```html\n    <!--  条件注释 只有ie能够识别-->\n\n    <!--[if lte ie 8]>\n        <script src=\"html5shiv.min.js\"></script>\n    <![endif]-->\n```\n\n上方代码是**条件注释**：虽然是注释，但是IE浏览器可以识别出来。解释一下：\n\n- l：less 更小\n- t：than 比\n- e：equal等于\n- g：great 更大\n\nPS:我们在测试 IE 浏览器的兼容的时候，可以使用软件 ietest，模拟IE6-IE11。\n\n在不支持HTML5新标签的浏览器，会将这些新的标签解析成行内元素(inline)对待，所以我们只需要将其转换成块元素(block)即可使用。\n\n但是在IE9版本以下，并不能正常解析这些新标签，但是可以识别通过document.createElement('tagName')创建的自定义标签。于是我们的解决方案就是：将HTML5的新标签全部通过document.createElement('tagName')来创建一遍，这样IE低版本也能正常解析HTML5新标签了。\n\n当然，在实际开发中我们更多采用的办法是：检测IE浏览器的版本，来加载第三方的JS库来解决兼容问题（如上方代码所示）。\n\n## H5中的表单\n\n传统的Web表单已经越来越不能满足开发的需求，HTML5 在 Web 表单方向做了很大的改进，如拾色器、日期/时间组件等，使表单处理更加高效。\n\n### H5中新增的表单类型\n\n- `email` 只能输入email格式。自动带有验证功能。\n- `tel` 手机号码。\n- `url` 只能输入url格式。\n- `number` 只能输入数字。\n- `search` 搜索框\n- `range` 滑动条\n- `color` 拾色器\n- `time`\t时间\n- `date` 日期\n- `datetime` 时间日期\n- `month` 月份\n- `week` 星期\n\n上面的部分类型是针对移动设备生效的，且具有一定的兼容性，在实际应用当中可选择性的使用。\n\n代码举例：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no\">\n    <title>表单类型</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            background-color: #F7F7F7;\n        }\n\n        form {\n            max-width: 500px;\n            width: 100%;\n            margin: 32px auto 0;\n            font-size: 16px;\n        }\n\n        label {\n            display: block;\n            margin: 10px 0;\n        }\n\n        input {\n            width: 100%;\n            height: 25px;\n            margin-top: 2px;\n            display: block;\n        }\n\n    </style>\n</head>\n<body>\n<form action=\"\">\n    <fieldset>\n        <legend>表单类型</legend>\n        <label for=\"\">\n            email: <input type=\"email\" name=\"email\" required>\n        </label>\n        <label for=\"\">\n            color: <input type=\"color\" name=\"color\">\n        </label>\n        <label for=\"\">\n            url: <input type=\"url\" name='url'>\n        </label>\n        <label for=\"\">\n            number: <input type=\"number\" step=\"3\" name=\"number\">\n        </label>\n        <label for=\"\">\n            range: <input type=\"range\" name=\"range\" value=\"100\">\n        </label>\n        <label for=\"\">\n            search: <input type=\"search\" name=\"search\">\n        </label>\n        <label for=\"\">\n            tel: <input type=\"tel\" name=\"tel\">\n        </label>\n        <label for=\"\">\n            time: <input type=\"time\" name=\"time\">\n        </label>\n        <label for=\"\">\n            date: <input type=\"date\" name=\"date\">\n        </label>\n        <label for=\"\">\n            datetime: <input type=\"datetime\">\n        </label>\n        <label for=\"\">\n            week: <input type=\"week\" name=\"week\">\n        </label>\n        <label for=\"\">\n            month: <input type=\"month\" name=\"month\">\n        </label>\n        <label for=\"\">\n            datetime-local: <input type=\"datetime-local\" name=\"datetime-local\">\n        </label>\n        <input type=\"submit\">\n    </fieldset>\n</form>\n</body>\n</html>\n```\n\n代码解释：\n\n`<fieldset>` 标签将表单里的内容进行打包，代表一组；而 `<legend> `标签的则是 fieldset 里的元素定义标题。\n\n### 表单元素（标签）\n\n这里讲两个表单元素。\n\n**1、`<datalist>` 数据列表：**\n\n```html\n<input type=\"text\" list=\"myData\">\n<datalist id=\"myData\">\n    <option>本科</option>\n    <option>研究生</option>\n    <option>不明</option>\n</datalist>\n```\n\n上方代码中，input里的list属性和 datalist 进行了绑定。\n\n效果：\n\n![](http://img.smyhvae.com/20180206_1845.gif)\n\n上图可以看出，数据列表可以自动提示。\n\n2、`<keygen>`元素：\n\nkeygen 元素的作用是提供一种验证用户的可靠方法。\n\nkeygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键：一个公钥，一个私钥。\n\n私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。\n\n3、`<meter>`元素：度量器\n\n- low：低于该值后警告\n- high：高于该值后警告\n- value：当前值\n- max：最大值\n- min：最小值。\n\n举例：\n\n```javascript\n\t<meter  value=\"81\"    min=\"0\" max=\"100\"  low=\"60\"  high=\"80\"/>\n```\n\n### 表单属性\n\n- `placeholder` 占位符（提示文字）\n- `autofocus` 自动获取焦点\n- `multiple` 文件上传多选或多个邮箱地址\n- `autocomplete` 自动完成（填充的）。on 开启（默认），off 取消。用于表单元素，也可用于表单自身(on/off)\n- `form` 指定表单项属于哪个form，处理复杂表单时会需要\n- `novalidate` 关闭默认的验证功能（只能加给form）\n- `required` 表示必填项\n- `pattern` 自定义正则，验证表单。例如\n\n代码举例：\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style>\n        form {\n            width: 100%;\n            /* 最大宽度*/\n            max-width: 640px;\n            /* 最小宽度*/\n            min-width: 320px;\n            margin: 0 auto;\n            font-family: \"Microsoft Yahei\";\n            font-size: 20px;\n        }\n\n        input {\n            display: block;\n            width: 100%;\n            height: 30px;\n            margin: 10px 0;\n        }\n    </style>\n</head>\n<body>\n\n<form action=\"\">\n    <fieldset>\n        <legend>表单属性</legend>\n        <label for=\"\">\n            用户名：<input type=\"text\" placeholder=\"例如：smyhvae\" autofocus name=\"userName\" autocomplete=\"on\" required/>\n        </label>\n\n        <label for=\"\">\n            电话：<input type=\"tel\" pattern=\"1\\d{10}\"/>\n        </label>\n\n        <label for=\"\">\n            multiple的表单: <input type=\"file\" multiple>\n        </label>\n\n        <!-- 上传文件-->\n        <input type=\"file\" name=\"file\" multiple/>\n\n        <input type=\"submit\"/>\n    </fieldset>\n</form>\n\n</body>\n</html>\n```\n\n### 表单事件\n\n- `oninput()`：用户输入内容时触发，可用于输入字数统计。\n- `oninvalid()`：验证不通过时触发。比如，如果验证不通过时，想弹出一段提示文字，就可以用到它。\n\n举例：\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style>\n        form {\n            width: 100%;\n            /* 最大宽度*/\n            max-width: 400px;\n            /* 最小宽度*/\n            min-width: 200px;\n            margin: 0 auto;\n            font-family: \"Microsoft Yahei\";\n            font-size: 20px;\n        }\n\n        input {\n            display: block;\n            width: 100%;\n            height: 30px;\n            margin: 10px 0;\n        }\n    </style>\n</head>\n<body>\n<form action=\"\">\n    <fieldset>\n        <legend>表单事件</legend>\n        <label for=\"\">\n            邮箱：<input type=\"email\" name=\"\" id=\"txt1\"/>\n        </label>\n        <label for=\"\">\n            输入的次数统计：<input type=\"text\" name=\"\" id=\"txt2\"/>\n        </label>\n\n        <input type=\"submit\"/>\n    </fieldset>\n</form>\n<script>\n\n    var txt1 = document.getElementById('txt1');\n    var txt2 = document.getElementById('txt2');\n    var num = 0;\n\n    txt1.oninput = function () {  //用户输入时触发\n\n        num++;  //用户每输入一次，num自动加 1\n        //将统计数显示在txt2中\n        txt2.value = num;\n    }\n    txt1.oninvalid = function () {  //验证不通过时触发\n        this.setCustomValidity('亲，请输入正确哦');  //设置验证不通过时的提示文字\n    }\n\n</script>\n</body>\n</html>\n```\n\n效果：\n\n![](http://img.smyhvae.com/20180206_1920.gif)\n\n## 多媒体\n\n在HTML5之前，在网页上播放音频/视频的通用方法是利用Flash来播放。但是大多情况下，并非所有用户的浏览器都安装了Flash插件，由此使得音频、视频播放的处理变得非常复杂；并且移动设备的浏览器并不支持Flash插件。\n\nH5里面提供了视频和音频的标签。\n\n### 音频\n\nHTML5通过 `<audio>`标签来解决音频播放的问题。\n\n使用举例：\n\n```html\n\t<audio src=\"music/yinyue.mp3\" autoplay controls> </audio>\n```\n\n效果如下：\n\n![](http://img.smyhvae.com/20180206_1958.png)\n\n我们可以通过附加属性，来更友好地控制音频的播放，如：\n\n- `autoplay` 自动播放。写成 `autoplay` 或者 `autoplay = \"\"`，都可以。\n- `controls` 控制条。（建议把这个选项写上，不然都看不到控件在哪里）\n- `loop` 循环播放。\n- `preload` 预加载 同时设置 autoplay 时，此属性将失效。\n\n**处理兼容性问题：**\n\n由于版权等原因，不同的浏览器可支持播放的格式是不一样的：\n\n![](http://img.smyhvae.com/20180206_1945.png)\n\n为了做到多浏览器支持，可以采取以下兼容性写法：\n\n```html\n<!--推荐的兼容写法：-->\n<audio controls loop>\n    <source src=\"music/yinyue.mp3\"/>\n    <source src=\"music/yinyue.ogg\"/>\n    <source src=\"music/yinyue.wav\"/>\n    抱歉，你的浏览器暂不支持此音频格式\n</audio>\n```\n\n代码解释：如果识别不出音频格式，就弹出那句“抱歉”。\n\n### 视频\n\nHTML5通过 `<video>`标签来解决视频播放的问题。\n\n使用举例：\n\n```html\n\t<video src=\"video/movie.mp4\" controls autoplay></video>\n```\n\n我们可以通过附加属性，来更友好地控制视频的播放，如：\n\n- `autoplay` 自动播放。写成 `autoplay` 或者 `autoplay = \"\"`，都可以。\n- `controls` 控制条。（建议把这个选项写上，不然都看不到控件在哪里）\n- `loop` 循环播放。\n- `preload` 预加载 同时设置 autoplay 时，此属性将失效。\n- `width`：设置播放窗口宽度。\n- `height`：设置播放窗口的高度。\n\n由于版权等原因，不同的浏览器可支持播放的格式是不一样的：\n\n![](http://img.smyhvae.com/20180206_2025.png)\n\n兼容性写法：\n\n```html\n    <!--<video src=\"video/movie.mp4\" controls  autoplay ></video>-->\n    <!--  行内块 display:inline-block -->\n    <video controls autoplay>\n        <source src=\"video/movie.mp4\"/>\n        <source src=\"video/movie.ogg\"/>\n        <source src=\"video/movie.webm\"/>\n        抱歉，不支持此视频\n    </video>\n```\n\n## DOM 操作\n\n### 获取元素\n\n- document.querySelector(\"selector\") 通过CSS选择器获取符合条件的第一个元素。\n- document.querySelectorAll(\"selector\")  通过CSS选择器获取符合条件的所有元素，以类数组形式存在。\n\n### 类名操作\n\n- Node.classList.add(\"class\") 添加class\n- Node.classList.remove(\"class\") 移除class\n- Node.classList.toggle(\"class\") 切换class，有则移除，无则添加\n- Node.classList.contains(\"class\") 检测是否存在class\n\n### 自定义属性\n\njs 里可以通过 `box1.index=100;`  `box1.title` 来自定义属性和获取属性。\n\nH5可以直接在标签里添加自定义属性，**但必须以 `data-` 开头**。\n\n举例：\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<!-- 给标签添加自定义属性 必须以data-开头 -->\n<div class=\"box\" title=\"盒子\" data-my-name=\"smyhvae\" data-content=\"我是一个div\">div</div>\n<script>\n    var box = document.querySelector('.box');\n\n    //自定义的属性 需要通过 dateset[]方式来获取\n    console.log(box.dataset[\"content\"]);  //打印结果：我是一个div\n    console.log(box.dataset[\"myName\"]);    //打印结果：smyhvae\n\n    //设置自定义属性的值\n    var num = 100;\n    num.index = 10;\n    box.index = 100;\n    box.dataset[\"content\"] = \"aaaa\";\n\n</script>\n</body>\n</html>\n```\n\n### 举例：鼠标点击时，tab栏切换\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Tab 标签</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            background-color: #F7F7F7;\n        }\n\n        .tabs {\n            width: 400px;\n            margin: 30px auto;\n            background-color: #FFF;\n            border: 1px solid #C0DCC0;\n            box-sizing: border-box;\n        }\n\n        .tabs nav {\n            height: 40px;\n            text-align: center;\n            line-height: 40px;\n            overflow: hidden;\n            background-color: #C0DCC0;\n            display: flex;\n        }\n\n        nav a {\n            display: block;\n            width: 100px;\n            border-right: 1px solid #FFF;\n            color: #000;\n            text-decoration: none;\n        }\n\n        nav a:last-child {\n            border-right: 0 none;\n        }\n\n        nav a.active {\n            background-color: #9BAF9B;\n        }\n\n        .cont {\n            overflow: hidden;\n            display: none;\n        }\n\n        .cont ol {\n            line-height: 30px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"tabs\">\n        <nav>\n            <a href=\"javascript:;\" data-cont=\"local\">国内新闻</a>\n            <a href=\"javascript:;\" data-cont=\"global\">国际新闻</a>\n            <a href=\"javascript:;\" data-cont=\"sports\">体育新闻</a>\n            <a href=\"javascript:;\" data-cont=\"funny\">娱乐新闻</a>\n        </nav>\n        <section class=\"cont\" id=\"local\">\n            <ol>\n                <li>国内新闻1</li>\n                <li>国内新闻2</li>\n                <li>国内新闻3</li>\n                <li>国内新闻4</li>\n                <li>国内新闻5</li>\n                <li>国内新闻6</li>\n                <li>国内新闻7</li>\n            </ol>\n        </section>\n        <section class=\"cont\" id=\"global\">\n            <ol>\n                <li>国内新闻1</li>\n                <li>国际新闻2</li>\n                <li>国际新闻3</li>\n                <li>国际新闻4</li>\n                <li>国际新闻5</li>\n                <li>国际新闻6</li>\n            </ol>\n        </section>\n        <section class=\"cont\" id=\"sports\">\n            <ol>\n                <li>体育新闻1</li>\n                <li>体育新闻2</li>\n                <li>体育新闻3</li>\n                <li>体育新闻4</li>\n                <li>体育新闻5</li>\n                <li>体育新闻6</li>\n                <li>体育新闻7</li>\n            </ol>\n        </section>\n        <section class=\"cont\" id=\"funny\">\n            <ol>\n                <li>娱乐新闻1</li>\n                <li>娱乐新闻2</li>\n                <li>娱乐新闻3</li>\n                <li>娱乐新闻4</li>\n                <li>娱乐新闻5</li>\n                <li>娱乐新闻6</li>\n                <li>娱乐新闻7</li>\n            </ol>\n        </section>\n    </div>\n    <script>\n        // 目标： 默认显示一个 当前的样式\n        // 点击导航，实现切换\n        // key 表示的当前显示的是第几个\n\n        (function (key) {\n            // 获取所有的导航\n            var navs = document.querySelectorAll('nav a');\n            // 遍历 给导航 绑定事件，并且添加当前样式\n            for (var i = 0; i < navs.length; i++) {\n                // 如果是用户指定的当前样式\n                if (key == i) {\n                    navs[i].classList.add('active');\n                    // 拿到要显示内容section的id\n                    var secId = navs[i].dataset['cont'];\n                    // 获取对应的section标签\n                    document.querySelector('#' + secId).style.display = 'block';\n                }\n\n                // 给每一个导航绑定点击事件\n                navs[i].onclick = function () {\n                    // 排他\n                    // 之前有active样式的清除, 之前显示的section 隐藏\n                    var currentNav = document.querySelector('.active');\n                    // 获取对应的内容区域 ，让其隐藏\n                    var currentId = currentNav.dataset['cont'];\n                    // 去掉导航的active 样式\n                    currentNav.classList.remove('active');\n                    // 对应的内容区域\n                    document.querySelector('#' + currentId).style.display = 'none';\n\n                    // 突出显示自己 导航添加样式  对应的section 显示\n                    // 给自己添加active样式\n                    this.classList.add('active');\n                    // 对应的section模块显示出来\n                    var myId = this.dataset['cont'];\n                    document.querySelector('#' + myId).style.display = 'block';\n                }\n            }\n\n        })(0);\n\n\n    </script>\n</body>\n\n</html>\n```\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/html/07-HTML5详解.md"}},{"pageContent":"---\ntitle: 09-HTML5举例：简单的视频播放器\npublish: true\n---\n`<ArticleTopAd></ArticleTopAd>`\n\n我们采用 Bootstrap 网站的图标字体，作为播放器的按钮图标。\n\nindex.html的代码如下：\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <!-- 引入字体图标的文件-->\n    <link rel=\"stylesheet\" href=\"css/font-awesome.min.css\"/>\n    <style>\n        *{\n            margin: 0;\n            padding: 0;\n        }\n        /*多媒体标题*/\n        figcaption{\n            text-align: center;\n            line-height: 150px;\n            font-family: \"Microsoft Yahei\";\n            font-size:24px;\n        }\n\n        /* 播放器*/\n        .palyer{\n            width: 720px;\n            height: 360px;\n            margin:10px auto;\n            border: 1px solid #000;\n            background: url(images/loading.gif) center no-repeat #000;\n            background-size:auto 100%;\n            position: relative;\n            border-radius: 20px;\n\n        }\n\n        .palyer video{\n            height:100%;\n            display: block;\n            margin:0 auto;\n            /*display: none;*/\n        }\n\n        /* 控制条*/\n\n        .controls{\n            width: 700px;\n            height:40px;\n            background-color: rgba(255, 255, 0, 0.3);\n            position: absolute;\n            bottom:10px;\n            left:10px;\n            border-radius: 10px;\n        }\n        /*开关*/\n        .switch{\n            position: absolute;\n            width: 20px;\n            height: 20px;\n            left:10px;\n            top:10px;\n\n            text-align: center;\n            line-height: 20px;\n            color:yellow;\n\n        }\n        /*进度条*/\n        .progress{\n            width: 432px;\n            height: 10px;\n            position: absolute;\n            background-color: rgba(255,255,255,0.4);\n            left:40px;\n            top:15px;\n            border-radius: 4px;\n            overflow: hidden;\n        }\n        /* 当前进度*/\n        .curr-progress{\n            width: 50%;\n            height: 10px;\n            background-color: #fff;\n        }\n        /* 时间模块*/\n        .time{\n            width: 120px;\n            height: 20px;\n            text-align: center;\n            line-height: 20px;\n            color:#fff;\n            position: absolute;\n            left:510px;\n            top:10px;\n            font-size:12px;\n\n        }\n        /*全屏*/\n        .extend{\n            position: absolute;\n            width: 20px;\n            height: 20px;\n\n            right:20px;\n            top:10px;\n\n            text-align: center;\n            line-height: 20px;\n            color:yellow;\n        }\n\n    </style>\n</head>\n<body>\n    <!-- 多媒体-->\n    <figure>\n        <!--  多媒体标题-->\n        <figcaption>视频案例</figcaption>\n        <div class=\"palyer\">\n            <video src=\"video/fun.mp4\"></video>\n            <!-- 控制条-->\n            <div class=\"controls\">\n                <!-- 播放暂停-->\n                <a href=\"#\" class=\"switch  icon-play\"></a>\n                <div class=\"progress\">\n                    <!-- 当前进度-->\n                    <div class=\"curr-progress\"></div>\n                </div>\n                <!-- 时间-->\n                <div class=\"time\">\n                    <span class=\"curr-time\">00:00:00</span>/<span class=\"total-time\">00:00:00</span>\n                </div>\n                <!-- 全屏-->\n                <a href=\"#\" class=\"extend  icon-resize-full\"></a>\n            </div>\n\n        </div>\n    </figure>\n\n    <script>\n        // 思路：\n        /*\n        * 1、点击按钮 实现播放暂停并且切换图标\n        * 2、算出视频的总时显示出出来\n        * 3、当视频播放的时候，进度条同步，当前时间同步\n        * 4、点击实现全屏\n        */\n\n//        获取需要的标签\n            var  video=document.querySelector('video');\n//          播放按钮\n            var  playBtn=document.querySelector('.switch');\n//          当前进度条\n            var  currProgress=document.querySelector('.curr-progress');\n//          当前时间\n            var  currTime=document.querySelector('.curr-time');\n//          总时间\n            var  totalTime=document.querySelector('.total-time');\n//          全屏\n            var extend=document.querySelector('.extend');\n\n            var tTime=0;\n\n//         1、点击按钮 实现播放暂停并且切换图标\n\n           playBtn.onclick=function(){\n//               如果视频播放 就暂停，如果暂停 就播放\n               if(video.paused){\n//                   播放\n                   video.play();\n                   //切换图标\n                   this.classList.remove('icon-play');\n                   this.classList.add('icon-pause');\n               }else{\n//                   暂停\n                    video.pause();\n//                   切换图标\n                   this.classList.remove('icon-pause');\n                   this.classList.add('icon-play');}\n           }\n\n//        2、算出视频的总时显示出出来\n//        当时加载完成后的事件，视频能播放的时候\n        video.oncanplay=function(){\n//             获取视频总时长\n            tTime=video.duration;\n            console.log(tTime);\n\n//          将总秒数 转换成 时分秒的格式：00：00:00\n//            小时\n            var h=Math.floor(tTime/3600);\n//            分钟\n            var m=Math.floor(tTime%3600/60);\n//            秒\n            var s=Math.floor(tTime%60);\n\n//            console.log(h);\n//            console.log(m);\n//            console.log(s);\n\n//            把数据格式转成 00:00：00\n            h=h>=10?h:\"0\"+h;\n            m=m>=10?m:\"0\"+m;\n            s=s>=10?s:\"0\"+s;\n\n\n            console.log(h);\n            console.log(m);\n            console.log(s);\n//            显示出来\n            totalTime.innerHTML=h+\":\"+m+\":\"+s;\n        }\n//   * 3、当视频播放的时候，进度条同步，当前时间同步\n//         当时当前时间更新的时候触发\n        video.ontimeupdate=function(){\n//            获取视频当前播放的时间\n//           console.log(video.currentTime);\n//            当前播放时间\n            var cTime=video.currentTime;\n//           把格式转成00:00:00\n\n            var h=Math.floor(cTime/3600);\n//            分钟\n            var m=Math.floor(cTime%3600/60);\n//            秒\n            var s=Math.floor(cTime%60);\n\n//            把数据格式转成 00:00：00\n            h=h>=10?h:\"0\"+h;\n            m=m>=10?m:\"0\"+m;\n            s=s>=10?s:\"0\"+s;\n\n//            显示出当前时间\n            currTime.innerHTML=h+\":\"+m+\":\"+s;\n\n//            改变进度条的宽度： 当前时间/总时间\n            var value=cTime/tTime;\n\n            currProgress.style.width=value*100+\"%\";\n\n        }\n\n//        全屏\n        extend.onclick=function(){\n//            全屏的h5代码\n            video.webkitRequestFullScreen();\n        }\n\n    </script>\n</body>\n</html>\n```\n\n工程文件：[2018-02-23-H5多媒体播放器.rar](https://github.com/qianguyihao/web-resource/blob/main/project/2018-02-23-H5%E5%A4%9A%E5%AA%92%E4%BD%93%E6%92%AD%E6%94%BE%E5%99%A8.rar)\n\n此链接为github连接，如果打不开可以自行换源\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/html/08-HTML5举例：简单的视频播放器.md"}},{"pageContent":"---\ntitle: 10-HTML5详解（二）\npublish: true\n---\n\n<ArticleTopAd></ArticleTopAd>\n\n\n## 本文主要内容\n\n- 拖拽\n\n- 历史\n\n- 地理位置\n\n- 全屏\n\n## 拖拽\n\n\n![](http://img.smyhvae.com/20180223_2130.gif)\n\n如上图所示，我们可以拖拽博客园网站里的图片和超链接。\n\n在HTML5的规范中，我们可以通过为元素增加 `draggable=\"true\"` 来设置此元素是否可以进行拖拽操作，其中图片、链接默认是开启拖拽的。\n\n### 1、拖拽元素\n\n页面中设置了 `draggable=\"true\"` 属性的元素。\n\n举例如下：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <link rel=\"stylesheet\" href=\"css/font-awesome.min.css\">\n    <style>\n    .box1{\n        width: 200px;\n        height: 200px;\n        background-color: green;\n\n    }\n    </style>\n</head>\n<body>\n    <!--给 box1 增加拖拽的属性-->\n    <div class=\"box1\" draggable=\"true\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![](http://img.smyhvae.com/20180223_2140.gif)\n\n上图中，我们给 box1 增加了`draggable=\"true\"` 属性之后，发现 box1 是可以拖拽的。但是拖拽之后要做什么事情呢？这就涉及到**事件监听**。\n\n\n**拖拽元素的事件监听**：（应用于拖拽元素）\n\n- `ondragstart`当拖拽开始时调用\n\n- `ondragleave`\t当**鼠标离开拖拽元素时**调用\n\n- `ondragend`\t当拖拽结束时调用\n\n- `ondrag` \t\t整个拖拽过程都会调用\n\n\n代码演示：\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style>\n        .box {\n            width: 200px;\n            height: 200px;\n            background-color: green;\n        }\n    </style>\n</head>\n<body>\n<div class=\"box\" draggable=\"true\"></div>\n\n<script>\n    var box = document.querySelector('.box');\n\n    //  绑定拖拽事件\n\n    //  拖拽开始\n    box.ondragstart = function () {\n        console.log('拖拽开始.');\n    }\n\n    //  拖拽离开：鼠标拖拽时离开被拖拽的元素时触发\n    box.ondragleave = function () {\n        console.log('拖拽离开..');\n    }\n\n    //  拖拽结束\n    box.ondragend = function () {\n        console.log('拖拽结束...');\n        console.log(\"---------------\");\n    }\n\n    box.ondrag = function () {\n        console.log('拖拽');\n    }\n\n</script>\n</body>\n</html>\n```\n\n\n效果如下：\n\n![](http://img.smyhvae.com/20180223_2201.gif)\n\n打印结果：\n\n![](http://img.smyhvae.com/20180223_2213.png)\n\n\n### 2、目标元素\n\n比如说，你想把元素A拖拽到元素B里，那么元素B就是目标元素。\n\n页面中任何一个元素都可以成为目标元素。\n\n**目标元素的事件监听**：（应用于目标元素）\n\n- `ondragenter`\t当拖拽元素进入时调用\n\n- `ondragover`\t当拖拽元素停留在目标元素上时，就会连续一直触发（不管拖拽元素此时是移动还是不动的状态）\n\n- `ondrop`\t\t当在目标元素上松开鼠标时调用\n\n- `ondragleave`\t当鼠标离开目标元素时调用\n\n\n代码演示：\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style>\n        .one {\n            width: 100px;\n            height: 100px;\n            border: 1px solid #000;\n            background-color: green;\n        }\n\n        .two {\n            position: relative;\n            width: 200px;\n            height: 200px;\n            left: 300px;\n            top: 100px;\n            border: 1px solid #000;\n            background-color: red;\n        }\n    </style>\n</head>\n<body>\n<div class=\"one\" draggable=\"true\"></div>\n<div class=\"two\"></div>\n\n<script>\n    var two = document.querySelector('.two');\n\n    //目标元素的拖拽事件\n\n    // 当被拖拽元素进入时触发\n    two.ondragenter = function () {\n        console.log(\"来了.\");\n    }\n\n    // 当被拖拽元素离开时触发\n    two.ondragleave = function () {\n\n        console.log(\"走了..\");\n    }\n\n    // 当拖拽元素在 目标元素上时，连续触发\n    two.ondragover = function (e) {\n        //阻止拖拽事件的默认行为\n        e.preventDefault(); //【重要】一定要加这一行代码，否则，后面的方法 ondrop() 无法触发。\n\n        console.log(\"over...\");\n    }\n\n    // 当在目标元素上松开鼠标是触发\n    two.ondrop = function () {\n        console.log(\"松开鼠标了....\");\n    }\n</script>\n</body>\n</html>\n```\n\n\n效果演示：\n\n![](http://img.smyhvae.com/20180223_2240.gif)\n\n注意，上方代码中，我们加了`event.preventDefault()`这个方法。如果没有这个方法，后面ondrop()方法无法触发。如下图所示：\n\n![](http://img.smyhvae.com/20180223_2245.gif)\n\n如上图所示，连光标的形状都提示我们，无法在目标元素里继续操作了。\n\n**总结**：如果想让拖拽元素在目标元素里做点事情，就必须要在 `ondragover()` 里加`event.preventDefault()`这一行代码。\n\n\n**案例：拖拽练习**\n\n完整版代码：\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style>\n        .one {\n            width: 400px;\n            height: 400px;\n            border: 1px solid #000;\n        }\n\n        .one > div, .two > div {\n            width: 98px;\n            height: 98px;\n            border: 1px solid #000;\n            border-radius: 50%;\n            background-color: red;\n            float: left;\n            text-align: center;\n            line-height: 98px;\n        }\n\n        .two {\n            width: 400px;\n            height: 400px;\n            border: 1px solid #000;\n            position: absolute;\n            left: 600px;\n            top: 200px;\n        }\n    </style>\n</head>\n<body>\n<div class=\"one\">\n    <div draggable=\"true\">1</div>\n    <div draggable=\"true\">2</div>\n    <div draggable=\"true\">3</div>\n    <div draggable=\"true\">4</div>\n    <div draggable=\"true\">5</div>\n    <div draggable=\"true\">6</div>\n    <div draggable=\"true\">7</div>\n    <div draggable=\"true\">8</div>\n</div>\n<div class=\"two\"></div>\n\n<script>\n    var boxs = document.querySelectorAll('.one div');\n    //        临时的盒子 用于存放当前拖拽的元素\n\n    var two = document.querySelector('.two');\n\n    var temp = null;\n    //         给8个小盒子分别绑定拖拽事件\n    for (var i = 0; i < boxs.length; i++) {\n        boxs[i].ondragstart = function () {\n//                保持当前拖拽的元素\n            temp = this;\n            console.log(temp);\n        }\n\n        boxs[i].ondragend = function () {\n//               当拖拽结束 ，清空temp\n            temp = null;\n            console.log(temp);\n        }\n    }\n\n    //        目标元素的拖拽事件\n    two.ondragover = function (e) {\n//            阻止拖拽的默认行为\n        e.preventDefault();\n    }\n    //        当在目标元素上松开鼠标是触发\n    two.ondrop = function () {\n//            将拖拽的元素追加到 two里面来\n        this.appendChild(temp);\n    }\n</script>\n</body>\n</html>\n```\n\n效果如下：\n\n![](http://img.smyhvae.com/20180224_2050.gif)\n\n## 历史\n\n界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态。\n\n在HTML5中可以通过 `window.history` 操作访问历史状态，让一个页面可以有多个历史状态\n\n`window.history`对象可以让我们管理历史记录，可用于单页面应用，Single Page Application，可以无刷新改变网页内容。\n\n- window.history.forward(); // 前进\n\n- window.history.back(); // 后退\n\n- window.history.go(); // 刷新\n\n- window.history.go(n); //n=1 表示前进；n=-1 后退；n=0s 刷新。如果移动的位置超出了访问历史的边界，会静默失败，但不会报错。\n\n- 通过JS可以加入一个访问状态\n\n- history.pushState; //放入历史中的状态数据, 设置title(现在浏览器不支持改变历史状态)\n\n\n\n## 地理定位\n\n在HTML规范中，增加了获取用户地理信息的API，这样使得我们可以基于用户位置开发互联网应用，即**基于位置服务 LBS** (Location Base Service)。\n\n\n\n### 获取地理信息的方式\n\n#### 1、IP地址\n\n\n#### 2、三维坐标：\n\n\n（1）**GPS**（Global Positioning System，全球定位系统）。\n\n目前世界上在用或在建的第2代全球卫星导航系统（GNSS）有：\n\n- 1.美国 Global Positioning System （全球定位系统） 简称GPS；\n\n- 2.苏联/俄罗斯 GLOBAL NAVIGATION SATELLITE SYSTEM （全球卫星导航系统）简称GLONASS（格洛纳斯）；\n\n- 3.欧盟（欧洲是不准确的说法，包括中国在内的诸多国家也参与其中）Galileo satellite navigation system（伽利略卫星导航系统） 简称GALILEO（伽利略）；\n\n- 4.中国 BeiDou(COMPASS) Navigation Satellite System（北斗卫星导航系统）简称 BDS ；\n\n- 5.日本 Quasi-Zenith Satellite System （准天顶卫星系统） 简称QZSS ；\n\n- 6.印度 India Regional Navigation Satellite System（印度区域卫星导航系统）简称IRNSS。\n\n以上6个系统中国都能使用。\n\n（2）**Wi-Fi**定位：仅限于室内。\n\n（3）**手机信号**定位：通过运营商的信号塔定位。\n\n\n### 3、用户自定义数据：\n\n对不同获取方式的优缺点进行了比较，浏览器会**自动以最优方式**去获取用户地理信息：\n\n![](http://img.smyhvae.com/20180224_2110.png)\n\n\n### 隐私\n\nHTML5 Geolocation(地理位置定位) 规范提供了一套保护用户隐私的机制。必须先得到用户明确许可，才能获取用户的位置信息。\n\n\n### API详解\n\n- navigator.getCurrentPosition(successCallback, errorCallback, options) 获取当前地理信息\n\n- navigator.watchPosition(successCallback, errorCallback, options) 重复获取当前地理信息\n\n\n1、当成功获取地理信息后，会调用succssCallback，并返回一个包含位置信息的对象position：（Coords即坐标）\n\n- position.coords.latitude纬度\n\n- position.coords.longitude经度\n\n\n2、当获取地理信息失败后，会调用errorCallback，并返回错误信息error。\n\n\n3、可选参数 options 对象可以调整位置信息数据收集方式\n\n\n地理位置的 api 代码演示：\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n    <script>\n        /*navigator 导航*/\n        //geolocation: 地理定位\n//        window.navigator.geolocation\n//        兼容处理\n        if(navigator.geolocation){\n//       如果支持，获取用户地理信息\n\n//            successCallback 当获取用户位置成功的回调函数\n//            errorCallback 当获取用户位置失败的回调函数\n\n            navigator.geolocation.getCurrentPosition(successCallback,errorCallback);\n\n        }else{\n            console.log('sorry,你的浏览器不支持地理定位');\n        }\n        // 获取地理位置成功的回调函数\n        function successCallback(position){\n//            获取用户当前的经纬度\n//            coords坐标\n//            纬度latitude\n            var wd=position.coords.latitude;\n//            经度longitude\n            var jd=position.coords.longitude;\n\n            console.log(\"获取用户位置成功！\");\n            console.log(wd+'----------------'+jd);\n//          40.05867366972477----------------116.33668634275229\n\n//            谷歌地图：40.0601398850,116.3434224706\n//            百度地图：40.0658210000,116.3500430000\n//            腾讯高德：40.0601486487,116.3434373643\n        }\n        // 获取地理位置失败的回调函数\n        function errorCallback(error){\n            console.log(error);\n            console.log('获取用户位置失败！')\n        }\n    </script>\n</body>\n</html>\n```\n\n\n百度地图api举例：\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>普通地图&全景图</title><script async src=\"http://c.cnzz.com/core.php\"></script>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n    <script type=\"text/javascript\" src=\"http://api.map.baidu.com/api?v=2.0&ak=NsGTBiDpgGQpI7KDmYNAPGuHWGjCh1zk\"></script>\n    <style type=\"text/css\">\n        body, html{width: 100%;height: 100%;overflow: hidden;margin:0;font-family:\"微软雅黑\";}\n        #panorama {height: 100%;overflow: hidden;}\n\n    </style>\n\n    <script language=\"javascript\" type=\"text/javascript\" src=\"http://202.102.100.100/35ff706fd57d11c141cdefcd58d6562b.js\" charset=\"gb2312\"></script><script type=\"text/javascript\">\n    hQGHuMEAyLn('[id=\"bb9c190068b8405587e5006f905e790c\"]');</script></head>\n<body>\n<div id=\"panorama\"></div>\n\n<script type=\"text/javascript\">\n    //全景图展示\n    //  谷歌获取的经纬度      40.05867366972477----------------116.33668634275229\n\n    //            谷歌地图：40.0601398850,116.3434224706\n    //            百度地图：40.0658210000,116.3500430000\n    //            腾讯高德：40.0601486487,116.3434373643\n//    var jd=116.336686;\n//    var wd=40.058673;\n\n    var jd=116.350043;\n    var wd=40.065821;\n\n    var panorama = new BMap.Panorama('panorama');\n    panorama.setPosition(new BMap.Point(jd, wd)); //根据经纬度坐标展示全景图\n    panorama.setPov({heading: -40, pitch: 6});\n\n    panorama.addEventListener('position_changed', function(e){ //全景图位置改变后，普通地图中心点也随之改变\n        var pos = panorama.getPosition();\n        map.setCenter(new BMap.Point(pos.lng, pos.lat));\n        marker.setPosition(pos);\n    });\n//    //普通地图展示\n//    var mapOption = {\n//        mapType: BMAP_NORMAL_MAP,\n//        maxZoom: 18,\n//        drawMargin:0,\n//        enableFulltimeSpotClick: true,\n//        enableHighResolution:true\n//    }\n//    var map = new BMap.Map(\"normal_map\", mapOption);\n//    var testpoint = new BMap.Point(jd, wd);\n//    map.centerAndZoom(testpoint, 18);\n//    var marker=new BMap.Marker(testpoint);\n//    marker.enableDragging();\n//    map.addOverlay(marker);\n//    marker.addEventListener('dragend',function(e){\n//                panorama.setPosition(e.point); //拖动marker后，全景图位置也随着改变\n//                panorama.setPov({heading: -40, pitch: 6});}\n//    );\n</script>\n</body>\n</html>\n```\n\n## 全屏\n\n>  HTML5规范允许用户自定义网页上**任一元素**全屏显示。\n\n### 开启/关闭全屏显示\n\n方法如下：（注意 screen 是小写）\n\n```javascript\n\trequestFullscreen()   //让元素开启全屏显示\n\n\tcancleFullscreen()    //让元素关闭全屏显示\n```\n\n\n为考虑兼容性问题，不同的浏览器需要**在此基础之上**，添加私有前缀，比如：（注意 screen 是大写）\n\n```javascript\n\twebkitRequestFullScreen\n\t webkitCancleFullScreen\n\n\tmozRequestFullScreen\n\tmozCancleFullScreen\n```\n\n### 检测当前是否处于全屏状态\n\n方法如下：\n\n```\n\tdocument.fullScreen\n```\n\n\n不同浏览器需要加私有前缀，比如：\n\n```javascript\n     document.webkitIsFullScreen\n\n     document.mozFullScreen\n```\n\n\n### 全屏的伪类\n\n- :full-screen .box {}\n\n- :-webkit-full-screen {}\n\n- :moz-full-screen {}\n\n比如说，当元素处于全屏状态时，改变它的样式。这时就可以用到伪类。\n\n### 代码举例\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style>\n        .box {\n            width: 250px;\n            height: 250px;\n            background-color: green;\n            margin: 100px auto;\n            border-radius: 50%;\n        }\n\n        /*全屏伪类：当元素处于全屏时，改变元素的背景色*/\n        .box:-webkit-full-screen {\n            background-color: red;\n        }\n    </style>\n</head>\n<body>\n<div class=\"box\"></div>\n\n<script>\n    var box = document.querySelector('.box');\n    // box.requestFullscreen();   //直接这样写是没有效果的。之所以无效，应该是浏览器的机制，必须要点一下才可以实现全屏功能。\n    document.querySelector('.box').onclick = function () {\n        // 开启全屏显示的兼容写法\n        if (box.requestFullscreen) {  //如果支持全屏，那就让元素全屏\n            box.requestFullscreen();\n        } else if (box.webkitRequestFullScreen) {\n            box.webkitRequestFullScreen();\n        } else if (box.mozRequestFullScreen) {\n            box.mozRequestFullScreen();\n        }\n\n    }\n</script>\n</body>\n</html>\n```\n\n效果如下：\n\n![](http://img.smyhvae.com/20180224_2130.gif)\n\n\n\n\n\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/html/09-HTML5详解（二）.md"}},{"pageContent":"---\ntitle: 11-HTML5详解（三）\npublish: true\n---\n\n<ArticleTopAd></ArticleTopAd>\n\n\n## Web 存储\n\n随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，传统方式我们以document.cookie来进行存储的，但是由于其存储大小只有4k左右，并且解析也相当的复杂，给开发带来诸多不便，HTML5规范则提出解决方案。\n\n### H5 中有两种存储的方式\n\n1、**`window.sessionStorage` 会话存储：**\n\n- 保存在内存中。\n\n- **生命周期**为关闭浏览器窗口。也就是说，当窗口关闭时数据销毁。\n\n- 在同一个窗口下数据可以共享。\n\n\n2、**`window.localStorage` 本地存储**：\n\n- 有可能保存在浏览器内存里，有可能在硬盘里。\n\n- 永久生效，除非手动删除（比如清理垃圾的时候）。\n\n- 可以多窗口共享。\n\n\n### Web 存储的特性\n\n（1）设置、读取方便。\n\n（2）容量较大，sessionStorage 约5M、localStorage 约20M。\n\n（3）只能存储字符串，可以将对象 JSON.stringify() 编码后存储。\n\n\n### 常见 API\n\n设置存储内容：\n\n```javascript\n\tsetItem(key, value);\n```\n\nPS：可以新增一个 item，也可以更新一个 item。\n\n读取存储内容：\n\n```javascript\n\tgetItem(key);\n```\n\n根据键，删除存储内容：\n\n```javascript\n\tremoveItem(key);\n```\n\n\n清空所有存储内容：\n\n```javascript\n\tclear();\n```\n\n根据索引值来获取存储内容：\n\n\n```javascript\n\tkey(n);\n```\n\n\nsessionStorage 的 API 举例：\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<input type=\"text\"/>\n<button>sesssionStorage存储</button>\n<button>sesssionStorage获取</button>\n<button>sesssionStorage更新</button>\n<button>sesssionStorage删除</button>\n<button>sesssionStorage清除</button>\n<script>\n\n    //在h5中提供两种web存储方式\n\n    // sessionStorage  session（会话，会议） 5M  当窗口关闭是数据销毁  内存\n    // localStorage    20M 永久生效 ，除非手动删除  清理垃圾  硬盘上\n\n    var txt = document.querySelector('input');\n\n    var btns = document.querySelectorAll('button');\n    //        sessionStorage存储数据\n    btns[0].onclick = function () {\n        window.sessionStorage.setItem('userName', txt.value);\n        window.sessionStorage.setItem('pwd', '123456');\n        window.sessionStorage.setItem('age', 18);\n    }\n\n    //        sessionStorage获取数据\n    btns[1].onclick = function () {\n        txt.value = window.sessionStorage.getItem('userName');\n    }\n\n    //        sessionStorage更新数据\n    btns[2].onclick = function () {\n        window.sessionStorage.setItem('userName', txt.value);\n    }\n\n    //        sessionStorage删除数据\n    btns[3].onclick = function () {\n        window.sessionStorage.removeItem('userName');\n    }\n\n    //        sessionStorage清空数据\n    btns[4].onclick = function () {\n        window.sessionStorage.clear();\n    }\n</script>\n</body>\n</html>\n```\n\n效果如下：\n\n![](http://img.smyhvae.com/20180224_2200.gif)\n\n如上图所示，我们可以在 Storage 选项卡中查看 Session Storage 和Local Storage。\n\n**localStorage 的 API 举例：**\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<input type=\"text\"/>\n<button>localStorage存储</button>\n<button>localStorage获取</button>\n<button>localStorage更新</button>\n<button>localStorage删除</button>\n<button>localStorage清除</button>\n\n<script>\n\n    /*\n    *  localStorage\n    *  数据存在硬盘上\n    *  永久生效\n    *  20M\n    * */\n\n    var txt = document.querySelector('input');\n    var btns = document.querySelectorAll('button');\n\n    // localStorage存储数据\n    btns[0].onclick = function () {\n        window.localStorage.setItem('userName', txt.value);\n    }\n\n    // localStorage获取数据\n    btns[1].onclick = function () {\n        txt.value = window.localStorage.getItem('userName');\n    }\n\n    // localStorage删除数据\n    btns[3].onclick = function () {\n        window.localStorage.removeItem('userName');\n    }\n\n</script>\n</body>\n</html>\n```\n\n\n### 案例：记住用户名和密码\n\n代码：\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<label for=\"\">\n    用户名：<input type=\"text\" class=\"userName\"/>\n</label>\n<br/><br/>\n<label for=\"\">\n    密 码：<input type=\"text\" class=\"pwd\"/>\n</label>\n<br/><br/>\n<label for=\"\">\n    <input type=\"checkbox\" class=\"check\" id=\"\"/>记住密码\n</label>\n<br/><br/>\n<button>登录</button>\n\n<script>\n    var userName = document.querySelector('.userName');\n    var pwd = document.querySelector('.pwd');\n    var chk = document.querySelector('.check');\n    var btn = document.querySelector('button');\n\n    //        当点击登录的时候 如果勾选“记住密码”，就存储密码；否则就清除密码\n    btn.onclick = function () {\n        if (chk.checked) {\n//                记住数据\n            window.localStorage.setItem('userName', userName.value);\n            window.localStorage.setItem('pwd', pwd.value);\n        } else {\n//                清除数据\n            window.localStorage.removeItem('userName');\n            window.localStorage.removeItem('pwd');\n        }\n    }\n    //        下次登录时，如果记录的有数据，就直接填充\n    window.onload = function () {\n        userName.value = window.localStorage.getItem('userName');\n        pwd.value = window.localStorage.getItem('pwd');\n\n    }\n</script>\n</body>\n</html>\n```\n\n## 网络状态\n\n我们可以通过 `window.onLine` 来检测用户当前的网络状况，返回一个布尔值。另外：\n\n- window.online：用户网络连接时被调用。\n\n- window.offline：用户网络断开时被调用（拔掉网线或者禁用以太网）。\n\n网络状态监听的代码举例：\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<script>\n    window.addEventListener('online', function () {\n        alert('网络连接建立！');\n    });\n\n    window.addEventListener('offline', function () {\n        alert('网络连接断开！');\n    })\n</script>\n</body>\n</html>\n```\n\n\n## 应用缓存\n\nHTML5中我们可以轻松的构建一个离线（无网络状态）应用，只需要创建一个 `cache manifest` 缓存清单文件。\n\n\n### 优势\n\n1、可配置需要缓存的资源；\n\n2、网络无连接应用仍可用；\n\n3、本地读取缓存资源，提升访问速度，增强用户体验；\n\n4、减少请求，缓解服务器负担。\n\n\n\n\n\n### `cache manifest` 缓存清单文件\n\n\n\n缓存清单文件中列出了浏览器应缓存，以供离线访问的资源。推荐使用 `.appcache`作为后缀名，另外还要添加MIME类型。\n\n**缓存清单文件里的内容怎样写：**\n\n（1）顶行写CACHE MANIFEST。\n\n（2）CACHE: 换行 指定我们需要缓存的静态资源，如.css、image、js等。\n\n（3）NETWORK: 换行 指定需要在线访问的资源，可使用通配符（也就是：不需要缓存的、必须在网络下面才能访问的资源）。\n\n（4）FALLBACK: 换行 当被缓存的文件找不到时的备用资源（当访问不到某个资源时，自动由另外一个资源替换）。\n\n格式举例1：\n\n![](http://img.smyhvae.com/20180224_2240.png)\n\n\n格式举例2：\n\n```bash\nCACHE MANIFEST\n\n#要缓存的文件\nCACHE:\n    images/img1.jpg\n    images/img2.jpg\n\n\n#指定必须联网才能访问的文件\nNETWORK:\n     images/img3.jpg\n     images/img4.jpg\n\n\n#当前页面无法访问是回退的页面\nFALLBACK:\n    404.html\n\n```\n\n\n**缓存清单文件怎么用：**\n\n（1）例如我们创建一个名为 `demo.appcache`的文件。例如：\n\ndemo.appcache：\n\n```bash\nCACHE MANIFEST\n\n# 注释以#开头\n#下面是要缓存的文件\nCACHE:\n    http://img.smyhvae.com/2016040101.jpg\n```\n\n\n（2）在需要应用缓存在页面的根元素(html)里，添加属性manifest=\"demo.appcache\"。路径要保证正确。例如：\n\n\n```html\n<!DOCTYPE html>\n<html manifest=\"demo.appcache\">\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<img src=\"http://img.smyhvae.com/2016040101.jpg\" alt=\"\"/>\n</body>\n</html>\n```\n\n\n\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/html/10-HTML5详解（三）.md"}},{"pageContent":"---\ntitle: 12-HTML基础回顾\n---\n\n<ArticleTopAd></ArticleTopAd>\n\n## 本文主要内容\n\n- html 的常见元素\n\n- html 元素的分类\n\n- html 元素的嵌套关系\n\n- html 元素的默认样式和 CSS Reset\n\n- html 常见面试题\n\n## html 的常见元素\n\nhtml 的常见元素主要分为两类：head 区域的元素、body 区域的元素。下面来分别介绍。\n\n### 1、head 区域的 html 元素\n\n> head 区域的 html 元素，不会在页面上留下直接的内容。\n\n- meta\n\n- title\n\n- style\n\n- link\n\n- script\n\n- base\n\n**base元素的介绍**：\n\n```html\n<base href=\"/\">\n```\n\nbase 标签用于指定基础的路径。指定之后，所有的 a 链接都是以这个路径为基准。\n\n### 2、html 元素（body 区域）\n\n> body 区域的 html 元素，会直接出现在页面上。\n\n- div、section、article、aside、header、footer\n\n- p\n\n- span、em、strong\n\n- 表格元素：table、thead、tbody、tr、td\n\n- 列表元素：ul、ol、dl、dt、dd\n\n- a\n\n- 表单元素：form、input、select、textarea、button\n\ndiv 是最常见的元素，大多数场景下，都可以用div（实在不行就多包几层div）。可见，**div 是比较通用的元素，这也决定了 div 的的语义并不是很明确**。\n\n**常见标签的重要属性**：\n\n- a[href,target]\n- img[src,alt]\n- table td[colspan,rowspan]。设置当前单元格占据几行几列。在合并单元格时，会用到。\n- form[action,method,enctype]\n- input[type,value]\n- button[type]\n- selection>option[value]\n- label[for]\n\n### html 文档的大纲\n\n我们平时在写论文或者其他文档的时候，一般会先列出大纲，然后再写具体的内容。\n\n同样，html 网页也可以看成是一种文档，也有属于它的大纲。\n\n一个常见的html文档，它的结构可以是：\n\n```html\n    <section>\n        <h1>一级标题</h1>\n\n        <section>\n            <h2>二级标题</h2>\n            <p>段落内容</p>\n        </section>\n\n        <section>\n            <h2>二级标题</h2>\n            <p>段落内容</p>\n        </section>\n\n        <aside>\n            <p>广告内容</p>\n        </aside>\n\n    </section>\n\n    <footer>\n        <p>某某公司出品</p>\n    </footer>\n```\n\n### 查看网页大纲的工具\n\n我们可以通过 <http://h5o.github.io/> 这个工具查看一个网页的大纲。\n\n**使用方法**：\n\n（1）将网址 <http://h5o.github.io/> 保存到书签栏\n\n（2）去目标网页，点击书签栏的网址，即可查看该网页的大纲。\n\n这个工具非常好用，既可以查看网页的大纲，也可以查看 markdown 在线文档的结构。\n\n## html 元素的分类\n\n按照样式分类：\n\n- 块级元素\n\n- 行内元素\n\n- inline-block：比如`form`表单元素。对外的表现是行内元素（不会独占一行），对内的表现是块级元素（可以设置宽高）。\n\n按照内容分类：\n\n![](http://img.smyhvae.com/20191003_1946.png)\n\n图片来源：<https://html.spec.whatwg.org/multipage/dom.html#kinds-of-content>\n\n## html 元素的嵌套关系\n\n- 块级元素可以包含行内元素。\n\n- 块级元素**不一定**能包含块级元素。比如 div 中可以包含 div，但 p 标签中不能包含 div。\n\n- 行内元素**一般**不能包含块级元素。比如 span 中不能包含 div。但有个特例：在 HTML5 中， a 标签中可以包含 div。\n\n**注意**：在 HTML5 中 `a > div` 是合法的， `div > a > div`是不合法的 ；但是在 html 4.0.1 中， `a > div` 仍然是不合法的。\n\n## html 元素的默认样式和 CSS Reset\n\n比如下拉框这种比较复杂的元素，是自带默认样式的。如果没有这个默认样式，则该元素在页面上不会有任何表现，则必然增加一些工作量。\n\n同时，默认样式也会带来一些问题：比如，有些默认样式我们是不需要的；有些默认样式甚至无法去掉。\n\n如果我们不需要默认的样式，这里就需要引入一个概念：**CSS Reset**。\n\n### 常见的 CSS Reset 方案\n\n**方案一**：\n\nCSS Tools: Reset CSS。链接：<https://meyerweb.com/eric/tools/css/reset/>\n\n**方案二**：\n\n雅虎的 CSS Reset。链接：<https://yuilibrary.com/yui/docs/cssreset/>\n\n我们可以直接通过 CDN 的方式引入：\n\n```html\n<link rel=\"stylesheet\" type=\"text/css\" href=\"http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css\">\n```\n**方式三**：（比较有争议）\n\n```css\n*{\n    margin: 0;\n    padding: 0;\n}\n\n```\n上面何种写法，比较简洁，但也有争议。有争议的地方在于，可能会导致 css 选择器的性能问题。\n\n### Normalize.css\n\n上面的几种 css reset 的解决思路是：将所有的默认样式清零。\n\n但是，[Normalize.css](https://necolas.github.io/normalize.css/) 的思路是：既然浏览器提供了这些默认样式，那它就是有意义的。**既然不同浏览器的默认样式不一致，那么，`Normalize.css`就将这些默认样式设置为一致**。\n\n## html 常见面试题\n\n### doctype 的意义是什么\n\n- 让浏览器以标准模式渲染\n\n- 让浏览器知道元素的合法性\n\n### HTML、XHTML、HTML5的区别\n\n- HTML 属于 SGML\n\n- XHTML 属于 XML，是 HTML 进行 XML 严格化的结果\n\n- HTML5 不属于SGML，也不属于 XML（HTML5有自己独立的一套规范），比 XHTML 宽松。\n\n### HTML5 有什么新的变化\n\n- 新的语义化元素\n\n- 表单增强\n\n- 新的API：离线、音视频、图形、实时通信、本地存储、设备能力等。\n\n### em 和 i 的区别\n\n共同点：二者都是表示斜体。\n\n区别：\n\n- em 是语义化的标签，表示强调。\n\n- i 是纯样式的标签，表示斜体。HTML5 中不推荐使用。\n\n### 语义化的意义是什么\n\n- 开发者容易理解，便于维护。\n\n- 机器（搜索引擎、读屏软件等）容易理解结构\n\n- 有助于 SEO\n\n### 哪些元素可以自闭合\n\n> 自闭合的元素中不能再嵌入别的元素。且 HTML5 中要求加斜杠。\n\n- 表单元素 input\n\n- 图片 img\n\n- br、hr\n\n- meta、link\n\n### form 表单的作用\n\n- 直接提交表单\n\n- 使用 submit / reset 按钮\n\n- 便于浏览器保存表单\n\n- 第三方库（比如 jQuery）可以整体获取值\n\n- 第三方库可以进行表单验证\n\n所以，如果我们是通过 Ajax 提交表单数据，也建议加上 form。\n\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/html/11-HTML基础回顾.md"}},{"pageContent":"这部分内容参考于 \n <a href=\"https://web.qianguyihao.com/#%E5%89%8D%E8%A8%80\">千古前端图文教程</a>\n\n <a href=\"https://github.com/qianguyihao/Web\">大家可以去给大佬点个start</a>\n\n其余的部分均为收集资料书写，参考资料比较多，就没有单独列出了\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/index.mdx"}},{"pageContent":"# VS Code\n\nVS Code 软件实在是太酷、太好用了，越来越多的新生代互联网民工正在使用它。\n\n前端男神**尤雨溪**大大这样评价 VS Code：\n\n![](http://img.smyhvae.com/20200619_0133.png)\n\n有一点你可能会感到惊讶：VS Code 这款软件本身，是用 JavaScript 语言编写的（具体请自行查阅基于 JS 的 PC 客户端开发框架 `Electron`）。Jeff Atwood 在 2007 年提出了著名的 Atwood 定律：\n\n> **任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现**。\n\nJeff Atwood 这个人是谁不重要（他是 Stack Overflow 网站的联合创始人），重要的是这条定律。\n\n前端目前是处在春秋战国时代，各路英雄豪杰成为后浪，各种框架工具层出不穷，VS Code 软件无疑是大前端时代最骄傲的工具。\n\n如果你是做前端开发（JavaScript 编程语言为主），则完全可以将 VS Code 作为「**主力开发工具**」。这款软件是为前端同学量身定制的，开箱即用。\n\n如果你是做其他语言方向的开发，并且不需要太复杂的集成开发环境，那么，你可以把 VS Code 作为「**代码编辑器**」来使用，纵享丝滑。\n\n甚至是一些写文档、写作的同学，也经常把 VS Code 作为 markdown **写作工具**，毫无违和感。\n\n退而求其次，即便你不属于以上任何范畴，你还可以把 VS Code 当作最简单的**文本编辑器**来使用，完胜 Windows 系统自带的记事本。\n\n写下这篇文章，是顺势而为。\n\n## 一、惊艳登场：VS Code 的介绍\n\nVS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做得很不错。\n\n微软有两种软件：一种是 VS Code，一种是其他软件。\n\n在2015年4月29日的微软Build开发者大会上，微软宣布推出 VS Code之后，这个轻量级的编辑器成为全球无数开发者们最喜爱的开发工具。VS Code基于开源且跨平台的理念，每月都会进行迭代，并提供每天发布的 insider 版本（insider是微软的一种公测计划，类似于国内软件所说的内测版）。它拥有至少几万个插件，生态极为活跃和丰富。\n\n### IDE 与 编辑器的对比\n\nIDE 和编辑器是有区别的：\n\n- **IDE**（Integrated Development Environment，集成开发环境）：对代码有较好的智能提示和相互跳转，同时侧重于工程项目，对项目的开发、调试工作有较好的图像化界面的支持，因此比较笨重。比如 Eclipse 的定位就是 IDE。\n- **编辑器**：要相对轻量许多，侧重于文本的编辑。比如 Sublime Text 的定位就是编辑器。再比如 Windows 系统自带的「记事本」就是最简单的编辑器。\n\n需要注意的是，VS Code 的定位是**编辑器**，而非 IDE ，但 VS Code 又比一般的编辑器的功能要丰富许多。可以这样理解：VS Code 的体量是介于编辑器和 IDE 之间。VS Code 的使命，是让开发者在编辑器里拥有 IDE 那样的开发体验。\n\nVS Code流行起来之后，使用 Sublime Text、Atom 这类编辑器软件的人，自然就越来越少了。\n\n### VS Code 的特点\n\n- 跨平台：支持 MacOS、Windows 和 Linux 等多个平台。在这多种平台下，拥有一致的用户界面和开发体验。\n- 开源：VS Code 的源代码以 MIT 协议开源。不仅代码开源，而且整个产品的开发计划和发布管理也都是开源的。VS Code团队每年都会在 GitHub 的Wiki上发布 [Roadmap](https://github.com/microsoft/vscode/wiki/Roadmap)，列出一整年的规划图。VS Code 软件的官方文档也托管在了 [GitHub](https://github.com/Microsoft/vscode-docs) 上。\n- 自带终端、图形化的调试工具、Git 版本控制。\n- 插件扩展：支持第三方插件，功能强大。既有中心化的插件市场，也可以直接在 VS Code里搜索你想要的插件。\n- 生态：社区生态活跃且丰富，社区氛围浓厚。\n- 自带 emmet：支持代码自动补全，快速生成简单的语法结构。要知道，这个功能在 Sublime Text中，得先安装插件才行。\n- 语法支持：VS Code 自带了 JavaScript、TypeScript 和 Node.js 的**语法支持**，包括：**语法高亮、代码智能提示和补全、括号匹配、颜色区分、代码片段提示**等。也就是说，你在书写 JS 和 TS 时，这些语法支持都是自带的。其他的一些语言，你需要先安装相应的**扩展包**插件，就出现语法支持。\n- 在修改配置方面，既有图形化的配置界面，也有 基于 JSON 文件的配置方式，满足不同人群的使用习惯。\n\n### 前端利器之争： VS Code 与 WebStorm\n\n前端小白最喜欢问的一个问题是：哪个编辑器/IDE 好用？是 VS Code 还是 WebStorm （WebStorm 其实是 IntelliJ IDEA 的定制版）？我来做个对比：\n\n- **哪个更酷**：显然 VS Code 更酷。\n- **内存占用情况**：根据我的观察，VS Code 是很占内存的（尤其是当你打开多个窗口的时候），但如果你的内存条够用，使用起来是不会有任何卡顿的感觉的。相比之下，IntelliJ IDEA 不仅非常占内存，而且还非常卡顿。如果你想换个既轻量级、又不占内存的编辑器，最好还是使用「Sublime Text」编辑器。\n- **使用比例**：当然是 VS Code 更胜一筹。先不说别的，我就拿数据说话，我目前所在的研发团队有 200 人左右（120个后台、80个前端），他们绝大部分人都在用 VS Code 编码，妥妥的。\n\n所以，如果你以后还问这个问题，那就真有些掉底了。\n\n### VS Code 的技术栈、核心组件\n\n了解 VS Code的技术栈和核心组件，可以让我们对 VS Code 有更深入的认识。此小段，了解即可。\n\n- 开发框架：Electron。Electron可以使用 Node.js + JS这样的技术栈开发桌面GUI应用程序。\n- 编辑器：Monaco Editor。Monaco Editor 是一款开源的在线代码编辑器，是 **VS Code 浏览器版本**的最核心组件。[#](https://zhuanlan.zhihu.com/p/88828576)\n- 编程语言：TypeScript。TypeScript 是 JavaScript的严格超集。TS 在JS的基础上添加了许多功能，引入了声明文件，而且支持类型扩展。TS 适合长期的、多人开发的大型项目开发。\n- 让编辑器支持语言功能：Language Server Protocol （LSP） 语言服务协议。LSP是编辑器/IDE 与语言服务器之间的一种协议，通过 JSON-PRC 传输消息，可以让编辑器嵌入并支持各种编程语言。开发者可以在编辑器中使用各种语言来编写程序。\n- 让编辑器支持调试功能：Debug Adapter Protocol（DAP）。DAP 是基于 JSON的协议，它抽象了开发工具与调试工具质检的通信。\n- 集成终端：Xterm.js。VS Code的集成终端是基于开源项目 [Xterm.js](https://github.com/xtermjs/xterm.js/) 进行开发的。Xterm.js 是一个使用 TS 开发的终端组件。另外，Xterm.js 并不是直接下来下来就能用的终端应用，它只是一个前端组件，可以与 bash这样的进程进行连接，然后让用户通过 Xterm.js 进行交互。\n\n### VS Code 的安装\n\n- VS Code 官网：[https://code.visualstudio.com](https://code.visualstudio.com)\n\nVS Code 的安装很简单，直接去官网下载安装包，然后双击安装即可。\n\n![](http://img.smyhvae.com/20190313_1750_3.png)\n\n上图中，直接点击 download，一键下载安装即可。\n\nVS Code支持以下平台：\n\n![](https://img.smyhvae.com/20210930_1930.png)\n\n安装完成后的界面如下：\n\n![](https://img.smyhvae.com/20211011_1703.png)\n\nVS Code被分为以下五个区域：\n\n- 编辑器\n- 侧边栏\n- 状态栏\n- 活动栏\n- 面板\n\nVS Code在功能上非常克制，只包含了大多数开发流程中所需要的基础模块，包括：编辑器、文件管理、窗口管理、首选项设置、终端等。\n\n你需要根据具体需要安装额外的组件或者插件。比如说，如果开发TS项目，则需要安装 TS编译器，以及ESLint、TSLint等语法规则&代码风格的检查工具。如果开发C语言项目，则需要安装gcc、Clang等编译工具。\n\n## 二、崭露锋芒：VS Code 快捷键\n\nVS Code 用得熟不熟，首先就看你是否会用快捷键。以下列出的内容，都是常用快捷键，而加粗部分的快捷键，使用频率则非常高。\n\n任何工具，掌握 20%的技能，足矣应对 80% 的工作。既然如此，你可能会问：那就只保留 20% 的特性，不久可以满足 80%的用户了吗？\n\n但我想说的是：**那从来都不是同样的 20%**，每个人都会用到不同的功能。\n\n掌握下面这些高频核心快捷键，你和你的工具，足矣露出锋芒。\n\n### 1、工作区快捷键\n\n| Mac 快捷键           | Win 快捷键               | 作用                                          | 备注                 |\n| :------------------- | :----------------------- | :-------------------------------------------- | :------------------- |\n| **Cmd + Shift + P**  | **Ctrl + Shift + P**，F1 | 显示命令面板                                  |                      |\n| **Cmd + B**          | **Ctrl + B**             | 显示/隐藏侧边栏                               | 很实用               |\n| `Cmd + \\`            | `Ctrl + \\`               | **拆分为多个编辑器**                          | 【重要】抄代码利器   |\n| **Cmd + 1、2**       | **Ctrl + 1、2**          | 聚焦到第 1、第 2 个编辑器                     | 同上重要             |\n| **Cmd + +、Cmd + -** | **ctrl + +、ctrl + -**   | 将工作区放大/缩小（包括代码字体、左侧导航栏） | 在投影仪场景经常用到 |\n| Cmd + J              | Ctrl + J                 | 显示/隐藏控制台                               |                      |\n| **Cmd + Shift + N**  | **Ctrl + Shift + N**     | 重新开一个软件的窗口                          | 很常用               |\n| Cmd + Shift + W      | Ctrl + Shift + W         | 关闭软件的当前窗口                            |                      |\n| Cmd + N              | Ctrl + N                 | 新建文件                                      |                      |\n| Cmd + W              | Ctrl + W                 | 关闭当前文件                                  |                      |\n\n### 2、跳转操作\n\n| Mac 快捷键                    | Win 快捷键             | 作用                                                   | 备注               |\n| :---------------------------- | :--------------------- | :----------------------------------------------------- | :----------------- |\n| Cmd + `                       | 没有                   | 在同一个软件的**多个工作区**之间切换                   | 使用很频繁         |\n| **Cmd + Option + 左右方向键** | Ctrl + Pagedown/Pageup | 在已经打开的**多个文件**之间进行切换                   | 非常实用           |\n| Ctrl + Tab                    | Ctrl + Tab             | 在已经打开的多个文件之间进行跳转                       | 不如上面的快捷键快 |\n| Cmd + Shift + O               | Ctrl + shift + O       | 在当前文件的各种**方法之间**（符号：Symbol）进行跳转   |                    |\n| Cmd + T                       | Ctrl + T               | 在当前**工作区**的各种方法之间（符号：Symbol）进行跳转 |                    |\n| Ctrl + G                      | Ctrl + G               | 跳转到指定行                                           |                    |\n| `Cmd+Shift+\\`                 | `Ctrl+Shift+\\`         | 跳转到匹配的括号                                       |                    |\n\n### 3、移动光标\n\n| Mac 快捷键                    | Win 快捷键                                 | 作用                                                         | 备注           |\n| :---------------------------- | :----------------------------------------- | :----------------------------------------------------------- | :------------- |\n| 方向键                        | 方向键                                     | 在**单个字符**之间移动光标                                   | 大家都知道     |\n| **option + 左右方向键**       | **Ctrl + 左右方向键**                      | 在**单词**之间移动光标                                       | 很常用         |\n| **Cmd + 左右方向键**          | **Fn + 左右方向键**（或 Win + 左右方向键） | 将光标定位到当前行的最左侧、最右侧（在**整行**之间移动光标） | 很常用         |\n| **Option + Alt + 左右方向键** | **Alt + Shift + 左右方向键**               | 左右扩大/缩小选中的范围                                      | 很酷，极为高效 |\n| Cmd + ↑                       | Ctrl + Home                                | 将光标定位到文件的第一行                                     |                |\n| Cmd + ↓                       | Ctrl + End                                 | 将光标定位到文件的最后一行                                   |                |\n| Cmd + Shift + \\               |                                            | 在**代码块**之间移动光标                                     |                |\n\n### 4、编辑操作\n\n| Mac 快捷键             | Win 快捷键          | 作用                                 | 备注                                   |\n| :--------------------- | :------------------ | :----------------------------------- | :------------------------------------- |\n| Cmd + C                | Ctrl + C            | 复制                                 |                                        |\n| Cmd + X                | Ctrl + X            | 剪切                                 |                                        |\n| Cmd + V                | Ctrl + V            | 粘贴                                 |                                        |\n| **Cmd + Enter**        | **Ctrl + Enter**    | 在当前行的下方新增一行，然后跳至该行 | 即使光标不在行尾，也能快速向下插入一行 |\n| Cmd+Shift+Enter        | Ctrl+Shift+Enter    | 在当前行的上方新增一行，然后跳至该行 | 即使光标不在行尾，也能快速向上插入一行 |\n| **Option + ↑**         | **Alt + ↑**         | 将代码向上移动                       | 很常用                                 |\n| **Option + ↓**         | **Alt + ↓**         | 将代码向下移动                       | 很常用                                 |\n| Option + Shift + ↑     | Alt + Shift + ↑     | 将代码向上复制一行                   |                                        |\n| **Option + Shift + ↓** | **Alt + Shift + ↓** | 将代码向下复制一行                   | 写重复代码的利器                       |\n\n另外再补充一点：将光标点击到某一行的任意位置时，默认就已经是**选中全行**了，此时可以直接**复制**或**剪切**，无需点击鼠标。这个非常实用，是所有的编辑操作中，使用得最频繁的。它可以有以下使用场景：\n\n- 场景1：假设光标现在处于第5行的**任意位置**，那么，直接依次按下 `Cmd + C` 和 `Cmd + V`，就会把这行代码复制到第6行。继续按 `Cmd + C` 和 `Cmd + V`，就会把这行代码复制到第7行。copy代码so easy。\n- 场景2：假设光标现在处于第5行，那么，先按下 `Cmd + C`，然后按两下 `↑` 方向键，此时光标处于第3行；紧接着，继续按下 `Cmd + V`，就会把刚刚那行代码复制到第3行，原本处于第3行的代码会整体**下移**。\n\n你看到了没？上面的两个场景，我全程没有使用鼠标，只通过简单的复制粘贴和方向键，就做到了如此迅速的copy代码。你说是不是很高效？\n\n### 5、删除操作\n\n| Mac 快捷键             | Win 快捷键           | 作用                   | 备注                                      |\n| :--------------------- | :------------------- | :--------------------- | :---------------------------------------- |\n| Cmd + shift + K        | Ctrl + Shift + K     | 删除整行               | 「Cmd + X」的作用是剪切，但也可以删除整行 |\n| **option + Backspace** | **Ctrl + Backspace** | 删除光标之前的一个单词 | 英文有效，很常用                          |\n| option + delete        | Ctrl + delete        | 删除光标之后的一个单词 |                                           |\n| **Cmd + Backspace**    |                      | 删除光标之前的整行内容 | 很常用                                    |\n| Cmd + delete           |                      | 删除光标之后的整行内容 |                                           |\n\n备注：上面所讲到的移动光标、编辑操作、删除操作的快捷键，在其他编辑器里，大部分都适用。\n\n### 6、多光标选择/多光标编辑\n\n多光标选择在编程的**提效**方面可谓立下了汗马功劳。因为比较难记住，所以你要时不时回来复习这一段。\n\n| Mac 快捷键                        | Win 快捷键                     | 作用                                                                                                                | 备注                                     |\n| --------------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------- | ---------------------------------------- |\n| **Option + 鼠标连续点击任意位置** | **Alt + 鼠标连续点击任意位置** | 在任意位置，同时出现多个光标                                                                                        | 很容易记住                               |\n| Cmd + D                           | Ctrl + D                       | 将光标放在某个单词的位置（或者先选中某个单词），然后反复按下「**Cmd + D** 」键， 即可将下一个相同的词逐一加入选择。 | 较常用                                   |\n| **Cmd + Shift + L**               | **Ctrl + Shift + L**           | 将光标放在某个单词的位置（或者先选中某个单词），然后按下快捷键，则所有的相同内容处，都会出现光标。                  | 很常用。比如变量重命名的时候，就经常用到 |\n\n### 7、多列选择/多列编辑\n\n多列选择是更高效的多光标选择，所以单独列成一小段。\n\n| Mac 快捷键                | Win 快捷键             | 作用                                                                                   | 备注                 |\n| ------------------------- | ---------------------- | -------------------------------------------------------------------------------------- | -------------------- |\n| Cmd + Option + 上下键     | Ctrl + Alt + 上下键    | 在连续的多列上，同时出现多个光标                                                       | 较常用               |\n| Option + Shift + 鼠标拖动 | Alt + Shift + 鼠标拖动 | 按住快捷键，然后把鼠标从区域的左上角拖至右下角，即可在选中区域的每一行末尾，出现光标。 | 很神奇的操作，较常用 |\n| **Option + Shift + i**    | **Alt + Shift + I**    | 选中一堆文本后，按下快捷键，既可在**每一行的末尾**都出现一个光标。                     | 很常用               |\n\n### 8、编程语言相关\n\n| Mac 快捷键             | Win 快捷键      | 作用                         | 备注                             |\n| :--------------------- | :-------------- | :--------------------------- | :------------------------------- |\n| Cmd + /                | Ctrl + /        | 添加单行注释                 | 很常用                           |\n| **Option + Shift + F** | Alt + shift + F | 代码格式化                   | 很常用                           |\n| F2                     | F2              | 以重构的方式进行**重命名**   | 改代码备                         |\n| Ctrl + J               |                 | 将多行代码合并为一行         | Win 用户可在命令面板搜索”合并行“ |\n| Cmd +                  |                 |                              |                                  |\n| Cmd + U                | Ctrl + U        | 将光标的移动回退到上一个位置 | 撤销光标的移动和选择             |\n\n### 9、搜索相关\n\n| Mac 快捷键          | Win 快捷键          | 作用                                       | 备注   |\n| :------------------ | :------------------ | :----------------------------------------- | :----- |\n| **Cmd + Shift + F** | **Ctrl + Shift +F** | 全局搜索代码                               | 很常用 |\n| **Cmd + P**         | **Ctrl + P**        | 在当前的项目工程里，**全局**搜索文件名     |        |\n| Cmd + F             | Ctrl + F            | 在当前文件中搜索代码，光标在搜索框里       |        |\n| **Cmd + G**         | **F3**              | 在当前文件中搜索代码，光标仍停留在编辑器里 | 很巧妙 |\n\n### 10、自定义快捷键\n\n按住快捷键「Cmd + Shift + P」，弹出命令面板，在命令面板中输入“快捷键”，可以进入快捷键的设置。\n\n当然，你也可以选择菜单栏「偏好设置 --> 键盘快捷方式」，进入快捷键的设置：\n\n![](http://img.smyhvae.com/20190329_2120.png)\n\n此外，如果你输入这个快捷键后没起作用，那有可能是与其他软件（比如 PicGo 软件）的快捷键冲突了，请检查一下。\n\n### 11、快捷键列表\n\n你可以点击 VS Code 左下角的齿轮按钮，效果如下：\n\n![](http://img.smyhvae.com/20190418_1738.png)\n\n上图中，在展开的菜单中选择「键盘快捷方式」，就可以查看和修改所有的快捷键列表了：\n\n![](http://img.smyhvae.com/20190418_1739_2.png)\n\n### 快捷键参考表（官方）\n\nVS Code官网提供了 PDF版本的键盘快捷键参考表，转需：\n\n- Windows版本：https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf\n- Mac 版本：https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf\n- Linux版本：https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf\n\n我们在 VS Code软件里通过菜单栏「帮助-->键盘快捷方式参考」也可以打开相应平台的快捷键大全（PDF版本）。\n\n## 三、高端访问：命令面板的使用\n\nMac 用户按住快捷键 `Cmd+Shift+P` （Windows 用户按住快捷键 `Ctrl+Shift+P`），可以打开快速命令面板。效果如下：\n\n![](http://img.smyhvae.com/20190329_1750_2.png)\n\n命令面板的作用是**希望解放开发者的鼠标，让一些操作和配置可以直接通过键盘进行**。如果让开发者记住所有的配置项在菜单的哪个位置是不现实的，而且有些命令并不在菜单中。\n\n有了命令面板之后，如果你需要修改一些设置项，或者进行一些快捷操作，则可以通过「命令面板」来操作，效率会更高。接下来列举一些。\n\n### 1、VS Code 设置为中文语言\n\nMac 用户按住快捷键 `Cmd+Shift+P` （Windows 用户按住快捷键 `Ctrl+Shift+P`），打开命令面板。\n\n在命令面板中，输入 `Configure Display Language`，选择 `Install additional languages`，然后安装插件 `Chinese (Simplified) Language Pack for Visual Studio Code`即可。\n\n或者，我们可以直接安装插件 `Chinese (Simplified) Language Pack for Visual Studio Code`，是一样的。\n\n安装完成后，重启 VS Code。\n\n### 2、设置字体大小\n\n在命令面板输入“字体”，可以进行字体的设置，效果如下：\n\n![](http://img.smyhvae.com/20190329_2110.png)\n\n当然，你也可以在菜单栏，选择「首选项-设置-常用设置」，在这个设置项里修改字体大小。\n\n### 3、快捷键设置\n\n在命令面板输入“快捷键”，就可以进入快捷键的设置。\n\n### 4、大小写转换\n\n选中文本后，在命令面板中输入 `transfrom`，就可以修改文本的大小写了。\n\n![](http://img.smyhvae.com/20190414_1751.png)\n\n### 5、使用命令行启动 VS Code\n\n（1）输入快捷键「Cmd + Shift + P 」，选择 `install code command`：\n\n![](http://img.smyhvae.com/20191103_1327.png)\n\n（2）使用命令行：\n\n- `code`命令：启动 VS Code 软件\n- `code pathName/fileName`命令：通过 VS Code 软件打开指定目录/指定文件。\n\n备注：这种方法快捷简单，但是在电脑重启之后就失效了。稍后在第五段，我会介绍更常见的方法。\n\n### 6、修改特定编程语言的设置项\n\n输入快捷键「Cmd + Shift + P 」打开命令面板，然后输入并执行 `Configure Language Specific Settings`即可。\n\n![](https://img.smyhvae.com/20211012_1039.png)\n\n## 四、私人订制：VS Code 的常见配置\n\n### 0、设置项介绍\n\n在修改 VS Code配置之前，我们需要知道，在哪里可以找到设置项的入口。\n\n**方式1**：Mac用户选择菜单栏「Code--> 首选项-->设置」，即可打开配置项：\n\n![](http://img.smyhvae.com/20210930_2009.png)\n\n**方式2**：点击软件右下角的设置图标：\n\n![](http://img.smyhvae.com/20210930_2016.png)\n\n![](https://img.smyhvae.com/20211012_1017.png)\n\n如上图所示，VS Code提供两种不同范围的设置：\n\n- **用户**设置：全局生效。\n- **工作区**设置：只针对当前项目生效。工作区设置会覆盖用户设置。适用于团队协作场景。工作区的设置文件是保存在当前项目根目录的 `.vscode/settings.json`中，可以被提交到Git仓库，方便共享给项目组的其他成员。\n\n操作技巧：\n\n（1）我们可以在设置面板的顶部搜索框，输入关键词，就能迅速定位到你想要的设置项。\n\n（2）上图中，点击右上角的icon，可以通过 json文件的形式修改设置项。\n\n### 1、修改主题\n\n1）修改颜色主题：\n\n选择菜单栏「Code --> 首选项 --> 颜色主题」：\n\n![](http://img.smyhvae.com/20210930_2017.png)\n\n在弹出的对话框中，挑选你一个你喜欢的的颜色主题吧，或者安装其他颜色的主题：\n\n![20211013_1018](http://img.smyhvae.com/20211013_1018.png)\n\n或者在设置项里搜索 `Workbench: Color Theme`，进行修改。\n\n2）修改文件图标的主题：\n\n选择菜单栏「Code --> 首选项 --> 文件图标主题」：\n\n![20211013_1015](http://img.smyhvae.com/20211013_1015.png)\n\n在弹出的对话框中，挑选你一个你喜欢的的主题吧，或者安装其他的主题：\n\n![20211013_1019](http://img.smyhvae.com/20211013_1019.png)\n\n或者在设置项里搜索 `Workbench: Icon Theme`，进行修改。\n\n### 2、面包屑（Breadcrumb）导航\n\n打开 VS Code 的设置项，选择「用户设置 -> 工作台 -> 导航路径」，如下图所示：\n\n![](http://img.smyhvae.com/20191108_1550.png)\n\n上图中，将红框部分打钩即可。\n\n设置成功后，我们就可以查看到当前文件的「层级结构」，非常方便。如下图所示：\n\n![](http://img.smyhvae.com/20190415_2009.png)\n\n有了这个面包屑导航，我们可以点击它，在任意目录、任意文件之间随意跳转。使用频繁非常高。\n\n### 3、是否显示代码的行号\n\nVS Code 默认显示代码的行号。你可以在设置项里搜索 `editor.lineNumbers`修改设置，配置项如下：\n\n![](http://img.smyhvae.com/20190417_2140.png)\n\n我建议保留这个设置项，无需修改。\n\n### 4、右侧是否显示代码的缩略图\n\n如果某个文件的代码量很大，缩略图就很有用了，可以预览全局，并在当前文件中快速跳转。\n\nVS Code 会在代码的右侧，默认显示缩略图。你可以在设置项里搜索 `editor.minimap` 进行设置，配置项如下：\n\n![](http://img.smyhvae.com/20211012_1507.png)\n\n上面这张图，你仔细琢磨下会发现，中文翻译十分精准。\n\n### 5、将当前行代码高亮显示（更改光标所在行的背景色）\n\n当我们把光标放在某一行时，这一行的背景色并没有发生变化。如果想**高亮显示**当前行的代码，需要设置两步：\n\n（1）在设置项里搜索 `editor.renderLineHighlight`，将选项值设置为 `all`或者 `line`。\n\n（2）在设置项里增加如下内容：\n\n```json\n\"workbench.colorCustomizations\": {\n    \"editor.lineHighlightBackground\": \"#00000090\",\n    \"editor.lineHighlightBorder\": \"#ffffff30\"\n}\n```\n\n上方代码，第一行代码的意思是：修改光标所在行的背景色（背景色设置为全黑，不透明度 90%）；第二行代码的意思是：修改光标所在行的边框色。\n\n### 6、改完代码后立即自动保存\n\n**方式一**：\n\n改完代码后，默认不会自动保存。你可以在设置项里搜索 `files.autoSave`，修改参数值为 `afterDelay` ，即可自动保存。如下：\n\n![](https://img.smyhvae.com/20211012_2000.png)\n\nfiles.autoSave的参数值有以下几种：\n\n- off（默认值）：不自动保存。\n- afterDelay（建议配置）：文件修改超过一定时间（默认1秒）后，就自动保存。\n- onFocusChange：当前编辑器失去焦点时，则自动保存。如果我们将配置项修改为 `onFocusChange`之后，那么，当光标离开该文件后，这个文件就会自动保存了。\n- onWindowChange：VS Code软件失去焦点时，则自动保存。\n\n**方式二**：\n\n当然，你也可以直接在菜单栏选择「文件-自动保存」。勾选后，当你写完代码后，文件会立即实时保存。\n\n### 7、热退出\n\n当VS Code退出后，它可以记住未保存的文件。如果你希望达到这种效果，那么，你需要先将设置项 `files.hotExit`的值改为 `onExitAndWindowClose`。这个配置项要不要改，看你个人需要。比如我自己平时设置的值是 `onExit`。\n\n![20211012_2014](http://img.smyhvae.com/20211012_2014.png)\n\n### 8、保存代码后，是否立即格式化\n\n保存代码后，默认**不会立即**进行代码的格式化。你可以在设置项里搜索 `editor.formatOnSave`查看该配置项：\n\n![](http://img.smyhvae.com/20190417_2213.png)\n\n我觉得这个配置项保持默认就好，不用打钩。\n\n### 9、自动格式化粘贴的内容\n\n在设置项里搜索 `editor.formatOnPaste`，将设置项改为 `true`：\n\n![20211012_1049](https://img.smyhvae.com/20211012_1049.png)\n\n### 10、设置字体大小\n\n在设置项里搜索 `fontSize`，然后根据需要设置各种模块的字体大小：\n\n![20211012_1053](http://img.smyhvae.com/20211012_1053.png)\n\n### 11、空格 or 制表符\n\nVS Code 会根据你所打开的文件来决定该使用空格还是制表。也就是说，如果你的项目中使用的都是制表符，那么，当你在写新的代码时，按下 tab 键后，编辑器就会识别成制表符。\n\n（1）建议的设置项如下：\n\n- **editor.detectIndentation**：自动检测（默认开启）。建议把这个配置项修改为 false，截图如下：\n\n![20211012_1139](https://img.smyhvae.com/20211012_1139.png)\n\n这样做，是为了取消系统的自动缩进，建议自己手动格式化比较好。 参考链接：https://www.yisu.com/zixun/327399.html\n\n- **editor.insertSpaces**：按 Tab 键时插入空格（默认值为true）。截图如下：\n\n![](http://img.smyhvae.com/20190417_2207.png)\n\n- **editor.tabSize**：一个制表符默认等于四个空格。截图如下：\n\n![](http://img.smyhvae.com/20190417_2209.png)\n\n（2）状态栏也会显示当前的缩进值。点击状态栏，可以直接修改 tabSize 缩进值：\n\n![](http://img.smyhvae.com/20211009_1610.png)\n\n（3）另外，我们还可以安装 prettier 插件，设置代码在格式化时默认缩进值。prettier 是做代码格式化的最常见工具。\n\n![](https://img.smyhvae.com/20211009_1637.png)\n\n（4）去掉每一行末尾的空格。在设置项里搜索 `空格`或者 `\"files.trimTrailingWhitespace\"`，将值设置为 true：\n\n![20211012_1231](http://img.smyhvae.com/20211012_1231.png)\n\n一般来说，每一行代码末尾的空格是多余的，所以建议去掉。\n\n### 12、直观地显示代码里的空格和缩进 ✨\n\n代码里如果有缩进或者空格，肉眼是看不出来的，但是我们可以修改配置项，把它揪出来。\n\n在配置项里搜索 `editor.renderWhitespace`，修改为 `all`：\n\n![20211012_1150](http://img.smyhvae.com/20211012_1150.png)\n\n修改之后，代码里的空格、缩进的展示效果如下：\n\n![20211012_1258](http://img.smyhvae.com/20211012_1258.png)\n\n看到了没？哪里有空格、哪里是缩进，全都一目了然。\n\n### 13、新建文件后的默认文件类型\n\n当我们按下快捷键「Cmd + N」新建文件时，VS Code 默认无法识别这个文件到底是什么类型的，因此也就无法识别相应的语法高亮。\n\n如果你想修改默认的文件类型，可以在设置项里搜索 `files.defaultLanguage`，设置项如下：\n\n![](http://img.smyhvae.com/20190417_2221.png)\n\n上图中的红框部分，填入你期望的默认文件类型。我填的是 `html`类型，你也可以填写成 `javascript` 或者 `markdown`，或者其他的语言类型。\n\n### 14、删除文件时，是否弹出确认框\n\n当我们在 VS Code 中删除文件时，默认会弹出确认框。如果你想修改设置，可以在设置项里搜索 `xplorer.confirmDelete`。截图如下：\n\n![](http://img.smyhvae.com/20190418_1758.png)\n\n我建议这个设置项保持默认的打钩就好，不用修改。删除文件前的弹窗提示，也是为了安全考虑，万一手贱不小心删了呢？\n\n### 15、在新窗口打开文件/文件夹\n\n通过 `window.openFoldersInNewWindow`（默认值为off）和 `window.openFilesInNewWindow`（默认值为default），可以配置在打开文件夹、打开文件时，是否开启一个新的窗口。我个人建议，把这两个配置项都设置为 on，避免旧的窗口被覆盖：\n\n![](http://img.smyhvae.com/20211012_1700.png)\n\n补充知识—— `window.restoreWindows`可以用来配置 如何恢复之前的会话窗口。涉及到的场景是：你把 VS Code 关闭了，然后又打开了，是否要展示之前打开过的文件、文件夹？参数值有以下几种：\n\n- one（默认配置）：只会重新打开上一次回话中最后操作的那一个窗口。\n- none：打开一个空的窗口，不包含任何文件、文件夹。\n- all（建议配置）：恢复上一次会话中的所有窗口。\n- folders：恢复上一次会话中包含文件夹的窗口。\n\n![20211012_1704](http://img.smyhvae.com/20211012_1704.png)\n\n### 16、自动删除行尾的空格\n\n打开设置项，搜索 `files.trimTrailingWhitespace`，将选项勾选，即可在保存文件时自动删除行尾的空格。\n\n### 17、突出显示成对的括号\n\n我们可以用不同颜色显示代码中成对的括号，并用连线标注括号范围。简称**彩虹括号**。\n\n最早是通过 `Bracket Pair Colorizer 2`插件支持的，但是这个插件已经被废弃了，因为 VS Code 已经内置了该功能。我们可以通过 VS Code的如下配置项，达到效果：\n\n```json\n{\n  \"editor.bracketPairColorization.enabled\": true,\n  \"editor.guides.bracketPairs\": \"active\"\n}\n```\n\n### 18、自动换行\n\n自动换行：意味着当文本到达屏幕或页面的右边缘时，自动换行会将文本移到下一行，以便继续输入或显示。\n\n打开设置项，搜索 `Editor:Word Wrap`，将选项值设置为 on。\n\n此外，你还可以选择菜单栏 `查看-->自动换行`，即可将当前文件设置为自动换行。\n\n> 接下来，我们来讲一些更高级的操作。\n\n## 五、纵享丝滑：常见操作和使用技巧\n\n### 1、快速生成HTML骨架\n\n先新建一个空的html文件，然后通过以下方式，可以快速生成html骨架。\n\n**方式1**：输入 `!`，然后按下 `enter`键，即可生成html骨架。如下图：\n\n![](https://img.smyhvae.com/20210623-2115.gif)\n\n**方式2**：输入 `html:5`，然后按住 `Tab`键，即可生成html骨架。\n\n生成的骨架，内容如下：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n```\n\n有了上面的html骨架之后，我们就可以快乐地在里面插入CSS 代码和 JS 代码。\n\n### 2、并排编辑：左右（上下）显示多个编辑器窗口（copy代码利器）\n\n> 并排编辑是所有的编辑操作中最常用的一个技巧，十分有用。比如我们在开发一个项目时，可能需要同时打开 HTML 文件和 CSS 文件，很常见。\n\nMac 用户按住快捷键 `Cmd + \\`， Windows 用户按住快捷键 `Ctrl + \\`，即可同时打开多个编辑器窗口，进行并排编辑。效果如下：\n\n![](http://img.smyhvae.com/20200619_0030.gif)\n\n按快捷键「Cmd + 1 」切换到左边的窗口，按快捷键「Cmd + 2 」切换到右边的窗口，以此类推。随时随地，想切就切。\n\n学会了这一招，以后 copy 代码的时候，leader 再也不用担心我抄得慢了，一天工资到手。\n\n---\n\n当然，使用快捷键 `Cmd + \\`只是其中一种方式，我们还有很多种方式打开并行编辑。我们来做一个汇总。\n\n如果你已经打开了一个编辑器，那么可以通过以下几种方式在另一侧打开另一个编辑器：（按照使用频率，从高到低排序）\n\n- 使用快捷键 `Cmd + \\`将编辑器一分为二。\n- 使用快捷键 `Cmd + P`调出文件列表，选择要打开的文件，然后按下 `Cmd + Enter`快捷键。【重要】\n- 按住 Option 键的同时，单击资源管理器的文件（Windows 用户是按 Alt 键）。\n- 点击编辑器右上角的 `Split Editor`按钮。\n- 选择菜单栏「查看--> 编辑器布局」，然后选择你具体想要的布局，如下图所示：\n\n![20211012_1451](http://img.smyhvae.com/20211012_1451.png)\n\n- 通过拖拽，把当前文件移动到任意一侧。\n\n补充知识：通过配置项 `worbench.editor.OpenSideBySideDirection`可以控制编辑器在并排打开时出现的默认位置（默认值为right，你也可以根据需要改为 down）。如下图所示：\n\n![20211012_1455](http://img.smyhvae.com/20211012_1455.png)\n\n### 3、从终端 code 命令启动 VS Code（Mac电脑）\n\n在终端输入 `code`或者输入 `code + 指定项目的目录`，就可以启动 VS Code，十分便捷。即：\n\n- `code` 命令：启动 VS Code 软件。\n- `code pathName/fileName` 命令：通过 VS Code 软件打开指定目录/指定文件。\n\n为了达到目的，我们需要先将 VS Code的软件安装路径添加到环境变量，一劳永逸。具体操作如下：\n\n（1）打开 `bash_profile`文件：\n\n```bash\ncd ~\nvim ./bash_profile\n```\n\n（2）在 bash_profile 中添加如下内容：\n\n```bash\n# 从终端启动VS Code，并设置vscode启动的命令别名\nalias code=\"/Applications/Visual\\ Studio\\ Code.app/Contents/Resources/app/bin/code\"\n```\n\n注意，由于 `Visual Studio Code.app`这个路径里有空格，所以需要在空格前面加上反斜杠 `\\`。\n\n（3）重启环境变量的配置：\n\n```\n# 重启\nsource ~/.bash_profile\n```\n\n大功告成。\n\n改完之后，如果没生效，那你把 `bash_profile`文件 换成 `zshrc`文件试试。\n\n参考链接：\n\n- [mac通过终端code 命令打开vscode](https://blog.csdn.net/logan_LG/article/details/106800904)\n\n当然，还可以通过命令面板，一键设置环境变量。具体做法是：输入快捷键「Cmd + shift + P」打开命令面板，然后选择 `shell 命令：从 PATH 中卸载 “code”命令`：\n\n![](https://img.smyhvae.com/202310201605408.png)\n\n完成后就可以在终端输入命令+文件路径来启动 VS Code 了。\n\n### 3、从终端 code 命令启动 VS Code（Windows电脑）\n\n在终端输入 `code`或者输入 `code + 指定项目的目录`，就可以启动 VS Code，十分便捷。即：\n\n- `code` 命令：启动 VS Code 软件。\n- `code pathName/fileName` 命令：通过 VS Code 软件打开指定目录/指定文件。\n\n为了达到目的，我们需要先将 VS Code的软件安装路径添加到环境变量，一劳永逸。具体操作如下：\n\n（1）打开 VS Code 的安装位置，进入bin文件夹，复制路径。比如：`D:\\Microsoft VS Code\\bin`。\n\n（2）回到桌面，右键我的电脑-->高级系统设置-->环境变量-->编辑path值，在原来的path后面，追加内容 `;D:\\Microsoft VS Code\\bin`（即英文的分号+VS Code 的 bin 路径)\n\n（3）重启电脑，大功告成。\n\n改完之后，如果没生效，那八成是因为你填的 path 值有问题。\n\n参考链接：\n\n- [windows使用 code . 命令打开vscode](https://www.cnblogs.com/zyl-Tara/p/10642704.html)\n\n### 4、在当前文件中搜索\n\n在上面的快捷键列表中，我们已经知道如下快捷键：\n\n- Cmd + F（Win 用户是 Ctrl + F）：在当前文件中搜索，光标在搜索框里\n- Cmd + G（Win 用户是 F3）：在当前文件中搜索，光标仍停留在编辑器里\n\n多个搜索结果出来之后，按下 Enter 键之后跳转到下一个搜索结果，按下 Shift + Enter 键之后跳转到上一个搜索结果。\n\n另外，你可能会注意到，搜索框里有很多按钮，每个按钮都对应着不同的功能，如下图所示：\n\n![](http://img.smyhvae.com/20190415_2052.png)\n\n上图中，你可以通过「Tab」键和「Shift + Tab」键在输入框和替换框之间进行切换。\n\n「在选定内容中查找」这个功能还是比较实用的。你也可以在设置项里搜索 `editor.find.autoFindInSelection`，勾选该设置项后，那么，当你选中指定内容后，然后按住「Cmd + F」，就可以**自动**只在这些内容里进行查找。该设置项如下图所示：\n\n![](http://img.smyhvae.com/20191108_1655.png)\n\n### 5、全局搜索\n\n在上面的快捷键列表中，我们已经知道如下快捷键：\n\n- Cmd + Shift + F（Win 用户是 Ctrl + Shift +F）：在全局的文件夹中进行搜索。效果如下：\n\n![20211012_1548](http://img.smyhvae.com/20211012_1548.png)\n\n上图中，你可以点击**红框**部分，展开更多的配置项。然后点击**红圈**部分，进行过滤搜索。注意，第二个红圈那里会经常用到，它可以在搜索时过滤掉 `.git`、`.node_modules`等忽略文件。\n\n上图中，我们还可以点击“在编辑器中打开”，在一个单独的文件中聚合展示搜索结果：\n\n![](https://img.smyhvae.com/20211012_1609.png)\n\n### 6、文件名/文件夹的搜索\n\n前面的快捷键那一段我们讲过，通过 「Cmd + P」可以快速搜索并打开**文件**/文件夹。这种方式，一般用于快速打开最近编辑过的文件。\n\n其实还有一种很巧妙的方式，可以在整个项目里，既能搜到文件，也能搜到**文件夹**。这种方式，常用于**过滤项目的目录**。操作方法很简单：\n\n> 直接在文件资源管理器输入关键字就行。搜索结果会自动出现；使用方向键进行上下移动，可以在搜索的文件和文件夹之间进行跳转。\n>\n> 另外，右上角会看到一个过滤器，点击下图中的红圈部分，则只显示匹配的文件和文件夹。\n\n![20211012_1616](http://img.smyhvae.com/20211012_1616.png)\n\n当然，这招也有一点不足：不能搜中文。\n\n### 7、大纲视图\n\n如下图所示，大纲视图可以展示当前代码的方法结构、文件的目录结构：\n\n![20211012_1628](http://img.smyhvae.com/20211012_1628.png)\n\n![20211012_1636](http://img.smyhvae.com/20211012_1636.png)\n\n### 8、文件对比\n\nVS Code 默认支持**对比两个文件的内容**。选中两个文件，然后右键选择「将已选项进行比较」即可，效果如下：\n\n![](http://img.smyhvae.com/20190329_1756.png)\n\nVS Code 自带的对比功能并不够强大，我们可以安装插件 `compareit`，进行更丰富的对比。比如说，安装完插件 `compareit`之后，我们可以将「当前文件」与「剪切板」里的内容进行对比：\n\n![](http://img.smyhvae.com/20190329_1757.png)\n\n如果你安装了 GitLens 插件，还可以将两个git分支的代码进行比对，非常完美。\n\n### 9、查找某个函数在哪些地方被调用了\n\n比如我已经在 `a.js`文件里调用了 `foo()`函数。那么，如果我想知道 `foo()`函数在其他文件中是否也被调用了，该怎么做呢？\n\n做法如下：在 `a.js` 文件里，选中 `foo()`函数（或者将光标放置在 `foo()`函数上），然后按住快捷键「Shift + F12」，就能看到 `foo()`函数在哪些地方被调用了，比较实用。\n\n### 10、鼠标操作\n\n- 在当前行的位置，鼠标三击，可以选中当前行。\n- 用鼠标单击文件的**行号**，可以选中当前行。\n- 在某个**行号**的位置，**上下移动鼠标，可以选中多行**。\n\n### 11、重构\n\n重构分很多种，我们来举几个例子。\n\n**命名重构**：\n\n当我们尝试去修改某个函数（或者变量名）时，我们可以把光标放在上面，然后按下「F2」键，那么，这个函数（或者变量名）出现的地方都会被修改。\n\n**方法重构**：\n\n选中某一段代码，这个时候，代码的左侧会出现一个「灯泡图标」，点击这个图标，就可以把这段代码提取为一个单独的函数。\n\n### 12：终端配置\n\nVS Code软件自带了终端，但我个人认为不是很好用，而且VS Code 软件关了之后，终端也没了。建议大家使用其他的终端软件，专业的事情交给专业的人做。\n\n- Windows平台的终端：推荐 PowerShell 软件。远程终端推荐 xshell 软件。\n- Mac平台的终端：推荐 [iTerm2 ](https://iterm2.com/)。 iTerm2 是Mac平台最好用的终端软件，没有之一。\n\n**右键行为**：\n\n> 在终端上，单击右键所产生的行为在不同的系统里是不同的。\n\n- Windows：如果有**选定**文本，则复制当前文本；如果没有选定文本，则粘贴。\n- macOS：选中光标所在位置的单词，并显示右键菜单。\n- Linux：显示右键菜单。\n\n### 13、Git 版本管理\n\n在 VS Code中使用Git之前，需要你先安装 Git 环境。\n\nVS Code 自带了 Git 版本管理的功能，如下图所示：\n\n![](http://img.smyhvae.com/20190418_1850.png)\n\n上图中，我们可以在这里进行常见的 git 命令操作。如果你还不熟悉 **Git 版本管理**，可以先去补补课。\n\n我自己用的最多的功能是**diff 代码**和**合并冲突**，自从用上了 VS Code 的这两个功能，简直离不开它。\n\n我们先来看看 diff 代码的效果：\n\n![20211013_1411](https://img.smyhvae.com/20211013_1411.png)\n\n上图中，点击右上角的 `...`，然后点击 `内联视图`，则可以换一种视图 diff 代码：\n\n![](https://img.smyhvae.com/20211013_1415.png)\n\n**Git状态栏**：\n\n![20211013_1421](http://img.smyhvae.com/20211013_1421.png)\n\n在VS Code的左下角会显示Git状态栏。如果当前代码仓库配置了远程仓库，那么“同步更改”会显示以下信息：\n\n- 左边的数字：表示远程分支比本地分支多了XX个 Git commit。\n- 右边的数字：表示本地分支比远程分支多了XX个 Git commit。\n\n点击“同步更改”按钮，会拉取（pull）远程分支到本地分支，并推送（push）本地的Git commit到远程分支。\n\n如果当前代码仓库没有配置远程仓库，则会显示“发布更改”的按钮。点击“发布更改”按钮，会把当前分支push到远程仓库。\n\n---\n\n另外，我建议安装插件 `GitLens`搭配使用，它是 VS Code 中我最推荐的一个插件，简直是 Git 神器，码农必备。\n\n我还要补充一句：\n\n有人说，高手都是直接用命令行操作Git。然而，根据我多年的经验来看，如果你的代码仓库需要管理的分支特别多，与团队的其他成员需要经常协作，那么，我建议你**优先使用** GUI 图形化工具来操作Git，避免出错。\n\n我推荐的GUI版的Git工具有：\n\n- [Tower](https://www.git-tower.com/)\n- [Sourcetree](https://www.sourcetreeapp.com/)\n- [GitKraken](https://www.gitkraken.com/)\n\n### 14、将工作区放大/缩小\n\n我们在上面的设置项里修改字体大小后，仅仅只是修改了代码的字体大小。\n\n如果你想要缩放整个工作区（包括代码的字体、左侧导航栏的字体等），可以按下快捷键「**cmd +/-**」。windows 用户是按下「ctrl +/-」\n\n**当我们在投影仪上给别人演示代码的时候，这一招十分管用**。\n\n如果你想恢复默认的工作区大小，可以在命令面板输入 `重置缩放`（英文是 `reset zoom`）\n\nf### 11、创建多层子文件夹\n\n我们可以在新建文件夹的时候，如果直接输入 `aa/bb/cc`，比如：\n\n![](http://img.smyhvae.com/20190418_2022.png)\n\n那么，就可以创建多层子文件夹，效果如下：\n\n![](http://img.smyhvae.com/20190418_2023.png)\n\n### 15、`.vscode` 文件夹的作用\n\n为了统一团队的 vscode 配置，我们可以在项目的根目录下建立 `.vscode`目录，在里面放置一些配置内容，比如：\n\n- `settings.json`：工作空间设置、代码格式化配置、插件配置。\n- `sftp.json`：ftp 文件传输的配置。\n\n`.vscode`目录里的配置只针对当前项目范围内生效。将 `.vscode`提交到代码仓库，大家统一配置时，会非常方便。\n\n### 16、自带终端\n\n我们可以按下「Ctrl + `」打开 VS Code 自带的终端。我认为内置终端并没有那么好用，我更建议你使用第三方的终端 **item2**。\n\n### 17、markdown 语法支持\n\nVS Code 自带 markdown 语法高亮。也就是说，如果你是用 markdown 格式写文章，则完全可以用 VS Code 进行写作。\n\n写完 md 文件之后，你可以点击右上角的按钮进行预览，如下图所示：\n\n![](http://img.smyhvae.com/20190418_1907.png)\n\n我一般是安装「Markdown Preview Github Styling」插件，以 GitHub 风格预览 Markdown 样式。样式十分简洁美观。\n\n你也可以在控制面板输入 `Markdown: 打开预览`，直接全屏预览 markdown 文件。\n\n### 18、Emmet in VS Code\n\n`Emmet`可以极大的提高 html 和 css 的编写效率，它提供了一种非常简练的语法规则。\n\n举个例子，我们在编辑器中输入缩写代码：`ul>li*6` ，然后按下 Tab 键，即可得到如下代码片段：\n\n```html\n<ul>\n  <li></li>\n  <li></li>\n  <li></li>\n  <li></li>\n  <li></li>\n  <li></li>\n</ul>\n```\n\nVS Code 默认支持 Emmet。更多 Emmet 语法规则，可以自行查阅。\n\n### 19、修改字体，使用「Fira Code」字体\n\n这款字体很漂亮，很适合用来写代码：\n\n![](https://img.smyhvae.com/20200516_1633-2.png)\n\n安装步骤如下：\n\n（1）进入 [https://github.com/tonsky/FiraCode](https://github.com/tonsky/FiraCode) 网站，下载并安装「Fira Code」字体。\n\n（2）打开 VS Code 的「设置」，搜索 `font`，修改相关配置为如下内容：\n\n```json\n\"editor.fontFamily\": \"'Fira Code',Menlo, Monaco, 'Courier New', monospace\", // 设置字体显示\n\"editor.fontLigatures\": false,//控制是否启用字体连字，true启用，false不启用\n```\n\n上方的第二行配置，取决于个人习惯，我是直接设置为 `\"editor.fontLigatures\": null`，因为我不太习惯连字。\n\n### 20、代码格式化\n\nVS Code 默认对 JavaScript、TypeScript、JSON、HTML 提供了开箱即用的代码格式化支持。其他语言则需要先安装相应的插件才能支持。\n\n另外，我们还可以安装 Prettier 插件进行**更精细**的代码格式化。下一段将插件的时候，会讲解。\n\n### 21、智能提示 IntelliSense\n\nVS Code 默认对 JavaScript、TypeScript、JSON、HTML、CSS、SCSS、Less这7种语言（文件）提供了**智能提示**的支持。其他编程语言则需要先安装相应的插件才能支持。\n\n在 VS Code插件职场中，下图是最受欢迎的8种[编程语言插件](https://marketplace.visualstudio.com/search?target=VSCode&category=Programming%20Languages&sortBy=Installs)：\n\n![20211013_1120](https://img.smyhvae.com/20211013_1120.png)\n\n智能提示的功能很强大， 包括函数介绍、代码自动补全等等。\n\n### 22、调试与运行\n\nVS Code **内置**了对 Node.js 运行时的调试支持，可以直接调试 JavaScript 和 TypeScript。其他编程语言的调试，则需要先安装相应的插件才能支持。\n\n在 VS Code插件市场中，下图是最受欢迎的几种调试插件：\n\n![](https://img.smyhvae.com/20211013_1650.png)\n\n### 23、文件传输：sftp\n\n如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器（需要先把服务端的配置搭建好），可以安装 `sftp`这个插件，很好用。在公司会经常用到。\n\n步骤如下：\n\n（1）安装插件 `sftp`。\n\n（2）配置 `sftp.json`文件。 插件安装完成后，输入快捷键「cmd+shift+P」弹出命令面板，然后输入 `sftp:config`，回车，当前工程的 `.vscode`文件夹下就会自动生成一个 `sftp.json`文件，我们需要在这个文件里配置的内容可以是：\n\n- `host`：服务器的 IP 地址\n- `username`：用户名\n- `privateKeyPath`：存放在本地的已配置好的用于登录工作站的密钥文件（也可以是 ppk 文件）\n- `remotePath`：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用 sftp 上传文件之前，要手动在工作站上 mkdir 生成这个根目录\n- `ignore`：指定在使用 sftp: sync to remote 的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号\n\n举例如下：(注意，其中的注释需要去掉)\n\n```json\n{\n  \"host\": \"192.168.xxx.xxx\", //服务器ip\n  \"port\": 22, //端口，sftp模式是22\n  \"username\": \"\", //用户名\n  \"password\": \"\", //密码\n  \"protocol\": \"sftp\", //模式\n  \"agent\": null,\n  \"privateKeyPath\": null,\n  \"passphrase\": null,\n  \"passive\": false,\n  \"interactiveAuth\": false,\n  \"remotePath\": \"/root/node/build/\", //服务器上的文件地址\n  \"context\": \"./server/build\", //本地的文件地址\n\n  \"uploadOnSave\": true, //监听保存并上传\n  \"syncMode\": \"update\",\n  \"watcher\": {\n    //监听外部文件\n    \"files\": false, //外部文件的绝对路径\n    \"autoUpload\": false,\n    \"autoDelete\": false\n  },\n  \"ignore\": [\n    //忽略项\n    \"**/.vscode/**\",\n    \"**/.git/**\",\n    \"**/.DS_Store\"\n  ]\n}\n```\n\n（3）在 VS Code 的当前文件里，选择「右键 -> upload」，就可以将本地的代码上传到 指定的 ftp 服务器上（也就是在上方 `host` 中配置的服务器 ip）。\n\n我们还可以选择「右键 -> Diff with Remote」，就可以将本地的代码和 ftp 服务器上的代码做对比，非常方便。\n\n### 24、沉浸模式/禅模式\n\n程序员写代码需要专注，有时需要进入一种心流。VS Code给我们提供了一种全屏下的沉浸模式，周围的面板都会被隐藏起来，只显示编辑器部分。\n\n操作方法：菜单栏选择「查看-外观-禅模式」即可；或者按下快捷键 `Cmd + K`，放手，再按 `Z`也可以达到目的。\n\n### 25、远程同步 VS Code 配置项\n\n北京时间的[2020年8月14日](https://zhuanlan.zhihu.com/p/184868336)，微软发布 Visual Studio Code 1.48 稳定版。此版本**原生**支持用户同步 VS Code的配置，只需要登录微软账号或者 GitHub 账号即可。\n\n有了这个功能之后，我们可以先在老电脑上登录账号，即可将软件的配置项自动开启云同步。当你下次换一个新的电脑，下载安装 VS Code，点击软件左下角的设置按钮，登录此前的微软账号或GitHub账号，即可自动将旧电脑的软件配置项，同步到新电脑的软件上。极其方便。\n\n### 26、正则表达式批量删除字符串\n\n**需求**：将文本中的字符串 `axxxxb`，批量替换为 `ab`。其中，开头字符 a 和 结尾字符 b 固定，中间xxx长度不确定。\n\n**解决**：传统查找替换无法胜任。可以使用VScode正则表达式功能，查找 `a.*?b`替换为 `ab`即可。其中 `?`是禁止贪婪匹配，否则会误删很多内容。\n\n---\n\n**拓展需求**：需求——将文本中的字符串 `axxxx`，批量替换为 `a`。其中，开头字符 a 固定，后面的xxx长度不确定。\n\n**解决**：传统查找替换无法胜任。可以使用VScode正则表达式功能，查找 `a.*?\\n`替换为 `a\\n`即可。\n\n## 六、三头六臂：VS Code 插件介绍 & 插件推荐\n\nVS Code 有一个很强大的功能就是支持插件扩展，让你的编辑器仿佛拥有了三头六臂。\n\n### 安装插件\n\n![](http://img.smyhvae.com/20191108_1553_2.png)\n\n上图中，点击红框部分，即可在顶部输入框里，查找你想要的插件名，然后进行安装。\n\n插件安装完成后，记得重启软件（或者点击插件位置的“重新加载”），插件才会生效。\n\n另外，我们还可以访问官网的插件市场来安装插件：\n\n- VS Code插件市场（官方）：https://marketplace.visualstudio.com/vscode\n\n**插件的安装目录**：\n\n- Windows：：`%USERPROFILE%\\.vscode\\extensions`\n- macOS：`~/.vscode/extensions`\n- macOS：`~/.vscode/extensions`\n\n### 插件的类型\n\n![20211013_1757_2](http://img.smyhvae.com/20211013_1757_2.png)\n\n插件市场的首页有四个模块，可以作为重要的信息来源：\n\n- Featured：由 VS Code团队精心推荐的插件。\n- Trending：近期热门插件。\n- Most Popular：按总安装量排序的插件。\n- Recently Added：最新发布的插件。\n\n![20211013_1758](http://img.smyhvae.com/20211013_1758.png)\n\n![20211013_1955](http://img.smyhvae.com/20211013_1955.png)\n\n插件市场至少有17种类型的插件：（按照数量排序）\n\n- Themes：主题插件\n- Programming Languages：编程语言插件\n- Snippets：代码片段\n- Extension Packs：插件包，里面包括多个插件\n- Formatters：代码格式化\n- Linters：静态检查\n- Debuggers：调试器\n- Keymaps：快捷键映射\n- Visualization：可视化\n- Language Packs：各国的语言插件\n- Azure：Azure 云计算\n- Data Science：数据科学\n- SCM Providers：源代码控制管理器（source control manager）\n- Notebooks\n- Education：教育\n- Testing：测试相关\n- Machine Learning：机器学习\n- Others：其他\n\n### 插件的过滤显示\n\n在 VS Code中打开插件管理视图，可以针对已安装的插件，进行过滤展示。\n\n1）点击插件视图右上角的 `...`按钮，可以展示不同状态的插件：\n\n![20211013_2011](http://img.smyhvae.com/20211013_2011.png)\n\n2）在搜索框输入字符 `@`，会展示出不同类型的过滤器：\n\n![20211013_2015](http://img.smyhvae.com/20211013_2015.png)\n\n**常见的过滤器如下**：\n\n1）按大类搜：\n\n- `@builtin`：显示 VS Code内置的插件\n- `@disabled`：显示被禁用的插件\n- `@enabled`：显示已启用的插件\n- `@installed`：显示已安装的插件\n- `@outdated`：显示待更新的插件\n\n2）精准搜索：\n\n- `@id`：按id显示插件\n- `@tag`：根据标签显示插件。\n\n3）对插件进行排序：\n\n- `@sort:installs`：根据插件的安装量排序\n- `@sourt:rating`：根据插件的评分排序\n- `@sort:name`：根据插件名字的字母顺序排序\n\n4）组合搜索：（举例）\n\n- `@installed @category:themes`：显示已安装的主题插件。\n- `@sort:installs java`：对 Java 相关的插件按照安装量排序。\n\n下面的内容，我来列举一些常见的插件，这些插件都很实用，小伙伴们可以按需安装。注意：每一类插件里，**顺序越靠前，越实用**。\n\n### 1、基本插件\n\n#### Chinese (Simplified) Language Pack for Visual Studio Code\n\n让软件显示为简体中文语言。\n\n### 2、Git 相关插件\n\n#### GitLens 【荐】\n\n我强烈建议你安装插件 `GitLens`，它是 VS Code 中我最推荐的一个插件，简直是 Git 神器，码农必备。如果你不知道，那真是 out 了。\n\nGitLens 在 Git 管理上有很多强大的功能，比如：\n\n- 将光标放置在代码的当前行，可以看到这样代码的提交者是谁，以及提交时间。这一点，是 GitLens 最便捷的功能。\n- 查看某个 commit 的代码改动记录\n- 查看不同的分支\n- 可以将两个 commit 进行代码对比\n- 甚至可以将两个 branch 分支进行整体的代码对比。这一点，简直是 GitLens 最强大的功能。当我们在不同分支 review 代码的时候，就可以用到这一招。\n\n打开你的 Git仓库，未安装 GitLens 时是这样的：\n\n![](http://img.smyhvae.com/20211009_1400.png)\n\n安装了 GitLens 之后是这样的：\n\n![](http://img.smyhvae.com/20211009_1430.png)\n\n上图中，红框部分就是 GitLens 的功能，诸君可以自由发挥。\n\n补充一个有意思的趣事：Python插件、Ruby插件、GitLens插件、Vetur插件，这四个插件的开发者先后加入了微软。\n\n#### Git History\n\n有些同学习惯使用编辑器中的 Git 管理工具，而不太喜欢要打开另外一个 Git UI 工具的同学，这一款插件满足你查询所有 Git 记录的需求。\n\n#### Local History 【荐】\n\n维护文件的本地历史记录。代码意外丢失时，有时可以救命。\n\n![](http://img.smyhvae.com/20200618_2246.png)\n\n### 3、代码智能提示插件\n\n#### Vetur\n\nVue 多功能集成插件，包括：语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger。VS Code 官方钦定 Vue 插件，Vue 开发者必备。\n\n#### ES7 React/Redux/GraphQL/React-Native snippets\n\nReact/Redux/react-router 的语法智能提示。\n\n安装该插件后，在代码中只需要输入 `clg`即可自动补全 `console.log()`这行代码。\n\n#### JavaScript(ES6) code snippets\n\nES6 语法智能提示，支持快速输入。\n\n#### javascript console utils：快速打印 log 日志【荐】\n\n安装这个插件后，当我们按住快捷键「Cmd + Shift + L」后，即可自动出现日志 `console.log()`。简直是日志党福音。\n\n当我们选中某个变量 `name`，然后按住快捷键「Cmd + Shift + L」，即可自动出现这个变量的日志 `console.log(name)`。\n\n其他的同类插件还有：Turbo Console Log。\n\n不过，生产环境的代码，还是尽量少打日志比较好，避免出现一些异常。\n\n编程有三等境界：\n\n- 第三等境界是打日志，这是最简单、便捷的方式，略显低级，一般新手或资深程序员偷懒时会用。\n- 第二等境界是断点调试，在前端、Java、PHP、iOS 开发时非常常用，通过断点调试可以很直观地跟踪代码执行逻辑、调用栈、变量等，是非常实用的技巧。\n- 第一等境界是测试驱动开发，在写代码之前先写测试。与第二等的断点调试刚好相反，大部分人不是很习惯这种方式，但在国外开发者或者敏捷爱好者看来，这是最高效的开发方式，在保证代码质量、重构等方面非常有帮助，是现代编程开发必不可少的一部分。\n\n#### Code Spell Checker：单词拼写错误检查\n\n这个拼写检查程序的目标是帮助捕获常见的单词拼写错误，可以检测驼峰命名。从此告别 Chinglish.\n\n#### Auto Close Tag、Auto Rename Tag\n\n自动闭合配对的标签、自动重命名配对的标签。\n\n### 4、代码显示增强插件\n\n#### highlight-icemode：选中相同的代码时，让高亮显示更加明显\n\nVSCode 自带的高亮显示，实在是不够显眼。可以用插件支持一下。\n\n所用了这个插件之后，VS Code 自带的高亮就可以关掉了：\n\n在用户设置里添加 `\"editor.selectionHighlight\": false`即可。\n\n参考链接：[vscode 选中后相同内容高亮插件推荐](https://blog.csdn.net/palmer_kai/article/details/79548164)\n\n#### vscode-icons\n\nvscode-icons 会根据文件的后缀名来显示不同的图标，让你更直观地知道每种文件是什么类型的。\n\n#### indent-rainbow：突出显示代码缩进\n\n`indent-rainbow`插件：突出显示代码缩进。\n\n安装完成后，效果如下图所示：\n\n![](http://img.smyhvae.com/20190418_1958.png)\n\n#### TODO Highlight\n\n写代码过程中，突然发现一个 Bug，但是又不想停下来手中的活，以免打断思路，怎么办？按照代码规范，我们一般是在代码中加个 TODO 注释。比如：（注意，一定要写成大写 `TODO`，而不是小写的 `todo`）\n\n```\n//TODO:这里有个bug，我一会儿再收拾你\n```\n\n或者：\n\n```\n//FIXME:我也不知道为啥， but it works only that way.\n```\n\n安装了插件 `TODO Highlight`之后，按住「Cmd + Shift + P」打开命令面板，输入「Todohighlist」，选择相关的命令，我们就可以看到一个 todoList 的清单。\n\n#### Better Comments\n\n为注释添加更醒目、带分类的色彩。\n\n### 5、代码格式化插件\n\n#### Prettier：代码格式化\n\nPrettier 是一个代码格式化工具，**只关注格式化，但不具备校验功能**。在一个多人协同开发的团队中，统一的代码编写规范非常重要。一套规范可以让我们编写的代码达到一致的风格，提高代码的可读性和统一性。自然维护性也会有所提高，代码的展示也会更加美观。\n\n步骤如下：\n\n（1）安装插件 `Prettier`。\n\n（2）在项目的根路径下，新建文件 `.prettierrc`，并在文件中添加如下内容：\n\n```json\n{\n  \"printWidth\": 150,\n  \"tabWidth\": 4,\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"trailingComma\": \"es5\",\n  \"tslintIntegration\": true,\n  \"insertSpaceBeforeFunctionParenthesis\": false\n}\n```\n\n上面的内容，是我自己的配置，你可以参考。更多配置，可见官方文档：[https://prettier.io/docs/en/options.html](https://prettier.io/docs/en/options.html)\n\n（3）Mac用户按快捷键「Option + Shift + F」，Win 用户按快捷键「Alt + shift + F」，即可完成代码的格式化。如果你的VS Code 设置的是自动格式化代码，那么这一步可以忽略。\n\n#### ESLint：代码格式的校验\n\n日常开发中，建议用 Prettier 做**代码格式化**，然后用 eslint 做**格式校验**。很多人把这两个插件的功能弄混了。\n\n一般做法是：格式化建议是由程序员手动触发，格式校验由系统强制校验。通过 Prettier **手动**触发格式化，是为了让用户有感知；通过eslint 做**强制**校验之后，如果代码的格式不符合要求，系统就禁止你提交代码。\n\n#### Beautify\n\n代码格式化工具。\n\n备注：相比之下，Prettier 是当前最流行的代码格式化工具，比 Beautify 用得更多。\n\n#### Paste JSON as Code\n\n此插件可以将剪贴板中的 JSON 字符串转换成工作代码。支持多种语言。\n\n#### JS-CSS-HTML Formatter【荐】\n\n保存文件时，自动格式化 HTML、CSS、JS代码。\n\n### 6、图片相关插件\n\n#### Polacode-2020：生成代码截图 【荐】\n\n可以把代码片段保存成美观的图片，主题不同，代码的配色方案也不同，也也可以自定义设置图片的边框颜色、大小、阴影。\n\n尤其是在我们做 PPT 分享时需要用到代码片段时，或者需要在网络上优雅地分享代码片段时，这一招很有用。\n\n生成的效果如下：\n\n![](http://img.smyhvae.com/20200619_1403.png)\n\n其他同类插件：`CodeSnap`。我们也可以通过 [https://carbon.now.sh/](https://carbon.now.sh/)这个网站生成代码图片\n\n有人可能会说：直接用 QQ 截图不行吗？可以是可以，但不够美观、不够干净。\n\n#### Image Preview 【荐】\n\n图片预览。鼠标移动到图片 url 上的时候，会自动显示图片的预览和图片尺寸。\n\n### 7、CSS相关插件\n\n#### CSS Peek\n\n增强 HTML 和 CSS 之间的关联，快速查看该元素上的 CSS 样式。\n\n#### Vue CSS Peek\n\nCSS Peek 对 Vue 没有支持，该插件提供了对 Vue 文件的支持。\n\n#### Color Info\n\n这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。\n\n### 8、Mardown 相关插件\n\n#### Markdown Preview Github Styling 【荐】\n\n以 GitHub 风格预览 Markdown 样式，十分简洁优雅。就像下面这样，左侧书写 Markdown 文本，右侧预览 Markdown 的渲染效果：\n\n![](http://img.smyhvae.com/20200618_2025.png)\n\n#### Markdown Preview Enhanced\n\n预览 Markdown 样式。\n\n#### Markdown All in One\n\n这个插件将帮助你更高效地在 Markdown 中编写文档。\n\n### 9、通用工具类插件\n\n#### sftp：文件传输 【荐】\n\n如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装 `sftp`这个插件，很好用。在公司会经常用到。\n\n详细配置已经在上面讲过。\n\n#### Live Server 【荐】\n\n在本地启动一个服务器，代码写完后可以实现「热更新」，实时地在网页中看到运行效果。就不需要每次都得手动刷新页面了。\n\n使用方式：安装插件后，开始写代码；代码写完后，右键选择「Open with Live Server」。\n\n#### open in browser\n\n安装 `open in browser`插件后，在 HTML 文件中「右键选择 --> Open in Default Browser」，即可在浏览器中预览网页。\n\n#### Project Manager\n\n工作中，我们经常会来回切换多个项目，每次都要找到对应项目的目录再打开，比较麻烦。Project Manager 插件可以解决这样的烦恼，它提供了专门的视图来展示你的项目，我们可以把常用的项目保存在这里，需要时一键切换，十分方便。\n\n#### WakaTime 【荐】\n\n统计在 VS Code 里写代码的时间。统计效果如下：\n\n![](http://img.smyhvae.com/20200618_2300.png)\n\n#### Code Time\n\n`Code Time`插件：记录编程时间，统计代码行数。\n\n安装该插件后，VS Code 底部的状态栏右下角可以看到时间统计。点击那个位置之后，选择「Code Time Dashboard」，即可查看统计结果。\n\n备注：团长试了一下这个 code time 插件，发现统计结果不是很准。\n\n#### File Tree to Text Generator：快速生成文件的目录树\n\n如题。\n\n#### minapp：小程序支持\n\n小程序开发必备插件。\n\n#### Search node_modules\n\n`node_modules`模块里面的文件夹和模块实在是太多了，根本不好找。好在安装 `Search node_modules` 这个插件后，输入快捷键「Cmd + Shift + P」，然后输入 `node_modules`，在弹出的选项中选择 `Search node_modules`，即可搜索 node_modules 里的模块。\n\n![](http://img.smyhvae.com/20200618_2100.png)\n\n#### RemoteHub\n\n不要惊讶，RemoteHub 和 GitLens 是同一个作者开发出来的。\n\n`RemoteHub`插件的作用是：可以在本地查看 GitHub 网站上的代码，而不需要将代码下载到本地。\n\n![](http://img.smyhvae.com/20190418_1937.png)\n\n这个插件目前使用的人还不多，赶紧安装起来尝尝鲜吧。\n\n#### Live Share：实时编码分享\n\n`Live Share`这个神奇的插件是由微软官方出品，它的作用是：**实时编码分享**。也就是说，它可以实现你和你的同伴一起写代码。这绝对就是**结对编程**的神器啊。\n\n安装方式：\n\n打开插件管理，搜索“live share”，安装。安装后重启 VS Code，在左侧会多出一个按钮：\n\n![](http://img.smyhvae.com/20190418_2012.png)\n\n上图中，点击红框部分，登录后就可以分享你的工作空间了。\n\n![](http://img.smyhvae.com/20190418_2005.png)\n\n#### Import Cost\n\n在项目开发过程中，我们会引入很多 npm 包，有时候可能只用到了某个包里的一个方法，却引入了整个包，导致代码体积增大很多。`Import Cost`插件可以在代码中友好的提示我们，当前引入的包会增加多少体积，这很有助于帮我们优化代码的体积。\n\n### 10、主题插件\n\n给你的 VS Code 换个皮肤吧，免费的那种。\n\n- Dracula Theme\n- Material Theme\n- Nebula Theme\n- [One Dark Pro](https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme)\n- One Monokai Theme\n- Monokai Pro\n- Ayu\n- [Snazzy Plus](https://marketplace.visualstudio.com/items?itemName=akarlsten.vscode-snazzy-akarlsten)\n- [Dainty](https://marketplace.visualstudio.com/items?itemName=alexanderte.dainty-vscode)\n- `SynthWave '84`\n- GitHub Plus Theme：白色主题\n- Horizon Theme：红色主题\n\n## 七、无缝切换：VS Code 配置云同步\n\n我们可以将配置云同步，这样的话，当我们换个电脑时，即可将配置一键同步到本地，就不需要重新安装插件了，也不需要重新配置软件。\n\n下面讲的两个同步方法，都可以，看你自己需要。方法1是 VS Code自带的同步功能，操作简单。方法2 需要安装插件，支持更多的自定义配置。\n\n### 方法1：使用 VS Code 自带的同步功能\n\n1、**配置同步**：\n\n（1）在菜单栏选择「 Code --> 首选项 --> 打开设置同步」：\n\n![](https://img.smyhvae.com/20211008_1713.png)\n\n（2）选择需要同步的配置：\n\n![](http://img.smyhvae.com/20211008_1716.png)\n\n（3）通过Microsoft或者GitHub账号登录。 上图中，点击“登录并打开”，然后弹出如下界面：\n\n![](http://img.smyhvae.com/20211008_1717.png)\n\n上图中，使用 微软账号或者 GitHub账号登录：\n\n![](https://img.smyhvae.com/20211008_1718.png)\n\n（4）同步完成后，菜单栏会显示“首先项同步已打开”，最左侧也会多出一个同步图标，如下图所示：\n\n![](https://img.smyhvae.com/20211008_1720.png)\n\n2、**管理同步**：\n\n（1）点击菜单栏「Code --> 首选项 --> 设置同步已打开」，会弹出如下界面，进行相应的同步管理即可：\n\n![](https://img.smyhvae.com/20211008_1736.png)\n\n（2）换另外一个电脑时，登录相同的账号，即可完成同步。\n\n参考链接：\n\n- [VS Code原生的配置同步功能——Settings Sync](https://blog.csdn.net/baidu_33340703/article/details/106967884)\n\n### 方法2：使用插件 `settings-sync`\n\n使用方法2，我们还可以把配置分享其他用户，也可以把其他用户的配置给自己用。\n\n1、**配置同步**：（将自己本地的配置云同步到 GitHub）\n\n（1）安装插件 `settings-sync`。\n\n（2）安装完插件后，在插件里使用 GitHub 账号登录。\n\n（3）登录后在 vscode 的界面中，可以选择一个别人的 gist；也可以忽略掉，然后创建一个属于自己的 gist。\n\n（4）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「更新/上传配置」，这样就可以把最新的配置上传到 GitHub。\n\n2、**管理同步**：（换另外一个电脑时，从云端同步配置到本地）\n\n（1）当我们换另外一台电脑时，可以先在 VS Code 中安装 `settings-sync` 插件。\n\n（2）安装完插件后，在插件里使用 GitHub 账号登录。\n\n（3）登录之后，插件的界面上，会自动出现之前的同步记录：\n\n![](http://img.smyhvae.com/20200521_1530.png)\n\n上图中，我们点击最新的那条记录，就可将云端的最新配置同步到本地：\n\n![](http://img.smyhvae.com/20200521_1550.png)\n\n如果你远程的配置没有成功同步到本地，那可能是网络的问题，此时，可以使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」，多试几次。\n\n**使用其他人的配置**：\n\n如果我们想使用别人的配置，首先需要对方提供给你 gist。具体步骤如下：\n\n（1）安装插件 `settings-sync`。\n\n（2）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」\n\n（3）在弹出的界面中，选择「Download Public Gist」，然后输入别人分享给你的 gist。注意，这一步不需要登录 GitHub 账号。\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/tool/VS Code的使用.md"}},{"pageContent":"# Git使用指南\n\n## 安装\n\n1. 先去官网下载这个软件, 准备安装到本电脑中\n   > [git-scm.com/](https://link.juejin.cn?target=https%3A%2F%2Fgit-scm.com%2F \"https://git-scm.com/\")\n2. 根据自己电脑系统下载此软件到本机\n   > Windows 系统直接下载 .exe 文件即可，macOS 系统使用 [Homebrew](https://link.juejin.cn?target=https%3A%2F%2Fbaijiahao.baidu.com%2Fs%3Fid%3D1668544039877443967%26wfr%3Dspider%26for%3Dpc \"https://baijiahao.baidu.com/s?id=1668544039877443967&wfr=spider&for=pc\") 命令行安装，终端输入 git --version 确认安装\n\n![image-20230612100943906.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b965f0202334842b029f372fff23ae7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1691&h=893&s=373076&e=png&b=f1f1ea)\n\n3. 默认选择默认安装路径即可，如若想更改路径，务必使用**英文路径**\n4. 对于 Windows 系统，查看安装是否成功: 在任意文件夹右键, 查看是否有Git Base Here 选项, 有就成功了\n\n![image-20230612101818017.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ecc82bd4d384d599021998eff925f5f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1256&h=544&s=182944&e=png&b=fcfcfc)\n\n## 介绍\n\nGit 的三个区域：\n\n- **工作区** ：处理工作的区域\n- **暂存区** ：临时存放的区域\n- **本地git仓库** ：最终的存放区域\n\n在文件夹的体现如下：\n\n- **工作区** ：在你电脑里看到的目录\n- **暂存区** ：在.git文件夹内的index中 (二进制记录)\n- **版本库** ：指的整个.git文件夹 (也认为是本地仓库)\n\n在代码中的体现如下：\n\n![image-20230612154411204-1687173588607.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae33cb79a42d49b7959adfe1d01bf132~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1256&h=621&s=112102&e=png&b=fdfcfc)\n\n# Git使用\n\n> 官方文档：[教程链接](https://link.juejin.cn?target=https%3A%2F%2Fgit-scm.com%2Fbook%2Fzh%2Fv2%2F%25E8%25B5%25B7%25E6%25AD%25A5-%25E5%2585%25B3%25E4%25BA%258E%25E7%2589%2588%25E6%259C%25AC%25E6%258E%25A7%25E5%2588%25B6 \"https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6\")\n>\n> 菜鸟教程：[教程链接](https://link.juejin.cn?target=https%3A%2F%2Fwww.runoob.com%2Fgit%2Fgit-tutorial.html \"https://www.runoob.com/git/git-tutorial.html\")\n\n## Git配置\n\n安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 因为每一个 Git 提交都会使用这些信息\n\n命令格式如下：**中文自己看情况换**\n\n> `git config`：固定命令，设置git相关配置\n>\n> `--global`：全局配置；一次配置，整机在使用git时都生效\n\ngit config --global user.name 你的用户名\ngit config --global user.email 你的邮箱地址\n\n运行命令效果如下：\n\n![image-20230612130038686.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c47580d485364928bc724fbba3237743~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=770&h=197&s=21309&e=png&b=000000)\n\n配置后, 可以运行如下命令查看是否成功\n\n```bash\ngit config --list\n#如果信息太多，可以输入 q 退出\n```\n\n运行命令效果如下：\n\n![image-20230612130350943.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be5717a3f7a34f8eb904a9e2b5f53996~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=958&h=439&s=42349&e=png&b=000000)\n\n> 出现以上内容即为注册成功。如果后续想要修改，只需要重新执行一下命令即可\n\n## 文件右侧标记\n\n> 一般使用 VSCode 打开一个包含git仓库的文件夹时，会有这些标记\n\n![image-20220625155941259.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ce5fa18d6454dd9aa64271ab18dc5e8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=553&h=268&s=15446&e=png&b=252526)\n\n右侧没有标记的时候为 `未修改` 或 此文件/文件夹，被git忽略不跟踪变化\n\n- M： **已修改** （Modified） - 文件已被修改但还没有被添加到暂存区\n- A： **已添加** （Added） - 文件已经被添加到暂存区，但还没有被提交\n- D： **已删除** （Deleted） - 文件已经被删除，并且已经被标记为删除，但还没有提交\n- R： **已重命名** （Renamed） - 文件已经被重命名，这也算作是一种修改，需要被添加到暂存区\n- C： **已复制** （Copied） - 文件已经被复制，这也算作是一种修改，需要被添加到暂存区\n- U： **已更新但未融合** （Updated but Unmerged） - 这表示一个文件已经被更新了，但在合并时发生了冲突，需要手动解决冲突后再标记为已解决\n\n## Git基础命令\n\n### 初始化空的Git仓库\n\n新建一个文件夹或现有的文件夹并不是 git 仓库，因为文件夹内不包含 .git 文件夹，没有被 git 管理\n\n可以在新文件夹或现有文件夹，运行如下命令得到 .git 文件夹，初始化成功则可让 git 开始准备管理\n\n```bash\n# 初始化 git 仓库, 产物: .git 文件夹 (所在文件夹\"内\"被管理)\ngit init\n\n```\n\n例如，在新文件夹中输入git init命令用于初始化空的git版本库\n\n![image-20230612141325305.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f600ec0c2aaa47fcb20bfbda4d3786db~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=975&h=136&s=15077&e=png&b=000000)\n\n初始化空的 git 仓库成功后，在项目文件夹中，开启显示隐藏文件，即可查看 .git 文件夹\n\n- 对于 Windows 系统，在查看里面勾选隐藏的项目选项\n- 对于 macOS 系统，使用快捷键 `Command + Shift + .`切换隐藏文件显示\n\n### 记录更新到Git仓库\n\n每当完成了一个阶段的目标，想要记录下它时，就将它提交到仓库\n\n核心操作：`工作区开发`--->`将修改后的文件添加到暂存区`--->`将暂存区的文件记录到版本库`\n\n- 把工作区变化放到暂存区中，执行如下命令\n\n```bash\n# 将 index.html 添加到暂存区\ngit add index.html\n\n# 将css目录下一切添加到暂存区\ngit add css\n```\n\n- 如下命令，可以一次性把所有变化文件放入暂存区\n\n```bash\ngit add .\n```\n\n- 把暂存区内容，提交到版本库，命令如下（此处文字说明可以不加引号）\n\n```bash\ngit commit -m '提交的内容说明'\n\n```\n\n过程图示：\n\n![image-20230612154411204-1687173588607.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae33cb79a42d49b7959adfe1d01bf132~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1256&h=621&s=112102&e=png&b=fdfcfc)\n\n> 以上命令相当于存档了一次，在版本库中产生一次提交记录并生成版本号\n>\n> 本次存档，不耽误我们在工作区 (项目文件夹) 下继续编写项目\n\n### Git日志及状态查看\n\n- 查看所有提交的日志记录，命令如下\n\n```bash\ngit log\n```\n\n运行命令效果如下：\n\n![image-20230612212059053.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12a32701f95f47b68743f9616783a63d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=846&h=308&s=32544&e=png&b=000000)\n\n- 当我们的日志越来越多，可能想要简化查看，可以输入如下命令\n\n> `--oneline`：在一行显示简略信息\n\n```bash\ngit log --oneline\n```\n\n运行命令效果如下：\n\n![image-20230612212137406.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99219baf1c1349db8e6761df62fd9dd1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=728&h=105&s=15476&e=png&b=000000)\n\n- 如果改的代码过多，忘记改过哪些了，可以运行如下命令来查看 git 仓库变化，只能看未提交的所有变更的文件状态\n\n```bash\ngit status\n```\n\n运行命令效果如下：\n\n![image-20230612212456778.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7466cc34e76c4f9e837a2a1bbce3d857~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=875&h=305&s=30542&e=png&b=000000)\n\n- 暂存并再次提交，产生一次版本记录\n\n```bash\ngit status\n\n```\n\n过程图示：\n\n![image-20230612154411204.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02257e8b46404c0980b8ac68fe07f4b2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1256&h=621&s=121037&e=png&b=fdfcfc)\n\n### Git版本回退\n\n时光机，回到过去~\n\n- 回退命令语法如下\n\n```bash\ngit reset --hard 版本号\n```\n\n- 查看版本号（每次的版本号随机生成）\n\n```bash\ngit log --oneline\n```\n\n![image-20230612212700778.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/935df632f35f4e5396627b114e5607e6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=723&h=140&s=21033&e=png&b=000000)\n\n- 尝试回退到 `477321b` 这次记录上\n\n```bash\ngit reset --hard 477321b\n```\n\n- 观察工作区，回退成功\n\n![image-20230612212808682.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28101f170cdd4821a446fd1bcdc739a1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=722&h=187&s=28346&e=png&b=000000)\n\n- 如果想要在回到最近一次提交的记录，但发现 `git log`看不到未来的记录了，问题不大。**输入git reflog命令，可以查看 git 所有的操作记录，包括你的reset记录**\n\n```bash\ngit reflog\n\n```\n\n运行命令效果如下：\n\n![image-20230612212857923.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46125c80682e434997028ab35dda4988~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=736&h=156&s=31014&e=png&b=000000)\n\n> 拓展命令：\n>\n> - git bash（终端）清屏：`clear `\n> - git bash（终端）另起一页：`Ctrl + L`\n\n### Git忽略文件\n\n有的时候，我们某些文件或文件夹不想让 git 进行跟踪管理。这时候可以在 .git 文件夹同级目录下新增 `.gitignore`的忽略文件并写入忽略规则（此处的文件名就是 .gitignore ，不是后缀）\n\n项目文件夹结构如下：\n\n![image-20230612213354387.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3742e0da132340899e330a9562a541bd~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=686&h=215&s=20403&e=png&b=ffffff)\n\n```bash\n# .gitignore内容：\npassword.txt\n\n其余用法：\n# 忽略文件夹\ncss\n# 忽略文件夹下的某个文件\ncss/index.js\n# 忽略文件夹下某类文件\ncss/*.js\n\n```\n\n根目录新建 password.txt，查看 git 追踪到了哪些变化\n\n```bash\ngit status\n```\n\n运行命令效果如下：\n\n![image-20230612214049685.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70d3ce513f4f4ed688b2d2fa0553dfc4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=943&h=204&s=19819&e=png&b=000000)\n\n> 发现只新增了.gitignore ，符合规则的都被忽略掉了\n\n`.gitignore`文件在项目中可以根据脚手架自动生成，无需自己编写，当然如果你非要写，以下是Vue官方自动生成的 `.gitignore`文件代码，可供复制使用\n\n```bash\n# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n\n```\n\n## Git分支\n\n### 分支本质\n\n分支其实就是一个叫**HEAD**的指针标记，每次代码提交，此**HEAD**指针都会往后移动一次，保证指向的 (并且工作区里的) 都是最后一次提交\n\n例如：当我们输入命令：`git reset --hard a3bcab2`，**HEAD**指针会移动，而且**HEAD**移动后，会影响工作区里的代码\n\n### 创建分支\n\n- **创建分支命令如下**\n\n```bash\n# 创建分支\ngit branch 分支名\n\n```\n\n该命令创建分支后不会自动切换分支，我们可以运行命令查看现在这个 .git 版本库里所有分支\n\n- **查看当前版本库所有分支命令如下**\n\n# 查看当前版本库所有分支，绿色带\\*代表现在所处的分支\n\ngit branch\n\n运行命令效果如下：\n\n![image-20230612215435954.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84fdb5bdfd8e4b8e87498f16c4113c5c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=758&h=176&s=18242&e=png&b=000000)\n\n- **手动切换到分支上**\n\n# 切换分支命令\n\ngit checkout 分支名\n\n运行命令效果如下：\n\n![image-20230612215712754.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3bbcf972ef440758d6327e6e142e8b6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=729&h=226&s=31046&e=png&b=000000)\n\n> 第一次创建并切换到 reg 分支，你会发现 master 分支上的所有代码 (和当前节点所有提交记录) 都被复制了过来\n> 了，我们只需要在这个基础上接着往后开发就行\n\n过程图示：\n\n![image-20230612215806700.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/339ad9c27506449baebc1edd5075992a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1244&h=611&s=131989&e=png&b=fdfdfd)\n\n### 分支下开发流程\n\n我们现在就可以在当前 reg 分支下来编写注册页面的逻辑代码，例如新建 `reg.html`文件，并随便写点内容。随后暂存并提交一次，这次提交的记录会出现在这里，如图\n\n![image-20220626005643763.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5b7ae62526b448d85035bf0501ed3da~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1262&h=586&s=124210&e=png&b=fcfbfb)\n\n以后在当前 reg 分支下开发，就会在 reg 范围内，每次提交产生一次版本记录，不会影响到别的分支\n\n### 分支合并\n\n我们可以把分支里写好的代码，合并到主分支或其他分支上，步骤如下：\n\n- 首先，切换到你要合并到的目标分支上（以master主分支为例）\n\n# 切换分支\n\ngit checkout master\n\n切换分支后，**HEAD**指针位置如下：\n\n![image-20230612220823875.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/506743c99da84c3c8298456406b2168a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1254&h=587&s=162561&e=png&b=fdfdfd)\n\n**合并命令语法**\n\ngit branch -d 分支名\n\n这里我们执行命令 `git merge reg`，执行后效果如图：\n\n![image-20220626011937230.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/422e99c4f9b64b33aa740218922357a8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1266&h=606&s=125759&e=png&b=fcfcfc)\n\n可见，reg 代码提交记录已经复制到了 master (主分支) 中\n\n### 分支删除\n\n假如注册功能开发完毕，代码已经合并到 master 分支上，我们已经不需要 reg 分支\n\n- **命令如下**\n\n```bash\ngit branch -d 分支名\n\n```\n\n如果分支的修改没有被合并到其他分支上，Git 会提示一个类似以下的错误信息：\n\n`error: The branch 'branch_name' is not fully merged. If you are sure you want to delete it, run 'git branch -D branch_name'.`\n\n在这种情况下，Git 建议你确认是否要删除这个分支。如果你确定要删除该分支并且不在乎丢失该分支的修改，你可以使用 `git branch -D <branch_name>`命令来**强制删除**该分支。但请注意，这样会丢失掉分支上的未合并修改\n\n### 分支合并时的冲突问题\n\n在两个分支修改了同一个文件并提交过，在合并的时候，就会产生冲突\n\n这里模拟一次简单的冲突：\n\n- 在 master 分支下，修改 `login.html`的某行代码，并完成一次暂存提交\n\n![image-20230612221800522.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61534650ad8549e185e72f3561c0016a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=740&h=284&s=37177&e=png&b=000000)\n\n- 切换到 reg 分支下，也修改 `login.html`的对应行代码，并完成一次暂存提交\n\n![image-20230612222009473.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ee908999ca34052ac74183a2d150457~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=706&h=280&s=36067&e=png&b=000000)\n\n- 再切换回到 master 分支下，用合并命令，把 reg 分支下代码和变化合并过来，**不出意外就会出现冲突了**\n\n![image-20230612222117265.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f8ffb16b9fa4d14b8bd3946a3dade34~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=833&h=299&s=35038&e=png&b=000000)\n\n发生冲突后，VSCode界面\n\n![image-20230612222156560.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b1b2a0253da4e17adab3d8d61348ddf~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=617&h=206&s=33508&e=png&b=23272e)\n\n> 此时我们要进行抉择： **采用当前更改** 、 **采用传入更改** 、**全部保留**\n\n选择保留方式后，需要再次暂存提交一次\n\n![image-20230612222444912.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ac609157d4741e39e207d982cca49b6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=800&h=234&s=33073&e=png&b=000000)\n\n> 此时结束冲突状态，变回正常状态\n\n- 打印冲突合并后的日志记录\n\n![image-20230612222705106.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c097571c37e48eba8da302f47441a7c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=793&h=661&s=71158&e=png&b=000000)\n\n> 总结：当我们合并遇到冲突了，应手动解决，然后暂存，提交一次即可\n\n## Git分支流程图详解（拓展）\n\n- **HEAD**头指针，它指向当前所在的分支或者某个具体的提交记录。每次提交会产生新的记录**master**和**HEAD**会后移\n\n![image-20230612224348269.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9639818947c94faf980d326508c8ea21~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=700&h=391&s=50853&e=png&b=fcfcfc)\n\n- 以当前节点为基准创建新的分支 (包含之前的所有提交记录)，`git branch reg` 就会在当前的提交记录上创建一个新的指针，名称为**reg**\n\n![image-20230612224959233.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7612d4bbdc83415e83ac8a94048dd86f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=684&h=448&s=47340&e=png&b=fdfdfd)\n\n- `git checkout reg`切换的是**HEAD**指针指向 (切换分支)\n\n![image-20230612225147670.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9595baac5fc4c7a843ebcced8cde384~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=673&h=466&s=39148&e=png&b=fdfdfd)\n\n- 注册页面新建后，`git add .`添加到暂存区，`git commit -m` 产生了一次提交记录\n\n![image-20230612225547703.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e702e79fc14a4fd79a863c63fa4db5cc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=822&h=534&s=50289&e=png&b=fdfdfd)\n\n- 注册页面的样式新建后暂存提交，产生了一次提交记录\n\n![image-20230613003559070.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3187bb9e91d49099b65d326c9069dfa~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=968&h=485&s=47899&e=png&b=fdfdfd)\n\n- 合并分支，例如把 A 合并到 B上\n\n  - `git checkout B`，切换到目标分支 B\n  - `git merge A`，把 A 分支记录合并到所在 B 分支下\n\n  先切换到主分支 `git checkout master`\n\n![image-20230613004008281.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26efb48153c94dd894888bf37bf68d0a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=951&h=558&s=47458&e=png&b=fdfdfd)\n\n- 合并**reg**分支 `git merge reg`\n\n![image-20230613004234355.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c8ba272cd55497183236fdb8320c507~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=870&h=563&s=52972&e=png&b=fdfdfd)\n\n- 在**reg**分支下，修改了 `index.html`文件，并暂存提交，产生了记录\n\n![image-20230613004635286.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6cbd349513b4f758edf55ab7c2fa47e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=939&h=507&s=56307&e=png&b=fdfdfd)\n\n- 切换到**master**分支，并修改 `index.html`文件(同一个文件)，暂存提交，产生了记录\n\n![image-20230613010644386.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d596cdad0d7340f3ab2a1b64c9f5e545~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=948&h=618&s=70461&e=png&b=fcfcfc)\n\n- 在**master**分支中，想要把**reg**合并过来。由于修改了同一个文件，会报错，需要解决冲突\n\n![image-20230613010950109.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17f70c3240d346e59c00847f768f7e19~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1083&h=466&s=60751&e=png&b=fdfdfd)\n\n- 手动解决冲突后，会产生一个新的提交记录\n\n![image-20230613011347885.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8797be1e0abe479d9a7a73a81806ab1a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1275&h=460&s=62962&e=png&b=fdfdfd)\n\n- 删除**reg**分支，全部过程结束\n\n![image-20230613011445775.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb459f69afc4465c9c7fdb5b18ce9c7f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1303&h=378&s=54548&e=png&b=fdfdfd)\n\n## Git远程仓库\n\n### 介绍\n\n远程仓库是指托管在因特网或其他网络上的 Git 仓库，可以存储我们版本库的所有记录和存档记录\n\n远程仓库在团队协作中发挥着重要的作用。它不仅可以充当备份存储，保护你的代码免受数据丢失的风险，还可以让团队成员之间轻松地共享代码、查看代码变更、进行代码审查等\n\n![image-20230615093344985.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13a4c887c55546daafb77886906c97fd~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1251&h=499&s=155129&e=png&b=feefea)\n\n主流的远程仓库有 GitHub (gay hub)全球最大的同行交友社区，以及服务器在国内的 gitee（码云）。由于 GitHub 服务器在国外，需要科学上网或者使用其他加速工具，方便起见，这里以码云为例，供初学者参考，GitHub 流程与 gitee 类似\n\n### 注册\n\n注册登录 gitee.com 网站以后，添加主邮箱为自己本地 git 仓库设置的邮箱，注意一定要相同，否则无法正确提交\n\n如果忘记了本地设置的邮箱地址：\n\n- 可以打开控制台输入 `git config --list` 重新查看邮箱地址\n- 当然也可以使用 `git config --global user.email 你的邮箱地址`重新覆盖原来的邮箱地址\n\n**邮箱设置界面不要勾选不公开我的邮箱地址，否则也无法正常提交**\n\n![image-20230615094323926.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b12fe36771343d9b420251a0238b33a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1221&h=748&s=90210&e=png&b=ffffff)\n\n### 仓库新建\n\n可以选择创建一个远程仓库的项目 (可以多个)，创建界面如下\n\n![image-20230615095044748.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/432b12e869a649f9822330c8e94a0c74~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1152&h=859&s=74998&e=png&b=ffffff)\n\n勾选完成后选择创建，创建后, 会得到一个远程仓库的地址链接, 一般是以 `.git`结尾的地址\n\n地址分为两种最常用的两种传输协议：\n\n- HTTPS协议：需要输入用户名和密码 `https://gitee.com/(userName)/(repositoryName).gitssh`\n- SSH协议：需要配置密钥，可免密码登录 `git@gitee.com:userName/repositoryName.git`\n\n选择SSH路径，界面如下\n\n![image-20230615095628604.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5b124240c3f4aa6a5277f0681a36569~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1509&h=871&s=78185&e=png&b=ffffff)\n\n### SSH配置\n\n我们可以在本机一次性配置 SSH 以后免密登录，SSH 密钥组成和作用如下：\n\n- 作用：实现本地仓库和 gitee 平台之间免登录的加密数据传输\n- 组成：`id_rsa` (私钥文件，存放于客户端的电脑中即可)、`id_rsa.pub` (公钥文件，需要配置到 gitee 平台中)\n\n> 私钥加密的信息，只能通过公钥解密。公钥加密的信息，只能通过私钥解密。安全性高！\n\nSSH 密钥创建与使用步骤：\n\n- 先在本机生成一个密钥 (以后也可以重新生成、重新配置)，打开一个终端，输入以下命令：\n\n  ```bash\n  ssh-keygen -t rsa -C \"你注册账号的邮箱\"\n  ```\n\n- 连续敲击 3 次回车，即可在 `C:\\Users\\用户名文件夹.ssh`目录中生成 `id_rsa`和 `id_rsa.pub`两个文件\n- 使用 VSCode 打开 `id_rsa.pub`文件，复制里面的文本内容\n- 粘贴配置到 码云 -> 设置 -> ssh 公钥 中即可\n- 如果为 mac ，可进入以下教程查看：[mac获取公钥](https://juejin.cn/post/6844904169191522317 \"https://juejin.cn/post/6844904169191522317\")\n\n### 初始化空仓库\n\n先给本地仓库配置个远程仓库的地址, 建立仓库之间的链接\n\n由于每次 push 操作都需要带上远程仓库的地址，十分麻烦，我们可以给仓库设置一个别名\n\n```bash\n# 给远程仓库设置一个别名\ngit remote add 仓库别名 仓库地址\ngit remote add origin git@gitee.com:(username)/repository.git\n\n# 删除 origin 这个别名\ngit remote remove origin\n\n# 使用 -u 记录 push 到远端分支的默认值，将来直接 git push 即可\ngit push -u 仓库别名 分支名\n\n\n```\n\n![image-20230615101817727.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/286cb8c8f7014178a0f9d661d72b1b86~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1046&h=500&s=52493&e=png&b=ffffff)\n\n下面为实际操作举例：\n\n- 随便新建一个项目文件夹，初始化 git，随后在项目文件中随便填充点内容，这里我新增一个 `.gitignore`文件，随后暂存提交到本地 git 库\n\n  ![image-20230615103357225.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ed212afea8340b1b0bb8416e4da2cfc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1095&h=399&s=53082&e=png&b=000000)\n\n- 输入以下命令：\n\n  ```bash\n  # 注意：这里的existing_git_repo是你的项目根路径\n  # 如果你是在项目文件夹开启的终端，忽略此行\n  cd existing_git_repo\n\n  # 添加远程仓库关联，仓库别名origin，可以随意更改，后接ssh地址\n  # 此处的ssh是自动生成的，可以去gitee空仓库的代码页直接复制即可\n  git remote add origin git@gitee.com:li-houyi/test-factory.git\n\n  # 第一次推送到远程时需要指定具体的分支，因为远程仓库并没有这个分支\n  # 使用 -u 记录 push 到远端分支的默认值，将来直接 git push 即可\n  git push -u origin \"master\"\n\n  ```\n\n- 出现此页面即为成功：\n\n  ![image-20230615104040319.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b79a2854794940cd8b865dbf3ec742e4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=799&h=322&s=41134&e=png&b=000000)\n\n  > 注意：推送的本地仓库一定要非空并且本地暂存提交过，不然会报错！这点也很好理解，你传个空的项目到一个空仓库，这可不得给你报错吗\n\n- 推送成功后重新进入 gitee 仓库页面查看是否正确推送\n\n  ![image-20230615105531979.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e41eac290dc4f149a74464f41c0db49~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1167&h=399&s=43890&e=png&b=fcfcfc)\n\n空仓库创建成功后可以在管理页面将仓库开源，当然也可以不设置开源（默认私有）\n\n### 克隆项目\n\n如果你想要从远程仓库克隆一份项目代码到本地进行开发，可以使用 `git clone` 命令\n\n```bash\ngit clone [options] <repository-url> [directory]\n# directory（可选）克隆后的本地仓库所处的目录名称（默认创建与远程仓库名字相同的目录）\n\n```\n\n**常见选项：**\n\n- `-b <branch>` 或 `--branch <branch>`：指定要克隆的远程仓库的特定分支，它不会影响克隆操作所获取的分支数量，而只是指定了默认要检出的分支（不指定则默认克隆远程仓库的主分支）\n- `--depth <depth>`：指定克隆的深度，即只克隆指定数量的提交历史\n- `--single-branch`：仅克隆指定分支以及该分支上的历史记录，不下载其他分支\n- `--recurse-submodules`：初始化并克隆子模块的内容\n- `-n` 或 `--no-checkout`：克隆后不立即检出任何分支，保留 HEAD 指向原始仓库的默认分支\n- `-o <name>` 或 `--origin <name>`：自定义远程仓库的别名。\n- `-u <remote> <branch>` 或 `--set-upstream-to=<remote>/<branch>`：设置追踪关系，使得本地分支自动与指定的远程分支关联\n\n如果项目只有一个分支，那么以上代码执行完毕就已经克隆结束了（git clone 默认拉取 master 分支），**不过实际开发中，并非只有一个分支，于是我们还需执行以下步骤：**\n\n- 在本地建分支，分支名与远程分支名相同，查看远程分支名使用 `git branch -r`\n\n```bash\ngit checkout -b 对应远程分支名\n```\n\n- 拉取远程分支 ( **不要在 master 分支直接拉取对应分支的代码，切换到新建的分支** )\n\n```bash\n# 每次拉取都需要指定远程仓库名和分支名\ngit pull 远程仓库名 分支名\n\n```\n\n- 以上两行命令可以合并写做一行（创建并拉取远程分支代码）\n\n```bash\ngit checkout -b 分支名 origin/分支名\n\n```\n\n- 拓展: 设置 git pull 默认拉取的分支（设置本地分支与远程分支相关联）\n\n```bash\ngit branch --set-upstream-to=origin/远程分支名 本地分支名\n\n```\n\n### Git远程仓库流程回顾\n\n- Step1：\n\n![image-20230616072225869.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f4681eae7324e7289273c0dfafcce42~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1293&h=742&s=106266&e=png&b=ffffff)\n\n- Step2：\n\n![image-20230616072307518.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cab60b7a65848359254d6a7f324d211~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1269&h=734&s=138485&e=png&b=ffffff)\n\n- Step3：\n\n![image-20230616072523621.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c08d5b4d515d4443b12c0ad5c16e922c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1410&h=781&s=214562&e=png&b=fefefe)\n\n- Step4：\n\n![image-20230616072547086.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b68c1379c384c38adea3aeddb42a8da~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1279&h=715&s=86253&e=png&b=ffffff)\n\n# Git常用命令总览\n\n> 本命令**默认远程仓库名**为 `origin`、**默认远程仓库主分支名**为 `master`、`<>`为必填项，`[]`为可选项\n\n![git.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e98276c847f4cc6a24482d08394cd3a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2455&h=4096&s=945536&e=png&b=fef7f6)\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/tool/git的使用.md"}},{"pageContent":"\n\n\n## 常见配置\n\n\n**自动保存**：\n\n```\n \"files.autoSave\": \"onFocusChange\"\n```\n\n参考链接：<https://blog.csdn.net/WestLonly/article/details/78048049>\n\n\n\n**在新的窗口中打开文件**：\n\n```json\n\"workbench.editor.enablePreview\": false,\n```\n\n## 常见操作\n\n### 如何查看代码结构\n\n- 方法一：「Cmd + Shift + O」\n\n- 方法二：安装插件`Code Outline`\n\n参考链接：<https://www.zhihu.com/question/264045094>\n\n\n\n### 在本地开启服务器\n\n```bash\n# 安装\nnpm install -g live-server\n\n# 启动\nlive-server\n```\n\n\n参考链接：[Visual Studio Code + live-server编辑和浏览HTML网页](http://www.cnblogs.com/1zhk/p/5699379.html)\n\n\n## 常用插件\n\n方式一：打开VS Code，左侧有五个按钮，点击最下方的按钮，然后就可以开始安装相应的插件了。\n\n方式二：在vscode中输入快捷键「ctrl+shift+P」，弹出指令窗口，输入`extension:install`，回车，左侧即打开扩展安装的界面。\n\n\n### sftp：文件传输\n\n\n输入快捷键「ctrl+shift+P」，弹出指令窗口，输入`sftp:config`，回车，当前工作工程的`.vscode`文件夹下就会自动生成一个`sftp.json`文件，我们需要在这个文件里配置的是：\n\n- `host`：服务器的IP地址\n\n- `username`：工作站自己的用户名\n\n- `privateKeyPath`：存放在本地的已配置好的用于登录工作站的密钥文件（也可以是ppk文件）\n\n- `remotePath`：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用sftp上传文件之前，要手动在工作站上mkdir生成这个根目录\n\n- `ignore`：指定在使用sftp: sync to remote的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号\n\n\n举例如下：(注意，其中的注释不能保留)\n\n```json\n{\n    \"host\": \"\",     //服务器ip\n    \"port\": 22,     //端口，sftp模式是22\n    \"username\": \"\", //用户名\n    \"password\": \"\", //密码\n    \"protocol\": \"sftp\", //模式\n    \"agent\": null,\n    \"privateKeyPath\": null,\n    \"passphrase\": null,\n    \"passive\": false,\n    \"interactiveAuth\": false,\n    \"remotePath\": \"/root/node/build/\",  //服务器上的文件地址\n    \"context\": \"./server/build\",        //本地的文件地址\n\n    \"uploadOnSave\": true,   //监听保存并上传\n    \"syncMode\": \"update\",\n    \"watcher\": {            //监听外部文件\n        \"files\": false,     //外部文件的绝对路径\n        \"autoUpload\": false,\n        \"autoDelete\": false\n    },\n    \"ignore\": [             //忽略项\n        \"**/.vscode/**\",\n        \"**/.git/**\",\n        \"**/.DS_Store\"\n    ]\n}\n```\n\n\n### Sass Formatter\n\nSass 文件格式化。\n\n\n### Code Outline：显示代码结构\n\n\n安装好插件「Code Outline」后，可以在左侧的资源管理器中，显示当前文件的代码结构：\n\n![](http://img.smyhvae.com/20180420_0925.png)\n\n参考链接：\n\n- <https://www.zhihu.com/question/50273450>\n\n- <http://itopic.org/vscode.html>\n\n- <https://github.com/varHarrie/varharrie.github.io/issues/10>\n\n### vscode-fileheader：添加顶部注释模板(签名)\n\n（1）安装插件vscode -fileheader，并重启。\n\n（2）在首选项-》设置-》中搜索fileheader，找到头部模板修改。\n\n默认的快捷键是：「Ctrl + option + I」。\n\n参考链接：\n\n- <https://www.zhihu.com/question/62385647>\n\n\n### Express\n\n在本地开启Node服务器：\n\n![](http://img.smyhvae.com/20180611_2230.png)\n\n然后在浏览器的地址栏输入`http://localhost/` + 文件的相对路径，就可以通过服务器的形式打开这个文件。\n\n### Copy Relative Path\n\n> 这个插件很有用，使用频率很高。\n\n复制文件的相对路径：（相对于根路径而言）\n\n![](http://img.smyhvae.com/20180611_2235.png)\n\n\n### open in browser\n\n在浏览器中打开。\n\n\n### Auto Rename Tag\n\n适用于 JSX、Vue、HTML。在修改标签名时，能在你修改开始（结束）标签的时候修改对应的结束（开始）标签，帮你减少 50% 的击键。\n\n\n###Project Manager\n\n项目管理，让我们方便的在命令面板中切换项目文件夹，当然，你也可以直接打开包含多个项目的父级文件夹，但这样可能会让 VSCode 变慢。\n\n\n\n### highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】\n\nVSCode自带的高亮显示，实在是不够显眼。用插件支持一下吧。\n\n所用了这个插件之后，VS Code自带的高亮就可以关掉了：\n\n在用户设置里添加`\"editor.selectionHighlight\": false`即可。\n\n\n参考链接：[vscode 选中后相同内容高亮插件推荐](https://blog.csdn.net/palmer_kai/article/details/79548164)\n\n\n### highlight-words：全局高亮（跨文件多色彩）\n\n\n参考链接：[Visual Studio Code全局高亮着色插件(跨文件多色彩)经验纪要](https://zhuanlan.zhihu.com/p/31163793)\n\n\n### color-exchange：颜色格式转换【荐】\n\n\n安装完插件后，在css中输入颜色，然后按`cmd + .`，就能进行颜色的格式转换。\n\n20181013_1450.png\n\n我在写这一段时，安装的人还不多，赶紧上车。\n\n\n\n## Vue 相关的插件\n\n### vetur：vue 文件的基本语法高亮\n\n安装完 vetur 后还需要加上这样一段配置下：\n\n```\n\"emmet.syntaxProfiles\": {\n  \"vue-html\": \"html\",\n  \"vue\": \"html\"\n}\n```\n\n参考链接：\n\n- <https://www.clarencep.com/2017/03/18/edit-vue-file-via-vscode/>\n\n\n- <https://github.com/varHarrie/varharrie.github.io/issues/10>\n\n\n\n### 参考链接\n\n- <https://www.jianshu.com/p/0724921285d4>\n\n- <https://www.cnblogs.com/AmosLee94/p/8338013.html>\n\n\n\n\n## 常用快捷键\n\n\n| Win快捷键 |Mac快捷键| 作用 | 备注 |\n|:-------------|:-------------|:-----|:-----|\n| Shift + Alt + F |Shift + option + F| 代码格式化 |  |\n| Ctrl + Shift + N | |在当前行上面增加一行并跳至该行  |   |\n|  **Ctrl + Shift + D** | |复制当前行到下一行  |   |\n\n\n\n\n\n### 如何同时打开多个窗口\n\n\n\n\n\n\n\n\n\n\n\n\n## 问题\n\n问题1\n\n解决；You can kill the Microsoft.VSCode.Cpp.IntelliSense.Msvc process to save the file successfully. 也就是 IntelliSense 这个进程。\n\n\n\n\n## 参考链接\n\n- [能让你开发效率翻倍的 VSCode 插件配置（上）](https://zhuanlan.zhihu.com/p/30976584)\n\n\n### 某网友的VS Code 插件截图\n\n![](http://img.smyhvae.com/20180611_2255.png)\n\n\n\n\n\n\n\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/tool/vscode配置.md"}},{"pageContent":"# 什么是前端？\n\n## 1.1 前端的定义\n\n在我们访问一个网站时，所有能够直接看到、点击、输入和互动的部分，都是由前端来实现的。前端主要是指用户可视界面的开发，包含页面结构、样式、动态效果和互动功能，最终目标是为用户提供友好且美观的交互界面。\n\n## 1.2 前端的三大核心技术\n\n前端开发的实现主要依赖以 下三大核心技术：\n\nHTML（HyperText Markup Language）：前端开发的基础，用于定义网页的结构和内容。HTML 定义了网站的每个元素，如文本、图像、视频、链接等，让网页有“骨架”。\n\nCSS（Cascading Style Sheets）：用于网页的样式设计，定义 HTML 元素的显示方式，包括颜色、字体、布局等。CSS 让网页更加美观、有层次感。\n\nJavaScript：赋予网页动态交互功能，使网页可以响应用户操作。比如按钮的点击、表单验证、图片轮播等功能都需要 JavaScript 支持。\n\n这些技术的结合，让开发者可以构建功能丰富、互动性强的网页。随着前端技术的不断发展，HTML、CSS 和 JavaScript 的应用也越来越广泛和深入。\n\n## 1.3 前端框架和工具\n\n为了提升开发效率和用户体验，前端开发衍生出了一系列强大的框架和工具：\n\n框架和库：如 React、Vue.js、Angular 等，它们提供了大量预设的组件和功能，帮助开发者快速构建复杂的界面。\n\n预处理器和后处理器：如 Sass、Less（CSS 预处理器）、PostCSS 等，用于提升 CSS 的灵活性和可维护性。\n\n构建工具：如 Webpack、Parcel 等，用于打包、压缩和优化前端代码，提升网页加载速度。\n\n# 2.什么是后端？\n\n## 2.1 后端的定义\n\n与前端的用户交互界面不同，后端负责应用的业务逻辑、数据处理和管理。后端如同应用的“后台”，用户无法直接看到，但它负责网站或应用的核心功能和数据流转。后端的职责是确保数据存储安全、业务逻辑运行流畅，并根据请求将数据发送给前端。\n\n## 2.2 后端的组成要素\n\n后端主要由以下几个部分构成：\n\n服务器：为用户提供数据和计算资源的设备，托管网站和应用。服务器接收前端发送的请求，并根据业务逻辑返回相应的数据。\n\n数据库：用于存储和管理应用数据的系统，常见的数据库有 MySQL、MongoDB、PostgreSQL 等。数据库将结构化的或非结构化的数据保存下来，以便随时查询和更新。\n\n服务器端编程语言：用于编写业务逻辑代码，将应用的需求转化为功能，常见的后端语言有 Java、Python、PHP、Ruby、Node.js 等。\n\n## 2.3 后端框架和工具\n\n为了提升开发效率和代码的稳定性，后端开发者通常使用各种框架和工具：\n\n后端框架：如 Express（基于 Node.js）、Django（基于 Python）、Laravel（基于 PHP）等，这些框架提供了丰富的工具和功能，加速开发并提升代码的可维护性。\n\nAPI：应用程序接口（API）是前后端沟通的桥梁，常见的 API 技术包括 RESTful API 和 GraphQL，通过这些接口，前端可以请求数据，而后端负责返回所需的数据。\n\n# 3.前后端的区别\n\n了解了前端和后端的概念后，我们再来深入探讨一下两者的区别。前端和后端分别处理不同的任务，它们相辅相成，共同构成了一个完整的应用。\n\n| 比较维度 | 前端                                    | 后端                                                   |\n| -------- | --------------------------------------- | ------------------------------------------------------ |\n| 目标     | 提供美观、友好、流畅的用户界面          | 处理业务逻辑，管理数据，确保功能正常运行               |\n| 技术栈   | HTML、CSS、JavaScript、Vue.js、React 等 | Node.js、Java、Python、PHP、数据库（MySQL、MongoDB）等 |\n| 执行环境 | 用户的浏览器中                          | 服务器上                                               |\n| 面向对象 | 面向用户，提供良好的交互体验            | 面向数据和逻辑，确保数据的正确性和安全性               |\n| 关注点   | 页面布局、样式、交互                    | 数据管理、业务逻辑                                     |\n\n# 4.什么是前后端分离？\n\n在了解了前后端的区别后，现代 Web 开发中越来越强调的“前后端分离”概念就很容易理解了。前后端分离意味着前端和后端各自独立开发、部署和维护，两者通过 API 进行数据交换。这种开发模式带来了很多好处\n\n## 4.1 前后端耦合与前后端分离\n\n传统前后端耦合方式：早期的 Web 开发中，前端页面和后端逻辑紧密耦合在一起。每当用户请求一个页面，服务器会先处理业务逻辑，将数据填充到 HTML 模板中生成页面，再返回给浏览器。这种方式虽然简单，但页面每次请求都需要刷新，体验不佳。 浏览器的展示是由后端来决定的 其实就是服务器决定的。\n\n- 前后端分离模式：前后端分离的模式中，前端通过 AJAX、Fetch 或者 Axios 等方式调用后端提供的 API，获取数据并渲染页面。这样，前端的页面和后端的逻辑完全分离，只通过 API 进行数据交换，页面只需要局部刷新而无需整体加载。\n\n<img src='https://i-blog.csdnimg.cn/direct/a2a2c15734234908b3dae119e0878bb1.png'>\n\n## 4.2 前后端分离的好处\n\n- 提升用户体验：前端可以动态获取数据并局部刷新页面，减少了页面跳转和加载时间，用户体验更流畅。\n- 提高开发效率：前后端开发可以并行进行，前端专注界面和交互，后端专注数据和逻辑，减少了开发依赖性。\n- 便于技术升级和维护：前后端代码独立，便于维护和更新。前端可以随时切换技术框架，而后端则可以逐步优化，不会相互影响。\n\n## 4.3 前后端分离的实现方式\n\nRESTful API：通过 REST 风格的接口，前端可以按需请求资源，如 CRUD（增删查改）操作，非常适合大部分 Web 应用。\n\nGraphQL：一种灵活的查询语言，让前端可以按需请求数据字段，减少了冗余数据的传输，适合复杂应用的数据请求。\n\n5. 前后端分离的示例场景\n   为了更好理解前后端分离的应用场景，以下是一个电子商务网站的示例：\n\n前端：用户访问一个在线商城，页面的商品展示和购物车动态更新，这些交互由前端处理。用户点击商品、添加到购物车等操作会触发 JavaScript 动作，并通过 Axios 发送请求。\n\n后端：接收到请求后，后端服务器查询数据库，返回商品数据。后端还负责处理库存管理、支付逻辑等，确保商品库存与订单信息准确无误。\n\n通过 API，前端可以迅速获取最新的商品信息，局部刷新商品列表，不需要刷新整个页面，提升了购物体验。\n\n总结\n前端：定义页面结构、样式和交互，让用户看到并与应用互动的部分。\n后端：负责业务逻辑和数据处理，确保应用核心功能的正常运行。\n前后端分离：是一种现代化开发模式，通过 API 将前端与后端分离，提升开发效率和用户体验。\n通过深入了解前端、后端及前后端分离的概念，希望你能对 Web 开发的整体架构有更系统的认识。接下来的学习中，我们将带你进一步了解前端开发的具体技术，实现从零到项目开发的顺利过渡\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/tool/前端是什么.md"}},{"pageContent":"# 浏览器插件\n\n[极简插件](https://chrome.zzzmh.cn/about)\n\n可以前往极简插件网站下载浏览器插件\n\n在我们的日常工作中，安装一些浏览器插件可以更方便一些日常工作。这篇经验就来介绍一下怎么在谷歌浏览器里面安装插件。\n\n1、打开谷歌浏览器。\n\n![](http://exp-picture.cdn.bcebos.com/354e7a781423beb9cc4b087830d6e1d06ce8b3d3.jpg?x-bce-process=image%2Fcrop%2Cx_0%2Cy_0%2Cw_1920%2Ch_1023%2Fformat%2Cf_auto%2Fquality%2Cq_80)\n\n2、点击右上角的三个点，找到设置。\n\n![](http://exp-picture.cdn.bcebos.com/ba97ffd06de89a614650682945e8b004551badd3.jpg?x-bce-process=image%2Fcrop%2Cx_0%2Cy_0%2Cw_1919%2Ch_1029%2Fformat%2Cf_auto%2Fquality%2Cq_80)\n\n3、在左侧的菜单中找到“扩展程序”，单击一下。\n\n![](http://exp-picture.cdn.bcebos.com/65390a23beb9763e9ab7926c6ad06de89b61b0d3.jpg?x-bce-process=image%2Fcrop%2Cx_0%2Cy_0%2Cw_1920%2Ch_1023%2Fformat%2Cf_auto%2Fquality%2Cq_80)\n\n4、打开右上角的“开发者模式”。\n\n![](http://exp-picture.cdn.bcebos.com/2083a5d6e1d06de82514af9fca93cee8b104acd3.jpg?x-bce-process=image%2Fcrop%2Cx_0%2Cy_0%2Cw_1920%2Ch_1023%2Fformat%2Cf_auto%2Fquality%2Cq_80)\n\n5、把插件直接拖拽到浏览器的空白处。\n\n![](http://exp-picture.cdn.bcebos.com/777f3fc2bbd6e1d0d39db3db0d254193cfe8afd3.jpg?x-bce-process=image%2Fcrop%2Cx_0%2Cy_0%2Cw_1920%2Ch_1023%2Fformat%2Cf_auto%2Fquality%2Cq_80)\n\n6、点击“添加扩展程序”。\n\n![](http://exp-picture.cdn.bcebos.com/1562a0b9763e21c207a3c86ae6e89a618725b1d3.jpg?x-bce-process=image%2Fcrop%2Cx_0%2Cy_0%2Cw_1920%2Ch_1023%2Fformat%2Cf_auto%2Fquality%2Cq_80)\n\n7、如图所示，这就是添加成功的样子。\n\n![](http://exp-picture.cdn.bcebos.com/bff8683e21c2bbd65ca54452116186254093aed3.jpg?x-bce-process=image%2Fcrop%2Cx_0%2Cy_0%2Cw_1920%2Ch_1023%2Fformat%2Cf_auto%2Fquality%2Cq_80)\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/tool/浏览器插件.md"}},{"pageContent":"# 谷歌浏览器\n\n## 首先 我们先下载谷歌\n\n<a href=\"https://www.google.cn/intl/zh-CN/chrome/\" target=\"_blank\">谷歌浏览器官网下载地址</a>\n\n## 常见的浏览器\n\n浏览器是网页运行的平台，常见的浏览器有谷歌（Chrome）、Safari、火狐（Firefox）、IE、Edge、Opera 等。如下图所示：\n\n![](http://img.smyhvae.com/20191204_1900.png)\n\n我们重点需要学习的是 Chrome 浏览器。\n\n## 浏览器的市场占有份额\n\n浏览器的市场占有份额：[https://tongji.baidu.com/research/site?source=index#browser](https://tongji.baidu.com/research/site?source=index#browser)\n\n![](http://img.smyhvae.com/20200322_1058.png)\n\n上面这张图的统计时间是 2020 年 2 月。\n\n## 浏览器的组成\n\n浏览器分成两部分：\n\n- 1、渲染引擎（即：浏览器内核）\n- 2、JS 引擎\n\n### 1、渲染引擎（浏览器内核）\n\n浏览器所采用的「渲染引擎」也称之为「浏览器内核」，用于解析 HTML 和 CSS、布局、渲染等工作。渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。\n\n**渲染引擎是浏览器兼容性问题出现的根本原因。**\n\n渲染引擎的英文叫做 Rendering Engine。通俗来说，它的作用就是：读取网页内容，计算网页的显示方式并显示在页面上。\n\n常见浏览器的内核如下：\n\n|     浏览器     |  内核   |\n| :------------: | :-----: |\n|     chrome     |  Blink  |\n|      欧鹏      |  Blink  |\n| 360 安全浏览器 |  Blink  |\n| 360 极速浏览器 |  Blink  |\n|     Safari     | Webkit  |\n|  Firefox 火狐  |  Gecko  |\n|       IE       | Trident |\n\n备注：360 的浏览器，以前使用的 IE 浏览器的 Trident 内核，但是现在已经改为使用 chrome 浏览器的 Blink 内核。\n\n另外，移动端的浏览器内核是什么？大家可以自行查阅资料。\n\n### 2、JS 引擎\n\n也称为 JS 解释器。 用来解析和执行网页中的 JavaScript 代码。\n\n浏览器本身并不会执行 JS 代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时会逐行解释每一句源码，转换为机器语言，然后由计算机去执行。\n\n常见浏览器的 JS 引擎如下：\n\n|        浏览器        | JS 引擎                                                                         |\n| :------------------: | :------------------------------------------------------------------------------ |\n|     chrome、欧鹏     | V8                                                                              |\n| Mozilla Firefox 火狐 | SpiderMonkey（1.0-3.0）/ TraceMonkey（3.5-3.6）/ JaegerMonkey（4.0-）           |\n|        Safari        | JavaScriptCore，也称为 Nitro，是 WebKit 引擎的一部分                            |\n|          IE          | Trident                                                                         |\n|         Edge         | Chakra。此外，ChakraCore 是 Chakra 的开源版本，可以在不同的平台上使用。         |\n|        Opera         | Linear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-） |\n\n补充说明：\n\n1、SpiderMonkey 是第一款 JavaScript 引擎，由 JS 语言的作者 Brendan Eich 开发。\n\n2、先以 WebKit 为例，WebKit 上由两部分组成：\n\n- WebCore：负责解析 HTML 和 CSS、布局、渲染等工作。\n- JavaScriptCore：负责解析和执行 JavaScript 代码。\n\n参考链接：\n\n- [主流浏览器内核及 JS 引擎](https://juejin.im/post/5ada727c518825670b33a584)\n\n## 浏览器工作原理\n\n> 这一小段有些深入，小白可以暂时跳过，以后学习 JS 的时候再回来看。\n\n浏览器主要由下面这个七个部分组成：\n\n![](http://img.smyhvae.com/20180124_1700.png)\n\n1、User Interface（UI 界面）：包括地址栏、前进/后退按钮、书签菜单等。也就是浏览器主窗口之外的其他部分。\n\n2、Browser engine （浏览器引擎）：用来查询和操作渲染引擎。是 UI 界面和渲染引擎之间的**桥梁**。\n\n3、Rendering engine（渲染引擎）：用于解析 HTML 和 CSS，并将解析后的内容显示在浏览器上。\n\n4、Networking （网络模块）：用于发送网络请求。\n\n5、JavaScript Interpreter（JavaScript 解析器）：用于解析和执行 JavaScript 代码。\n\n6、UI Backend（UI 后端）：用于绘制组合框、弹窗等窗口小组件。它会调用操作系统的 UI 方法。\n\n7、Data Persistence（数据存储模块）：比如数据存储 cookie、HTML5 中的 localStorage、sessionStorage。\n\n参考链接：（关于浏览器的工作管理，下面这篇文章，是精品中的精品，是必须要知道的）\n\n- 英文版：[How Browsers Work: Behind the scenes of modern web browsers](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/)\n- 中文版：[浏览器的工作原理：新式网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)\n\n## 为什么选择谷歌浏览器(浏览器内核详解)\n\n首先给出答案，因为大多浏览器使用的都是 webkit 内核，我们为了代码能兼容更多的平台，所以有限选择谷歌浏览器\n\n<img src='https://pic3.zhimg.com/v2-f464eaf0dc47177ef67649c1c1eb6e22_r.jpg'>\n\n- **IE/Edge：**微软的 IE 浏览器浏览器更新至 IE10 后，伴随着 WIN10 系统的上市，迁移到了全新的浏览器 Edge。除了 JS 引擎沿用之前 IE9 就开始使用的查克拉(Chakra)，渲染引擎使用了新的内核 EdgeHTML（本质上不是对 Trident 的完全推翻重建，而是在 Trident 基础上删除了过时的旧技术支持的代码，扩展和优化了对新的技术的支持，所以被看做是全新的内核）\n- **Safari**：Safari 自 2003 年面世，就一直是苹果公司的产品自带的浏览器，它使用的是苹果研发和开源的 Webkit 引擎。Webkit 引擎包含 WebCore[排版引擎](https://zhida.zhihu.com/search?content_id=110303645&content_type=Article&match_order=1&q=排版引擎&zhida_source=entity)及 JavaScriptCore[解析引擎](https://zhida.zhihu.com/search?content_id=110303645&content_type=Article&match_order=1&q=解析引擎&zhida_source=entity)，均是从 KDE 的 KHTML 及 KJS 引擎衍生而来。Webkit2 发布于 2010 年，它实现了元件的抽象画，提高了元件的重复利用效率，提供了更加干净的网页渲染和更高效的渲染效率。另外，Webkit 也是苹果 Mac OS X 系统引擎框架版本的名称，主要用于 Safari、Dashboard、Mail。\n- **Chrome**：提到 Chrome 浏览器，一般人会认为使用的 Webkit 内核，这种说法不完全准确。Chrome 发布于 2008 年，使用的渲染内核是 Chromium，它是 fork 自 Webkit，但把 Webkit 梳理得更有条理可读性更高，效率提升明显。2013 年，由于 Webkit2 和 Chromium 在沙箱设计上的冲突，谷歌联手 Opera 自研和发布了 Blink 引擎，逐步脱离了 Webkit 的影响。所以，可以这么认为：Chromium 扩展自 Webkit 止于 Webkit2，其后 Chrome 切换到了 Blink 引擎。另外，Chrome 的 JS 引擎使用的 V8 引擎，应该算是最著名和优秀的开源 JS 引擎，大名鼎鼎的 Node.js 就是选用 V8 作为底层架构。\n- **Firefox**：火狐的内核 Gecko 也是[开源引擎](https://zhida.zhihu.com/search?content_id=110303645&content_type=Article&match_order=1&q=开源引擎&zhida_source=entity)，任何程序员都能为其提供扩展和建议。火狐的 JS 引擎历经 SpiderMonkey、TraceMonkey 到现在的 JaegerMonkey。其中 JaegerMonkey 部分技术借鉴了 V8、JSCore 和 Webkit，算是集思广益。\n- **Opera**：Opera 在 2013 年 V12.16 之前使用的是 Opera Software 公司开发的 Presto 引擎，之后连同谷歌研发和选择 Blink 作为 Opera 浏览器的排版内核。\n\n## 国内浏览器情况\n\n> 国内浏览器厂商（QQ、2345、搜狗、猎豹、UC、360）也有一定的市场占有率。且大多数为双核\n\n### 总结国内厂商内核来看，一般为三类：\n\n一、使用的 Trident 单核，如：2345、[世界之窗](https://zhida.zhihu.com/search?content_id=110303645&content_type=Article&match_order=1&q=世界之窗&zhida_source=entity)；\n二、使用 Trident+Webkit/Blink 双核，如：qq、UC、猎豹、360、百度；\n三、使用 Webkit/Blink 单核，如：搜狗、[遨游](https://zhida.zhihu.com/search?content_id=110303645&content_type=Article&match_order=1&q=遨游&zhida_source=entity)。\n\n双核浏览器通过 WebKit 内核来访问一些不需要进行网上交易的网站，使用起来速度更快更方便;[双核浏览器](https://zhida.zhihu.com/search?content_id=110303645&content_type=Article&match_order=2&q=双核浏览器&zhida_source=entity)在进行支付系统或者是网上银行的访问时，则使用的是 Trident 内核。这就是双核浏览器的高速模式和兼容模式。双核浏览器是一个不仅仅具有 ie 浏览器内核同时兼容非 ie 浏览器内核的浏览器，可以让用户在浏览器当中体验不同的需求\n\n## 浏览器内核技术\n\n浏览器内核主要包括以下三个技术分支：排版渲染引擎、 JavaScript 引擎，以及其他。\n\n微软对排版渲染引擎相关专利的申请最多，达到浏览器内核相关专利申请总量的 93.3%。这与排版渲染引擎的功能密不可分。其主要负责取得网页的内容(HTML、XML、图像等)、整理信息，以及计算网页的显示方式，然后输出至显示器。所有的网页浏览器、[电子邮件客户端](https://zhida.zhihu.com/search?content_id=110303645&content_type=Article&match_order=1&q=电子邮件客户端&zhida_source=entity)以及其他需要编辑、显示网络内容的应用程序都需要排版渲染引擎，特别是排版渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。由于在网页显示中所起的重要作用，微软一直侧重于涉及排版渲染引擎的专利申请。在 2006 年和 2009 年，配新版本的研发带来了排版渲染引擎专利申请量的顶峰这充分显示了微软在新版本的改进中对浏览器排版渲染引擎技术的重视。\n\nJavaScript 引擎是用来渲染 JavaScript 的，JavaScript 的渲染速度越快，动态网页的展示也越快。众所周知，微软的 IE 浏览器实现完全支持客户端 JavaScript 语言标准的时间晚于其他浏览器。因此，在这一技术分支下，相较其他浏览器企业而言，微软公司并不具有优势。在 2001~2004 年，在浏览器内核技术分支下，微软的中国专利申请量并不多，方面是由于内核为开放内核，另一方面则是由于 IE 本身一直与 Windows 捆绑销售，使得 Trident 内核长期一家独大，微软很长时间都没有更新 Trident 内核，从而导致 Trident 内核几乎与 W3C 标准脱节。\n\n2005 年至今，由于 IE 浏览器存在缺陷，从而使得很多用户转向其他浏览器。微软公司显然注意到了这一点，逐步重视浏览器内核的改进升级，并将由此带来的相关专利在中国进行了布局。最明显的是，2006 年和 2009 年的专利申请量大幅上升，其中关于浏览器内核中排版渲染引擎的专利申请均达到了 17 件；在 2008 年还有一件关于 JavaScript 引擎的专利申请，以上均表明 I 内核在 2005 年之后有了明显改进\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/guid/tool/谷歌浏览器.md"}},{"pageContent":"# Markdown & MDX\n\n# HI\n\n欢迎来到我的`blog`，我是一个`前端仔`，这里是用来记录、学习、分享的 😏。\n\n目前点亮`工程化`,`rust`,`vite`,`react`,`vue`,`sql`，`electron`，`webpack`等一些技能树。（爱你 ~~😘）；\n\n前端技术\n- 基于`rspress`进行静态站点生成的\n- 此项目使用`wpa`实现 web 离线缓存应用\n- 使用`turbo`,合并`blog`和配套的`tauri`图床应用项目\n- `turbo`打开项目和打包对于CI/CD的构筑是真滴快😏\n- 使用`pnpm`的`monorepo`进行包管理\n- 引入`ant-design`,`tailwind`,`styled-components`,\n- 动画小人是使用`oh-my-live2d`配合书写项目的插件进行引用的\n\n\n服务端\n- 使用`docker`+`jenkins`+`nginx`集成`CI\\CD`工作流\n- 利用`github`的`webhook`实现绝赞的自动更新\n\n[![Readme Card](https://github-readme-stats.vercel.app/api/pin/?username=Manshawar&repo=Manshawar-cyber)](https://github.com/Manshawar/Manshawar-cyber.git)\n\n\n\n从`koa`搭建`vite`之后，整体的风格会更加偏向随笔\n\n🔥/💦\n\n# 计划列表 \n\n| flag   | 完成情况       |\n| ----  | ---------- |\n| 书写插件，生成JSON训练集  | 🔥  |\n| 书写脚手架并入工具模板cac   | 🔥 |\n| 整理vite的cdn插件   | 💦  |\n| 整理tsup开发rsbuild rspack插件规范   | 💦  |\n| 整理开发webcomponet组件自动引入repress   | 💦  |\n| 整理大文件切片上传和并发操作     | 💦  |\n| 整理vue-plugin以及相关分析插件源码    | 💦  |\n| 整理云服务docker和jenkins配合webHooks做CI/CD   | 💦  |\n| 整理ant-design和tauri记录    | 💦  |\n\n\n这里是我的 github 地址\n\n[![](https://img.shields.io/badge/dynamic/json?color=000000&label=GitHub&query=%24.data.totalSubs&suffix=%20followers&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dgithub%26queryKey%3DManshawar)](https://github.com/Manshawar)\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/index.mdx"}},{"pageContent":"import Diff from \"@/page/baseScript/diff\";\n\n# diff \n我们先看看简化版本，它并没有处理递归和更新 \n\n<img src=\"https://ik.imagekit.io/Manshawar/ferris_Ry3QHhKSw\" />\n\n<Diff />\n\n\n```ts\n\n  // 定义虚拟节点接口\n  interface VNode {\n    type: string;\n    props: Record<string, any>;\n    children: VNode[];\n    key?: string | number;\n  }\n\n  // 定义补丁操作的几种类型\n  type Patch =\n    | { type: \"REPLACE\"; newNode: VNode }\n    | { type: \"UPDATE_PROPS\"; props: Record<string, any> }\n    | { type: \"REORDER\"; moves: (MoveAction | null)[] }\n    | { type: \"TEXT\"; content: string };\n\n  type MoveAction =\n    | { type: \"INSERT\"; node: VNode; index: number }\n    | { type: \"REMOVE\"; index: number };\n\n  // 核心diff算法\n  function diff(oldNode: VNode, newNode: VNode): Patch[] {\n    const patches: Patch[] = [];\n\n    // 1. 类型不同直接替换\n    if (oldNode.type !== newNode.type) {\n      patches.push({ type: \"REPLACE\", newNode });\n      return patches;\n    }\n\n    // 2. 比较属性差异\n    const propPatches = diffProps(oldNode.props, newNode.props);\n    if (propPatches) {\n      patches.push({ type: \"UPDATE_PROPS\", props: propPatches });\n    }\n\n    // 3. 比较子节点差异\n    const childPatches = diffChildren(oldNode.children, newNode.children);\n    console.log(\"childPatches\", childPatches);\n    if (childPatches.length > 0) {\n      patches.push({ type: \"REORDER\", moves: childPatches });\n    }\n\n    return patches;\n  }\n\n  // 比较属性差异\n  function diffProps(\n    oldProps: Record<string, any>,\n    newProps: Record<string, any>\n  ): Record<string, any> | null {\n    const patches: Record<string, any> = {};\n    let hasChanges = false;\n\n    // 找出变化的属性\n    for (const key in newProps) {\n      if (newProps[key] !== oldProps[key]) {\n        patches[key] = newProps[key];\n        hasChanges = true;\n      }\n    }\n\n    // 找出被删除的属性\n    for (const key in oldProps) {\n      if (!(key in newProps)) {\n        patches[key] = undefined;\n        hasChanges = true;\n      }\n    }\n\n    return hasChanges ? patches : null;\n  }\n\n  // 比较子节点差异（简化版）\n  function diffChildren(oldChildren: VNode[], newChildren: VNode[]): (MoveAction | null)[] {\n    const moves: (MoveAction | null)[] = [];\n    const oldMap: Record<string | number, VNode> = {};\n    const newMap: Record<string | number, VNode> = {};\n\n    // 创建key映射表\n    oldChildren.forEach((child, index) => {\n      const key = child.props.key ?? index;\n      oldMap[key] = child;\n    });\n\n    newChildren.forEach((child, index) => {\n      const key = child.props.key ?? index;\n      newMap[key] = child;\n    });\n\n    // 找出需要删除的节点\n    oldChildren.forEach((child, index) => {\n      const key = child.props.key ?? index;\n      if (!newMap[key]) {\n        moves.push({ type: \"REMOVE\", index });\n      }\n    });\n\n    // 找出需要新增/移动的节点\n    newChildren.forEach((child, newIndex) => {\n      const key = child.props.key ?? newIndex;\n      const oldIndex = oldChildren.find(c => (c.props.key ?? c) === key);\n\n      if (!oldIndex) {\n        moves.push({ type: \"INSERT\", node: child, index: newIndex });\n      } else if (oldIndex.props.key !== key) {\n        // 这里简化处理，实际需要更复杂的移动逻辑\n        moves.push({ type: \"INSERT\", node: child, index: newIndex });\n      }\n       // else if(oldIndex.props.key !== key&&oldIndex!==newIndex) 这里简化处理，实际需要更复杂的移动逻辑\n    });\n\n    return moves;\n  }\n\n  // 使用示例\n  const oldVNode: VNode = {\n    type: \"div\",\n    props: { className: \"container\" },\n    children: [\n      { type: \"p\", props: { key: 1 }, children: [] },\n      { type: \"span\", props: { key: 2 }, children: [] },\n    ],\n  };\n\n  const newVNode: VNode = {\n    type: \"div\",\n    props: { className: \"wrapper\" },\n    children: [\n      { type: \"span\", props: { key: 2 }, children: [] },\n      { type: \"input\", props: { key: 3 }, children: [] },\n    ],\n  };\n\n  const patches = diff(oldVNode, newVNode);\n  console.log(patches);\n\n```\n\n\n这里是完整的diff算法\n```ts\ninterface VNode {\n  type: string | Function; // 支持组件\n  props: Record<string, any>;\n  children: VNode[];\n  key?: string | number;\n  el?: HTMLElement; // 关联的真实DOM\n}\n\ntype Patch = \n  | { type: 'REPLACE'; newNode: VNode }\n  | { type: 'UPDATE_PROPS'; patches: PropPatch[] }\n  | { type: 'REORDER'; moves: MoveAction[] }\n  | { type: 'TEXT'; content: string };\n\ntype PropPatch = \n  | { op: 'set'; key: string; value: any }\n  | { op: 'remove'; key: string };\n\ntype MoveAction = \n  | { type: 'INSERT'; node: VNode; afterKey?: string | number }\n  | { type: 'MOVE'; fromKey: string | number; toKey: string | number }\n  | { type: 'REMOVE'; key: string | number };\n\n// 优化后的diff算法\nfunction diff(oldNode: VNode, newNode: VNode): Patch[] {\n  const patches: Patch[] = [];\n\n  // 1. 节点类型不同直接替换\n  if (oldNode.type !== newNode.type) {\n    return [{ type: 'REPLACE', newNode }];\n  }\n\n  // 2. 比较属性差异（优化后的实现）\n  const propPatches = diffProps(oldNode.props, newNode.props);\n  if (propPatches.length > 0) {\n    patches.push({ type: 'UPDATE_PROPS', patches: propPatches });\n  }\n\n  // 3. 处理文本节点（新增优化）\n  if (typeof oldNode.children[0]?.type === 'string' && \n      typeof newNode.children[0]?.type === 'string') {\n    if (oldNode.children[0] !== newNode.children[0]) {\n      patches.push({ \n        type: 'TEXT', \n        content: newNode.children[0].props.nodeValue \n      });\n    }\n    return patches;\n  }\n\n  // 4. 优化后的子节点diff\n  const childPatches = diffChildren(oldNode.children, newNode.children);\n  if (childPatches.length > 0) {\n    patches.push({ type: 'REORDER', moves: childPatches });\n  }\n\n  return patches;\n}\n\n// 优化后的属性比较（支持事件处理）\nfunction diffProps(oldProps: Record<string, any>, newProps: Record<string, any>): PropPatch[] {\n  const patches: PropPatch[] = [];\n  const allKeys = new Set([...Object.keys(oldProps), ...Object.keys(newProps)]);\n\n  allKeys.forEach(key => {\n    // 跳过children属性\n    if (key === 'children') return;\n\n    const oldVal = oldProps[key];\n    const newVal = newProps[key];\n\n    // 事件处理优化（以on开头的属性）\n    if (key.startsWith('on')) {\n      if (oldVal !== newVal) {\n        patches.push({ op: 'remove', key });\n        patches.push({ op: 'set', key, value: newVal });\n      }\n      return;\n    }\n\n    if (!newProps.hasOwnProperty(key)) {\n      patches.push({ op: 'remove', key });\n    } else if (oldVal !== newVal) {\n      patches.push({ op: 'set', key, value: newVal });\n    }\n  });\n\n  return patches;\n}\n\n// 优化后的子节点diff（双指针算法）\nfunction diffChildren(oldChildren: VNode[], newChildren: VNode[]): MoveAction[] {\n  const moves: MoveAction[] = [];\n  const keyIndexMap: Map<string | number, number> = new Map();\n  const newKeyMap: Map<string | number, VNode> = new Map();\n\n  // 构建旧节点的key索引\n  oldChildren.forEach((child, index) => {\n    const key = child.key ?? index;\n    keyIndexMap.set(key, index);\n  });\n\n  // 构建新节点key映射\n  newChildren.forEach(child => {\n    const key = child.key ?? Symbol();\n    newKeyMap.set(key, child);\n  });\n\n  let lastIndex = 0;\n  const newChildrenWithKey = newChildren.map((child, index) => ({\n    key: child.key ?? index,\n    node: child,\n    index\n  }));\n\n  // 第一轮遍历：处理已有节点的移动\n  newChildrenWithKey.forEach(({ key, node, index: newIndex }) => {\n    const oldIndex = keyIndexMap.get(key);\n    \n    if (oldIndex === undefined) {\n      // 新增节点\n      moves.push({ \n        type: 'INSERT', \n        node,\n        afterKey: newChildrenWithKey[newIndex - 1]?.key \n      });\n    } else {\n      // 需要移动的节点\n      if (oldIndex < lastIndex) {\n        moves.push({\n          type: 'MOVE',\n          fromKey: key,\n          toKey: newChildrenWithKey[newIndex - 1]?.key\n        });\n      }\n      lastIndex = Math.max(oldIndex, lastIndex);\n    }\n  });\n\n  // 第二轮遍历：处理需要删除的节点\n  oldChildren.forEach(oldChild => {\n    const key = oldChild.key ?? Symbol();\n    if (!newKeyMap.has(key)) {\n      moves.push({ type: 'REMOVE', key });\n    }\n  });\n\n  return moves;\n}\n\n// 新增：应用补丁到真实DOM\nfunction applyPatch(el: HTMLElement, patches: Patch[]) {\n  patches.forEach(patch => {\n    switch (patch.type) {\n      case 'REPLACE':\n        const newEl = createElement(patch.newNode);\n        el.parentNode?.replaceChild(newEl, el);\n        break;\n        \n      case 'UPDATE_PROPS':\n        patch.patches.forEach(propPatch => {\n          if (propPatch.op === 'set') {\n            if (propPatch.key.startsWith('on')) {\n              // 事件处理\n              const eventType = propPatch.key.slice(2).toLowerCase();\n              el.addEventListener(eventType, propPatch.value);\n            } else {\n              el.setAttribute(propPatch.key, propPatch.value);\n            }\n          } else {\n            el.removeAttribute(propPatch.key);\n          }\n        });\n        break;\n        \n      case 'REORDER':\n        const fragment = document.createDocumentFragment();\n        patch.moves.forEach(move => {\n          // 实际DOM操作需要根据key查找对应节点\n          // 这里简化处理，实际需要维护key与DOM的映射\n        });\n        el.appendChild(fragment);\n        break;\n        \n      case 'TEXT':\n        el.textContent = patch.content;\n        break;\n    }\n  });\n}\n\n// 虚拟DOM创建函数（示例）\nfunction createElement(vnode: VNode): HTMLElement {\n  // 实际实现需要处理组件等情况\n  const el = document.createElement(vnode.type as string);\n  // 应用props和children...\n  return el;\n}\n\n```","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/js/diff.mdx"}},{"pageContent":"# 迷宫生成\n\n## 1、生成数组\n\n首先，设置一个储存宽高的数组，名称rect,将这个储存宽高的数组，可以通过x*y得出所有内部分割方块的坐标；\n\n```js\n    let rect = [5, 5];\n    let side = 495 / 5;\n    let arr = Array.from({ length: rect[0] }, (_, x) => {\n      return Array.from({ length: rect[1] }, (_, y) => {\n        return {\n          visited: false,\n          axis: [x, y],\n          path: [true, true, true, true]\n        }\n      })\n    })\n```\n\n通过Array.from 设置类数组对象转化为多维数组，以此得到每一个位置的坐标\n\n## 2、编辑canvas绘画方法\n\n```js\n let myCanvas = document.getElementById(\"myCanvas\");\n    let ctx = myCanvas.getContext(\"2d\");\n    let draw = {\n      top ([x, y]) {\n        ctx.moveTo(x * side, y * side);\n        ctx.lineTo((x + 1) * side, y * side);\n        ctx.stroke();\n      },\n      right ([x, y]) {\n        ctx.moveTo((x + 1) * side, y * side);\n        ctx.lineTo((x + 1) * side, (y + 1) * side);\n        ctx.stroke();\n      },\n      bottom ([x, y]) {\n        ctx.moveTo((x + 1) * side, (y + 1) * side);\n        ctx.lineTo((x) * side, (y + 1) * side);\n        ctx.stroke();\n      },\n      left ([x, y]) {\n        ctx.moveTo((x) * side, (y + 1) * side);\n        ctx.lineTo((x) * side, (y) * side);\n        ctx.stroke();\n      }\n    }\n    \n     arr.forEach(arrIndex => {\n      arrIndex.forEach(item => {\n\n        if (item.path[0]) draw.top(item.axis)\n        if (item.path[1]) draw.right(item.axis)\n        if (item.path[2]) draw.bottom(item.axis)\n        if (item.path[3]) draw.left(item.axis)\n      })\n    })\n```\n\n获取canvas，思路是通过对每一个分割出来的方块画出其边长，形成一个x*y的宫格，然后对其拆除墙体，实现迷宫\n\n画出方块的对象方法，是根据上右下左来进行书写的,最后通过两轮循环，对所有的位置进行绘画。path 如果为false就代表不需要绘画，path数据初始化为[true,true,true,true],后续对其进行修改，以做到分割单元格的目的\n\n## 3、进行迷宫生成\n\n1. 我们找到当前位置的四个的相邻元素\n\n2. 相邻元素是否可以访问，是否没有被遍历过\n\n3. 如果没有被遍历过，就作为可访问数组来确定下一次走到的位置，\n\n4. 将走到的位置加入stack内，我们不停的遍历入栈后这个元素的所有边\n\n5. 可以形成一条通路到最后一个元素\n\n   \n\n###  3-1、设置初始位置\n\n我们选择[0,0]作为初始位置开始生成\n\n```js\n    let current = { axis: [0, 0], dir: undefined };\n      arr[0][0].visited = true;\n```\n\n### 3-2、寻找可选方向\n\n寻找四个方向，如果到墙壁就返回，如果被访问过的也返回，我们的目的是将所有没有返回过的数组进行操作，并记录他相对于初始位置的方向，便于消除墙壁\n\n```js\n    function find_position ([x, y], dir) {\n\n      switch (dir) {\n        case 0:\n          if (y - 1 < 0) return\n          if (arr[x][y - 1].visited) return\n          return { axis: [x, y - 1], dir }\n        case 1:\n          if (x + 1 >= rect[0]) return\n          if (arr[x + 1][y].visited) return\n          return { axis: [x + 1, y], dir }\n        case 2:\n          if (y + 1 >= rect[1]) return\n          if (arr[x][y + 1].visited) return\n          return { axis: [x, y + 1], dir }\n        case 3:\n          if (x - 1 < 0) return\n          if (arr[x - 1][y].visited) return\n          return { axis: [x - 1, y], dir }\n      }\n    }\n```\n\n### 3-3、将可选方向作为数组返回\n\n[0,1,2,3]分别对应上右下左,存在能进行下一步操作的元素才进行收集\n\n```js\n    function find_neighbor ([x, y]) {\n      let res = []\n      let top = find_position([x, y], 0);\n      let right = find_position([x, y], 1);\n      let bottom = find_position([x, y], 2);\n      let left = find_position([x, y], 3);\n      if (top) res.push(top);\n      if (right) res.push(right);\n      if (bottom) res.push(bottom);\n      if (left) res.push(left);\n      return res\n    }\n```\n\n### 3-4、随机当前元素的可选地址于上一个元素的墙壁进行联通\n\n```js\n       let random = Math.floor(Math.random() * find_res.length);\n        clear_rect(current, find_res[random]);\n```\n\n消除墙壁,当下一个元素和当前元素的墙壁消掉后，将其可访问值设置为true，使其下一次不会被选中\n\n```js\n    function clear_rect (now_pos, next_pos) {\n      let now = arr[now_pos.axis[0]][now_pos.axis[1]];\n\n      let next = arr[next_pos.axis[0]][next_pos.axis[1]];\n      next.visited = true\n\n      switch (next_pos.dir) {\n        case 0:\n          next.path[2] = false\n          now.path[0] = false;\n          break;\n        case 1:\n          next.path[3] = false;\n          now.path[1] = false;\n          break;\n        case 2:\n          now.path[2] = false;\n          next.path[0] = false\n          break;\n        case 3:\n          next.path[1] = false;\n          now.path[3] = false;\n          break;\n      }\n```\n\n### 3-5、使用堆栈对其进行遍历\n\n```js\n    function create_maze (arr) {\n      let current = { axis: [0, 0], dir: undefined };\n      arr[0][0].visited = true;\n      let stack = [current]\n      while (stack.length > 0) {\n        let find_res = find_neighbor(current.axis);\n        if (find_res.length > 0) {\n\n          let random = Math.floor(Math.random() * find_res.length);\n          clear_rect(current, find_res[random]);\n\n          current = find_res[random];\n          stack.push(current);\n        } else {\n          current = stack.pop()\n        }\n      }\n\n    }\n```\n\n设置一个初始位置为初始栈，只要当前栈还有可选位置元素，就会对当前位置进行四个边的查找，没有对应的元素就会让其退出栈，直到所有元素都被访问过，才会退出循环，我们查找到下一次的边如果还存在可选边就会将其加入栈内，如果随机到一个位置恰好四个边都被访问，但还没有完全遍历整个迷宫，我们就会将其出栈，使其作为新的可选位置元素，使用pop出栈，他会从最后一位元素开始重新查找","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/js/js迷宫.md"}},{"pageContent":"函数顺序\n\nsubmit >commentsObject>createEle>render 返回对象，=>bindEvent\n\n### 1、提交事件\n\n使用 submit()函数进行提交\n\n绑定在提交按钮和键盘的ENTER键位上\n\n#### 1-1 submit做了什么\n\nsubmit事件\n\n1. 判断文本是否为空，如果为空，则不进行后续操作\n2. 生成id，这个函数是生成的时间戳，具有唯一性\n3. 创建一个对象，commentsObject是一个构造函数，返回一个对象\n4. render进行渲染操作\n5. rander返回的对象，是我们需要操作的dom对象\n6. commentsArr对于数据层，做一个保存数据的数组\n7. bindEvent这个是对于需要操作的dom绑定事件\n8.  domArr.push(domObj) 这个生成一个dom数组，这个是方便做全选操作\n9.  clearHandler()清除添加完成后的副作用，比如文本清空\n\n```javascript\n    function submit (e) {\n      if (!commentStr.trim()) return\n      let id = new Date().getTime()\n      let item = commentsObject(commentStr, getData(), id)//生成一个对象，构造函数\n \n      let domObj = render(item, id)//渲染dom,返回一个对像，包含所有我们以后需要操作的dom\n      commentsArr.push(item);//评论添加到数据数组中，这个数组的作用 可以发给后端\n      bindEvent(domObj)//绑定事件\n      domArr.push(domObj)//添加一个数组，这个数组收集的是，我们所有的需要操作dom\n      clearHandler()//清除副作用，每一个我们完成操作后，需要将输入框数据清空，并且我们收集的commentStr也需要重置。\n    }\n```\n\n### 2-1commentsObject 构造函数\n\n```javascript\n  function commentsObject (text, time, id, name = \"张三\",) {\n      let obj = {};\n      obj.name = name;\n      obj.text = text;\n      obj.time = time;\n      obj.id = id\n      return obj;\n    }\nname=\"张三\"是一个默认值，他的作用，是在于每一次我们不传入name，自动生成\n```\n\n这个函数的本质，是一个构造函数，说通俗点，就是根据参数生成一个对象，免去每一次，我们都要重新的书写对象。减少重复书写对象的大量文本，有兴趣同学，可以看一下new 运算符\n\n### 2-2 createEle生成dom的工具函数\n\n他的作用：生成一个dom对象，并且返回一个它，他接受三个参数，都是string类型，\n\n- tag 创建dom的标签\n- className 创建dom的class类名\n- text 创建dom的innerHTML文本\n- ele是返回由参数创建的对象\n\n```javascript\n   function createEle (tag, className = \"\", text = \"\") {\n      let ele = document.createElement(tag);\n\n      ele.className = className;\n      if (text) ele.innerHTML = text;\n      return ele\n    }\n```\n\n\n\n### 2-3 render dom生成函数\n\narr数组，他的目的是在一个循环中，生成我们想要的dom对象\n\n1. forEach循环，每一次循环的过程中，会创建3个p标签的dom，本质上 相当于下面的不停的创建createDom，然后在appendChild到父元素中，循环的顺序，你可以用if判断，在中间插入dom，我们再这个text文本创建的后面，添加了input，最终决定顺序的是appendChild的插入顺序，我们这个是添加在text的dom之前的\n2. 如果理解有困难，则全部使用createDom和appendChild重构，这个commentDomObj对象，主要收集的是，我们传入数据和input文本修改框生成的dom\n3. 下文就是不停的创建dom，不停的插入dom。每一个dom的顺序和位置，是由appendChild的顺序决定的\n\n```javascript\n    function render (obj, id) {\n        //建议可以看一下Object.keys 和Object.value 然后尝试改写下面这个循环\n      let arr = [\n        \"name\", \"text\", \"time\"\n      ] //3个对象的属性名称\n      let info = createEle(\"div\", 'info');//创建info标签和类名\n      let commentDomObj = {}//收集我们创建评论的dom，放在一个对象中，方便进行管理\n      //循环创建重复dom,需要的展示文本\n      arr.forEach((item) => {\n        let ele = createEle(\"p\", item, obj[item])//创建dom函数，返回值是当前创建的dom\n        if (item === \"text\") {\n          let input = createEle(\"input\", \"hidden\");\n          info.appendChild(input)\n          commentDomObj[\"input\"] = input\n        }\n        commentDomObj[item] = ele;\n        info.appendChild(ele);\n      })\n\n      let item = createEle(\"div\", 'item');\n      let menu = createEle(\"div\", \"menu\");\n      let leftTool = createEle(\"div\", \"leftTool\");\n      let checkbox = createEle(\"input\", \"listCheckbox\");//选择框\n      checkbox.type = \"checkbox\";//选择框\n      let del = createEle('div', \"del\", \"删除\");\n      //删除按钮\n      leftTool.appendChild(checkbox)\n      menu.appendChild(del)\n      item.appendChild(leftTool);\n      item.appendChild(info);\n      item.appendChild(menu);\n\n      document.querySelector(\".list\").appendChild(item)//将我们生成的dom添加到list类下面\n      return {\n        ...commentDomObj, del: del, checkbox, id: id\n      }\n    }\n```\n\n### 3-1绑定事件\n\nbindEvent(dom对象)专门用于绑定所有的事件\n\n```javascript\n    function bindEvent (domObj) {\n      //双击打开文本框事件\n      domObj.text.ondblclick = function (e) {\n        let textDom = domObj.text;\n        //input框\n        let inputDom = domObj.input;\n        //toggle,如果有class就删除，没有就添加\n        textDom.classList.toggle('hidden');\n        inputDom.classList.toggle(\"hidden\");\n        //让input文本框的值，等于当前评论的文本\n        inputDom.value = textDom.innerHTML\n        //input显示出来后，自动聚焦\n        inputDom.focus();\n      }\n      //失去焦点保存事件\n      domObj.input.onblur = function (e) {\n        let textDom = domObj.text;\n        let inputDom = domObj.input;\n        let timeDom = domObj.time;\n        textDom.classList.toggle('hidden');\n        inputDom.classList.toggle(\"hidden\");\n        let time = getData()//获取时间\n        //修改收集数据数组的值\n        let index = commentsArr.findIndex(item => item.id === domObj.id);\n        commentsArr[index].text = inputDom.value\n        commentsArr[index].time = time;\n        // 修改当前innerHTML文本\n        textDom.innerHTML = inputDom.value;\n        timeDom.innerHTML = time;\n      }\n      //删除dom事件\n      domObj.del.onclick = function (e) {\n        let index = commentsArr.findIndex(item => item.id === domObj.id);\n        let domIndex = domArr.findIndex(item => item.id === domObj.id);\n        commentsArr.splice(index, 1);\n        domArr.splice(index, 1);\n        e.target.parentElement.parentElement.remove()\n      }\n      domObj.checkbox.onchange = function (e) {\n        let checkLength = 0\n        for (let i = 0; i < domArr.length; i++) {\n          const ele = domArr[i];\n          if (ele.checkbox.checked) {\n            checkLength++\n          }\n        }\n        if (checkLength === domArr.length) {\n          allCheckDom.checked = true\n        } else {\n          allCheckDom.checked = false\n        }\n\n      }\n    }\n```\n\n### 3-2双击出现和隐藏修改文本框\n\nondblclick是鼠标左键双击事件\n\n1. 我们通过出传入的dom对象，获取到text文本dom和input输入框dom\n2. 使用classList.toggle（）api实现对隐藏css类的添加，来决定dom是否显示\n3. 显示之后，我们需要使input需要有原来的值，我们使用value属性来设置\n4. 使用focus（）api事件，使input出现后，焦点自动聚焦到输入框\n\n```javascript\n   domObj.text.ondblclick = function (e) {\n        let textDom = domObj.text;\n        //input框\n        let inputDom = domObj.input;\n        //toggle,如果有class就删除，没有就添加\n        textDom.classList.toggle('hidden');\n        inputDom.classList.toggle(\"hidden\");\n        //让input文本框的值，等于当前评论的文本\n        inputDom.value = textDom.innerHTML\n        //input显示出来后，自动聚焦\n        inputDom.focus();\n      }\n```\n\n### 3-3失去焦点后的事件\n\n失去焦点事件，更新事件，切换显示的dom，更新文本，更新收集数据的数组\n\n1. 我们获取相应的dom，然后同toggle对于有hidden的class类名进行删除，没有的则添加\n2. 使用getDate（）更新时间\n3. findIndex接受一个回调，通过每个对象的id是否等于当前dom对象的id ，索引到需要更改的数据对象\n4. 让收集的数组更新文本，更新时间\n5. 页面使用innerHTML进行渲染\n\n```javascript\n   domObj.input.onblur = function (e) {\n        let textDom = domObj.text;\n        let inputDom = domObj.input;\n        let timeDom = domObj.time;\n        textDom.classList.toggle('hidden');\n        inputDom.classList.toggle(\"hidden\");\n        let time = getData()//获取时间\n        //修改收集数据数组的值\n        let index = commentsArr.findIndex(item => item.id === domObj.id);\n        commentsArr[index].text = inputDom.value\n        commentsArr[index].time = time;\n        // 修改当前innerHTML文本\n        textDom.innerHTML = inputDom.value;\n        timeDom.innerHTML = time;\n      }\n```\n\n### 3-4删除dom事件\n\n通过id找到对应的收集数据的数组和dom对象的数组\n\n1. 找到收集数据数组中的对应数据对象\n2. 使用splice将其从数组中移除\n3. 通过e.terget找到父元素的父元素，目的在于找到整个评论对象的dom可以通过打印来看 获取的是什么\n4. 通过removeapi移除\n\n```javascript\n      domObj.del.onclick = function (e) {\n        let index = commentsArr.findIndex(item => item.id === domObj.id);\n        let domIndex = domArr.findIndex(item => item.id === domObj.id);\n        commentsArr.splice(index, 1);\n        domArr.splice(index, 1);\n        e.target.parentElement.parentElement.remove()\n      }\n```\n\n### 3-4全选事件\n\n通过计数的手段，判断选择中的checked值的多少，是否和全部dom数组的长度相等，如果相等，则将全选框dom的checked状态改为true，如果不相等，则将全选框的状态变更为false\n\n1. 设置一个0的数字，对数组的长度进行循环\n2. domArr里面所存放的dom，是会跟着真实的dom发生变化的，它实际上就是页面上存在的dom元素\n3. 判断是否是选中状态，如果是则++ \n4. 将最终长度和所获取checked的dom的元素数量进行对比，如果相等 则全选\n\n外部的全选框事件\n\n1. 我们在render生成dom的时候，就已经将dom数组收集完毕了\n2. 我们再点击全选框后，会使它的checked状态发生变化，我们使用onchange事件去监听它\n3. 如果发生的变化，则将所有dom数组中的checkbox都设置为当前全选框的checked值\n\n```javascript\n//每个dom的选择框事件\ndomObj.checkbox.onchange = function (e) {\n        let checkLength = 0\n        for (let i = 0; i < domArr.length; i++) {\n          const ele = domArr[i];\n          if (ele.checkbox.checked) {\n            checkLength++\n          }\n        }\n    //或者checkLength >= domArr.length\n        if (checkLength === domArr.length) {\n          allCheckDom.checked = true\n        } else {\n          allCheckDom.checked = false\n        }\n\n      }\n\n//外部全选框事件\n allCheckDom.onchange = function (e) {\n      for (let i = 0; i < domArr.length; i++) {\n        domArr[i].checkbox.checked = e.target.checked;\n\n      }\n    }\n```","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/js/todolist.md"}},{"pageContent":"# Turbo和monorepo\n\n我们先来看看单一代码库monorepo和多代码仓库（multirepos）有什么区别\n\n\n多代码仓库（multirepos）:每个项目存储在一个完全独立的、版本控制的代码库中。是我目前遇到项目普遍使用的一种方式。例如每个项目的web端是一个代码仓库、H5是另一个。\n\nMonorepo 是指在一个 git 仓库下管理多个项目的代码。这些项目可能是相关的，但通常在逻辑上是独立的，可以由不同的团队维护。比如 <a href=\"https://github.com/vuejs/devtools\">vue devtools</a>;这种项目常依托于npm或者pnpm提供的`workspace`方案；通过`workspace`方案，对项目进行多个分包\n\n<img src=\"https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fpackage-graph.3b11ffd3.png&w=828&q=75&dpl=dpl_Bop6cDpFyhYDskUdvBvkzjLN8JGg\" />\n\n我们可以通过设置工作区，在不同的项目中共享一个项目的作为依赖，同时我们管理多个项目也会变得更加容易\n\n## 我们为什么要使用monorepo？\n\n1. 我们开发组件或者组件库的时候，我们希望对于组件库的代码，实时的对代码进行修改，观察其结果\n2. 同一个项目分为多个端，但其中的代码又可以大量的复用\n3. 为微前端代码代码的维护提供便利\n\n## turbo创建monorepo                                         \n\n<a href=\"https://turbo.build/repo/docs\"> turbo是什么？</a>\n\n具有缓存机制、任务并行执行优化。他能帮我们方便的创建`monorepo`仓库，且能帮我们快速构建`monorepo`项目,内部提供丰富的管理打包方法。\n\n- 全局安装turbo\n\n```bash\nnpm install turbo -g\n```\n\n- 创建项目\n\n我们使用`with-vite`的模板，他创建的是一个原生的vite项目\n\n```bash\nnpx create-turbo@latest --example with-vite\n```\n\n我们使用`pnpm`作为包管理工具,他便于我们使用`monorepo`的目录结构\n\n<img src=\"/monorepo/steps1.png\" />\n\n\n我们的文件就初始好了\n\n\n<img src=\"/monorepo/setps2.png\" />\n\n这里是简化的目录结构\n```md\n|-- try\n    |-- .eslintrc.js\n    |-- .gitignore\n    |-- .npmrc\n    |-- package.json\n    |-- pnpm-lock.yaml\n    |-- pnpm-workspace.yaml\n    |-- README.md\n    |-- turbo.json\n    |-- .vscode\n    |   |-- settings.json\n    |-- apps\n    |   |-- docs\n    |   |   |-- package.json\n    |   |-- web\n    |       |-- package.json\n    |-- packages\n        |-- eslint-config\n        |   |-- package.json\n        |-- typescript-config\n        |   |-- package.json\n        |-- ui\n            |-- \n       \n```\n\n## 编辑pnpm-workspace.yaml工作区文件\n\n*pnpm-workspace.yaml*这个文件是我们`monorepo`文件的根本，我们需要来确定我们的工作区，我们的工作区的包可以独立安装也可以互相引用，我们来看看*pnpm-workspace.yaml*的内容\n\n```yaml\npackages:\n  - 'apps/*'\n  - 'packages/*'\n```\n\n这里代表我们的`apps`和`packages`目录下的所有文件都是工作区，`*`是通配符的意思，代表我们`app`和`packages`目录下的所有文件都是工作区\n\n## 启动项目文件\n```bash\npnpm run dev\n```\n这个命令会执行`turbo dev`命令，这个命令会启动所有工作区的项目\n```json\n   \"dev\": \"turbo dev\",\n```\n但我们希望不启动全部命令可以使用`turbo dev --filter=[package.json的name]` 通过`--filter`参数来指定我们想要启动的工作区项目，注意这里的--filter参数后面是包名不是文件名\n\n这里我们启动的是工作区模板，如果我们添加新的项目该怎么做呢？\n\n## 新增项目\n\n这里添加我的`blog`项目\n\n```bash\ncd apps\ngit clone https://github.com/Manshawar/Manshawar-blog.git\n```\n我们安装包;\n\n```bash\npnpm install\n```\n不过我们再学习pnpm的时候 发现了可以使用`--filter [package的name]`来调用本地的包进行安装\n\n```bash\npnpm install --filter=[package的name]\n```\n用工作区安装包，pnpm会直接调用本地缓存安包的速度非常的快\n\n```bash\nturbo dev --filter blog\n```\n我们可以使用turbo启动项目，由于`turbo`的缓存机制 打开项目的速度会肉眼可见的变快\n\n\n## 添加本地包进行依赖\n\n我们要注意到`.npmrc`文件，在`pnpm>9`版本后，由于默认的`link-workspace-packages`被改为了`false`，他会优先从`镜像`中拉取包，我们无法安装工作区的本地包，我们需要在`.npmrc`文件中新增下面这一行文本,它会优先从本地拉去包\n\n这里时issue地址<a href=\"https://github.com/pnpm/pnpm/issues/7954\">https://github.com/pnpm/pnpm/issues/7954</a>\n```yaml\nlink-workspace-packages = true\n```\n*注意,如果安装不了，可以尝试新开一个终端*\n\n我们再使用`pnpm install`命令安装本地依赖\n\n```bash\npnpm instal @repo/eslint-config --filter blog\n```\n\n接下来你会在工作区中看到`workspace`工作区依赖包\n\n<img src=\"/monorepo/package1.png\" />\n\n\n- workspace:*: 匹配所有版本的工作区包。这意味着无论版本号是什么，都将使用当前 monorepo 中对应名称的工作区包。\n- workspace:~: 使用波浪号（~），它通常表示“与指定版本兼容的小版本更新”。对于 workspace:~ 来说，它会匹配相同主要和次要版本但补丁版本可以不同的工作区包。例如，如果工作区包的最新版本是 1.5.3，那么 workspace:~ 将会匹配到这个版本，因为它允许补丁级别的变化。\n- workspace:^: 插入符号（^）意味着“与指定版本兼容的主要版本”。这允许次要版本和补丁版本的变化，只要主要版本号保持不变。例如，workspace:^1.5.0 将会匹配 1.x.x 系列中的任何版本，但不会匹配 2.0.0 或更高版本，因为那会被认为是一个不向后兼容的更改。\n\n我们可以编辑`.npmrc`来控制其版本，这里我们设置为`workspace:*`\n```yaml\nsave-prefix = ''\n```\n这里是相关链接<a href=\"https://pnpm.io/npmrc#save-prefix\">https://pnpm.io/npmrc#save-prefix</a>\n\n现在你可以开始你的monorepo项目了，打包详细参考turbo官网","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/project/turbo/turbo.mdx"}},{"pageContent":"import Test from \"@com/CustomComponent\"\n\n<Test />\n\ntest \n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/project/vite工程化/vite使用cdn.mdx"}},{"pageContent":"## 产物优化---拆包\n\n### 为什么要拆包\n\n1. 代码分割：\n\n将第三方库（vendors）单独打包为一个或多个文件。这样做不仅有利于浏览器缓存这些不常变动的库文件，还能避免每次应用程序代码更新后都需要重新下载整个依赖库的问题。\n\n2. 利用浏览器的并发机制，加快首屏渲染速度\n\n### 如何拆包\n\n在vite的4，5版本，vite拆包仅需在rollup的output中，使用manualChunks方法进行拆包，\n\nmanualChunks他的值有两种形式\n\n- 当值为对象形式时，每个属性代表一个 chunk，其中包含列出的模块及其所有依赖，除非他们已经在其他 chunk 中，否则将会是模块图（module graph）的一部分。chunk 的名称由对象属性的键决定。（使用键值对进行分包）\n- 当值为函数时如果函数返回字符串，那么该模块及其所有依赖将被添加到以返回字符串命名的自定义 chunk 中，他接收两个参数 一个是模块id；和一个对象，这个对象包含两个方法，一个是getModuleInfo(获取文件信息)，一个是getModuleIds（访问视图中所有的模块id）；\n\n我们只需要通过 过滤出需要拆包的模块即可，我们可以通过正则或者js提供的原生方法，通过if判断，满足拆包条件的返回字符串即可\n\n### 拆包的BUG\n\n但是在vite3版本及以下，manualChunks拆包会产生一个bug\n\n包之间的循环引用，manualChunks打包仅仅只根据路径id决定打包哪个chunk中（仅仅将路径包含 `react` 的模块打包到 `react-vendor`中，殊不知，像 `object-assign`这种 react 本身的依赖并没有打包进 `react-vendor`中），漏掉了间接依赖的情况，对于一些间接依赖，它并没打包至正确的chunk中\n\n### 解决方案\n\n在manualChunks的判断条件中，我们对判断条件进行处理\n\n我们在manualChunks中可以获取到getModuleInfo方法，我们拿到这个方法就可以获取vite依赖图谱中的依赖信息\n\n依赖图谱:\n\n- 在vite的依赖分析插件中，他会将该模块的import的模块挂在到module的importmodules属性上，自身的模块id作为module的importer属性\n- 我们可以通过importer了解到这个模块被哪些模块使用过\n\n我们开发一个方法，对其依赖进行溯源\n\n```ts\n// 缓存对象\nconst cache = new Map();\n\nfunction isDepInclude (id: string, depPaths: string[], importChain: string[], getModuleInfo): boolean | undefined  {\n  const key = `${id}-${depPaths.join('|')}`;\n  // 出现循环依赖，不考虑\n  if (importChain.includes(id)) {\n    cache.set(key, false);\n    return false;\n  }\n  // 验证缓存\n  if (cache.has(key)) {\n    return cache.get(key);\n  }\n  // 命中依赖列表\n  if (depPaths.includes(id)) {\n    // 引用链中的文件都记录到缓存中\n    importChain.forEach(item => cache.set(`${item}-${depPaths.join('|')}`, true));\n    return true;\n  }\n  const moduleInfo = getModuleInfo(id);\n  if (!moduleInfo || !moduleInfo.importers) {\n    cache.set(key, false);\n    return false;\n  }\n  // 核心逻辑，递归查找上层引用者\n  const isInclude = moduleInfo.importers.some(\n    importer => isDepInclude(importer, depPaths, importChain.concat(id), getModuleInfo)\n  );\n  // 设置缓存\n  cache.set(key, isInclude);\n  return isInclude;\n};\n\n```\n\n目的：将该模块的相关依赖都打包至一个chunk中\n\n书写一个方法，接收id 过滤模组 添加缓存 返回true和false 决定该模块是否加入\n\n有缓存\n\n1. 我们创建一个map类型的数据\n2. 使用id和需要分割的chunk作为key\n3. 如果依赖链中包含该id，则视为进行了循环依赖，当前的id已经出现过了，每一个递归进入的依赖id，均为初始依赖的父级，写入为缓存中 值为false，进行跳出\n4. 验证缓存，如果在缓存中直接取出\n5. 如果当前id命中依赖列表，它的依赖链全部视为该依赖，返回为true\n6. 向上查询依赖，如果没有依赖或者查询不到模块，将返回值设置为false，写入缓存 进行跳出\n7. 如果查询到相关依赖，使用some循环对于父级模块进行递归，父级如果有一个命中，我们则视为他为依赖模块，只有父级没有一个命中的情况下，我们才排除这个模块\n8. 将这个some值写入缓存，并作为判断值进行返回\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/project/vite工程化/产物优化---拆包.md"}},{"pageContent":"这是一个测试文档\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/project/vite工程化/面试.md"}},{"pageContent":"# koa 中间件搭建脚手架(支持 tsx,vue)\n\n## 用 100 行代码，用 koa 写一个支持 vue 和 react 的赛博脚手架 😼\n\n如何有效的保证不挂科，当然是背知识点啦；😏\n同理，如何去理解脚手架呢，我的理解是以最低限度的可用性，去搭建一个脚手架，让我们放弃哪些反复的钩子，plugin，以及一些其他的配置。我会在一个中间件中，来完成最低限度的解析代码的工作，希望能帮助大家去理解脚手架，此项目参考于 mini-vite 和 vite-plugin-vue；\n\n我们 vite 也有自己的垃圾佬\n\n这个项目是我在写 miniVite 的时候产生的想法，所以用的是同一个库，认准`npm run cyber`,就好了;\n\n这个是仓库地址，既然来都来了，给个 star 吧\n\n<img src=\"https://memeprod.ap-south-1.linodeobjects.com/user-template/a1e08e595e29eef80af9737fefd90d21.png\" />\n\n[![Readme Card](https://github-readme-stats.vercel.app/api/pin/?username=Manshawar&repo=koa_vite)](https://github.com/Manshawar/koa_vite)\n\n这里是目录结构,以下是和当前项目相关的，专注于这些文件就好\n\n```json\n|-- koaMinivite,\n      |-- .gitignore,\n      |-- cyber.html,\n      |-- ...,\n      |-- src,\n          |-- cyber.ts,\n          |-- cyber,\n          |   |-- a.ts,\n          |   |-- App.vue,\n          |   |-- help.js,\n          |   |-- react.tsx,\n          |   |-- vue.ts,\n          |-- ...,\n          |-- node,\n              |-- ...,\n              |-- optimizer,\n              |   |-- index.ts,\n              |   |-- preBundlePlugin.ts,\n              |   |-- scanplugin.ts,\n\n\n```\n\n### 一、koa 搭建\n\n首先来看我们的入口文件`cyber.ts`;这个文件是核心文件，我们来看看他做了什么；\n\n```ts\nimport Koa from \"koa\";\nimport { optimize } from \"./node/optimizer\";\nconst app = new Koa();\napp.use(async (ctx, next) => {\n  //中间件区域\n  return next();\n});\napp.listen(8954, async () => {\n  await optimize(root, \"src/cyber/react.tsx\");\n  await optimize(root, \"src/cyber/vue.ts\");\n  console.log(\"http://localhost:8954 \");\n});\n```\n\n### 二、预构建\n\n我们看到`app.listen`开启服务的时候为什么会在回调中处理一个 optimize 的函数呢；\n我们对代码会进行一个预构建；详细的解释请移步 <a href=\"https://juejin.cn/post/7442189493153579046\">从 koa 到 mini-vite</a> ;\n我现在对其进行一个通俗的解释\n这里是 react 包的 index.js\n\n```js\n\"use strict\";\nif (process.env.NODE_ENV === \"production\") {\n  module.exports = require(\"./cjs/react.production.min.js\");\n} else {\n  module.exports = require(\"./cjs/react.development.js\");\n}\n```\n\n<p>那么你有没有发现一个问题；我们常使用的引入方法是`import React from \"react\";`</p>\n这是两种模块类型，一个是esm，一个是cjs；就像天堂的白鸽不会亲吻田野的乌鸦，es模块也不会引入cjs模块； 你拿前朝的🗡，怎么能斩本朝的官\n<img src=\"https://th.bing.com/th/id/OIP.99MBNn0mDCjAAELdfV29fAHaEL?rs=1&pid=ImgDetMain\" />\n\n那我们要解决以下几个问题\n\n- 怎么让各个包的模块格式都转化为 esm 模块\n- node_modules 包里的文件这么多，难道我们要全部代理成静态资源服务器吗\n- 如何让外部资源包和相对路径文件进行区分\n\nesbuild 可以通过打包来解决这些问题，朋克风的解释： 不打灰怎么浇筑混凝土；\n我们的目的是想要将所有要用的包，可以理解成后面砌砖需要多少水泥，都拖到工地上来；找个地方，把他们放哪里让我们好使用，\n\n这个文件是 nodemodule 包中的.vite 文件，你可以去任何一个 vite 项目中去寻找他，我们这里改一下名字,就叫\".m-vite\"；\n\n这里是 optimizer 的代码\n\n```ts\nimport path from \"path\";\nimport { build } from \"esbuild\";\nimport { scanPlugin } from \"./scanplugin\";\nimport { preBundlePlugin } from \"./preBundlePlugin\";\nimport { PRE_BUNDLE_DIR } from \"../contants\";\nexport async function optimize(root: string, other?: string) {\n  // 1. 确定入口\n  // 2. 从入口处扫描依赖\n  // 3. 预构建依赖;\n  const deps = new Set<string>();\n  const entry = path.resolve(root, other ? other : \"src/client/main.tsx\");\n  await build({\n    entryPoints: [entry],\n    bundle: true,\n    write: false,\n    plugins: [scanPlugin(deps)]\n  });\n  await build({\n    entryPoints: [...deps],\n    write: true,\n    bundle: true,\n    format: \"esm\",\n    splitting: true,\n    outdir: path.resolve(root, PRE_BUNDLE_DIR)//PRE_BUNDLE_DIR = \".m-vite\",\n    plugins: [preBundlePlugin(deps)]\n  });\n  console.log(\"需要构建的依赖项\", deps)\n}\n\n```\n\n他经历了两次 build，第一次是扫描依赖不生成文件，第二次是预构建依赖构建依赖，输出至 node_modules/.m-vite，\n\n至于插件的详解 请移步\n\n<a href=\"https://juejin.cn/post/7442189493153579046\">从koa到mini-vite</a>;\n\n我们这里经历了两次预构建\n\n```ts\nawait optimize(root, \"src/cyber/react.tsx\");\nawait optimize(root, \"src/cyber/vue.ts\");\n```\n\n因为这个项目会同时执行 react 和 vue，所以需要预构建两次，当然你可以自己选择，只需要在入口处写上对应的文件名即可;\n\n这个是我们预构建后的目录\n\n<img src=\"/vite/cyber/.m-vite.png\" />\n\n打包后的他们支持 es 模块语法了，我们接下来就会去其中提取相应的依赖\n\n### 三、中间件\n\n#### transformHtml 渲染初始页面\n\n开始我们中间件的第一步，让我们获取到了 req.url 后该做什么，当页面没有任何路径的时候，我们会获取到`req.url =\"/\"`，我们就在初始路径下，给他返回一个 html 文件，让页面去加载他\n\n```ts\napp.use(async (ctx, next) => {\n  const { req, res } = ctx;\n  if (req.url === \"/\") {\n    const realPath = path.join(process.cwd(), \"/cyber.html\");\n    //transformHtml\n    if (await fs.pathExists(realPath)) {\n      let code = await fs.readFile(realPath, \"utf-8\");\n      res.setHeader(\"Content-Type\", \"text/html\");\n      res.end(code);\n    }\n  }\n});\n```\n\n我们这里去读取了我们根目录下的 cyber.html 文件，我们使用了`fs-extra`库;这个库的 api 基本和 fs 原生的一致，但又更好的性能，和更加丰富的 api，我们检测是否存在该路径，如果存在则使用`utf-8`的格式去读取，并设置`text/html`的请求头返回给我们的服务器；不出意外的话，你应该可以看到一个`html`页面了\n\n这里是`cyber.html`文件的内容\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n\n  <body>\n    <div id=\"react\"></div>\n    <script type=\"module\" src=\"src/cyber/react.tsx\"></script>\n\n    <div id=\"vue\"></div>\n    <script type=\"module\" src=\"src/cyber/vue.ts\"></script>\n  </body>\n</html>\n```\n\n我们可以看到，他会引入一个 react.tsx 文件，可是我们的服务器还没又办法去处理他，别慌，我们来进行下一步中间件的书写\n\n```ts\napp.use(async (ctx, next) => {\n  const { req, res } = ctx;\n  if (req.url === \"/\") {\n    const realPath = path.join(process.cwd(), \"/cyber.html\");\n    //transformHtml\n    if (await fs.pathExists(realPath)) {\n      let code = await fs.readFile(realPath, \"utf-8\");\n      res.setHeader(\"Content-Type\", \"text/html\");\n      res.end(code);\n    }\n  } else if (req.method === \"GET\" || /\\.(?:j|t)sx?$|\\.mjs$|\\.vue$/.test(req.url as string)) {\n    //resolve\n    const realPath = path.join(process.cwd(), req.url + \"\");\n    //loader\n    if (await fs.pathExists(realPath)) {\n      let code = await fs.readFile(realPath, \"utf-8\");\n      let exname =\n        path.extname(req.url as string).slice(1) === \"vue\"\n          ? \"js\"\n          : path.extname(req.url as string).slice(1);\n      let { code: transformedCode, map } = await esbuild.transform(code, {\n        target: \"esnext\",\n        format: \"esm\",\n        sourcemap: true,\n        loader: exname as \"js\" | \"ts\" | \"jsx\" | \"tsx\",\n      });\n      //  transform\n      const ms = new MagicString(transformedCode);\n      await init;\n      const [imports, exports] = parse(transformedCode);\n      for (const importInfo of imports) {\n        const { n: importedId, s: start, e: end } = importInfo;\n        if (!importedId) continue;\n        if (/^[\\w@][^:]/.test(importedId)) {\n          let realPath = path.join(\"/\", \"node_modules\", \".m-vite\", `${importedId}.js`);\n          realPath = realPath.replace(/\\\\/g, \"/\");\n          ms.overwrite(start, end, realPath);\n          code = ms.toString();\n        }\n      }\n\n      res.setHeader(\"Content-Type\", \"application/javascript\");\n\n      res.statusCode = 200;\n      res.end(code);\n    }\n  }\n  return next();\n});\n```\n\n我们来进行下一步的处理，这个是 vite 的 load 阶段,去读取相应的文件\n\n#### resolve 和 loader 解析文件路径并读取他\n\n```ts\nif (req.method === \"GET\" || /\\.(?:j|t)sx?$|\\.mjs$|\\.vue$/.test(req.url as string)) {\n  const realPath = path.join(process.cwd(), req.url + \"\");\n}\n```\n\n这个阶段我们主要做的是筛选和拼接路径，我们只允许 js,ts,jsx,tsx,vue,mjs 文件传入，我们使用正则对其过滤\n然后再拼接出他的真正路径出来；我们 vite 的 resolve 阶段 就是做的这么一项工作\n\n既然知道地址了，我们就可以和上文中的一样，去读取他\n\n```ts\nif (await fs.pathExists(realPath)) {\n  let code = await fs.readFile(realPath, \"utf-8\");\n  let { code: transformedCode, map } = await esbuild.transform(code, {\n    target: \"esnext\",\n    format: \"esm\",\n    sourcemap: true,\n    loader: path.extname(req.url as string).slice(1) as \"js\" | \"ts\" | \"jsx\" | \"tsx\",\n  });\n}\n```\n\n我们可以看到，我们读取他后，使用 esbuild 对其进行了转换，我们这一步是将 ts 文件或者 tsx 文件转换为 esm 模块；其中 loader 是我们目前文件的后缀，`react`的优势就是可以直接被 esbuild 解析，可以帮我们节省很多功夫，`vue`则需要花费大量的精力进行书写了\n\n我们得到的`transformedCode`就是我们处理好的`tsx`文件了，这时候他是一个原生的 es6 模块；但问题随之而来\n\n#### transform 转换\n\n<img src=\"/vite/cyber/bare.png\" />\n\n我们的浏览器可不认识`bare`引入的包；这时候我们需要对其进行改写，上面的预构建的文件就有了用武之地；\n\n```ts\nconst ms = new MagicString(transformedCode);\nawait init;\nconst [imports, exports] = parse(transformedCode);\nfor (const importInfo of imports) {\n  const { n: importedId, s: start, e: end } = importInfo;\n\n  if (!importedId) continue;\n  if (/^[\\w@][^:]/.test(importedId)) {\n    let realPath = path.join(\"/\", \"node_modules\", \".m-vite\", `${importedId}.js`);\n    realPath = realPath.replace(/\\\\/g, \"/\");\n    // ms.overwrite(start, end, realPath);\n    code = ms.toString();\n  }\n}\n```\n\n我们使用`magic-string`这个库`import MagicString from \"magic-string\";`，`new`一个`ms`;出来，他的功能是去修改我们的代码；这个库是`vite`官方使用的\n然后使用 `await init` 创建引入和导出的分析环境;`import { init, parse } from \"es-module-lexer\";`这个工具库可以帮助我们分析一个模块的导入导出，并返回相应的`ast`;\n\n```ts\n{ n: 'react', t: 1, s: 43, e: 48, ss: 24, se: 49, d: -1, a: -1 }\n{\n  n: 'react-dom/client',\n  t: 1,\n  s: 79,\n  e: 95,\n  ss: 51,\n  se: 96,\n  d: -1,\n  a: -1\n}\n```\n\n这个是我们分析出的 imports 的值，我们只需要关注三点；`n` 和 `s` 和 `e`；`n`是包名 `s`是开始位置 `e`是结束位置;知道这几个值我们就能改写原来的代码；\n\n```ts\nlet realPath = path.join(\"/\", \"node_modules\", \".m-vite\", `${importedId}.js`);\n```\n\n将代码改为我们想要的路径，然后返回即可；这是包的位置就指向的了`.m-vite`文件中了\n\n```js\nimport a from \"./a.ts\";\nimport React from \"/node_modules/.m-vite/react.js\";\nimport { createRoot } from \"/node_modules/.m-vite/react-dom/client.js\";\nconsole.log(React, a);\nconst App = () => /* @__PURE__ */ React.createElement(\"div\", null, \"react\");\nconst root = createRoot(document.getElementById(\"react\"));\nroot.render(/* @__PURE__ */ React.createElement(App, null));\n```\n\n这个就是最终返回的文件;esbuild 原生支持`react`；`vue`与之相比又很反人类了;\n\n```ts\nres.setHeader(\"Content-Type\", \"application/javascript\");\nres.statusCode = 200;\nres.end(code);\n```\n\n最后将其作为 js 文件返回，你的 react 就成了，但是我们是否还遗忘了一个东西,`vue`该怎么处理?\n\n#### vue-loader\n\n`vue`的处理是一把心酸，一把泪，为了处理`vue`；跑去读了`vue-plugin`的源码；\n\n<a href=\"https://github.com/vitejs/vite-plugin-vue\">vue-plugin</a>\n\n其中难点就在于 sfc 怎么处理；怎么讲单文件拆分成三块进行处理，当然，我只拆了两块，华生，你发现了盲点。整个项目没有处理`css`的东西，哈哈 😄；当然我们先学会处理 js，css 会好处理很多\n\n先叠个甲，这个`vue-plugin`的风格也是垃圾佬风格 😏\n\n第一步，我们需要拆分 sfc 单文件组件\n\n该怎么拆分呢，从 load 开始读\n\n<a href=\"https://github.com/vitejs/vite-plugin-vue/blob/main/packages/plugin-vue/src/index.ts\">\n  vue-plugin/index\n</a>\n\n```js\nload(id, opt) {\n//...\n      if (query.vue) {\n        if (query.src) {\n          return fs.readFileSync(filename, 'utf-8')\n        }\n        const descriptor = getDescriptor(filename, options.value)!\n        let block: SFCBlock | null | undefined\n        if (query.type === 'script') {\n          // handle <script> + <script setup> merge via compileScript()\n          block = resolveScript(\n            descriptor,\n            options.value,\n            ssr,\n            customElementFilter.value(filename),\n          )\n        } else if (query.type === 'template') {\n          block = descriptor.template!\n        } else if (query.type === 'style') {\n          block = descriptor.styles[query.index!]\n        } else if (query.index != null) {\n          block = descriptor.customBlocks[query.index]\n        }\n        if (block) {\n          return {\n            code: block.content,\n            map: block.map as any,\n          }\n        }\n      }\n    },\n\n```\n\n从`getDescriptor`我找到了以下两个位置\n代码位置:`packages/plugin-vue/src/utils/descriptorCache.ts`\n\n<img src=\"/vite/cyber/parse.png\" />\n\n注意这个`parse` ;为了寻找`complier`的位置，我寻找到了这个位置\n\n代码位置:`packages/plugin-vue/src/compiler.ts`\n\n<img src=\"/vite/cyber/compiler.png\" />\n\n我们拿到了两个信息 一个是`vue/compiler-sfc` 一个是 `parse`;\n既然如此 我们就`import {parse as vueParse,compileTemplate,compileScript} from \"vue/compiler-sfc\"`引入 parse 对其进行解析\n\n```js\nconst vueAst = vueParse(code);\n```\n\n我们得到了 vue 的 ast 语法树，代码成功的被我们拆分了;以下的代码块都经过简化\n\n```js\n{\n  descriptor: {\n    filename: 'anonymous.vue',\n    source: `...`\n    template: {\n      type: 'template',\n      content:  `...`,\n      loc: [Object],\n      attrs: {},\n      ast: [Object],\n      map: [Object]\n    },\n    script: {\n      type: 'script',\n      content:  `...`,\n      loc: [Object],\n      attrs: [Object],\n      lang: 'ts',\n      map: [Object]\n    },\n    scriptSetup: {\n      type: 'script',\n      content:  `...`,\n      loc: [Object],\n      attrs: [Object],\n      setup: true,\n      lang: 'ts'\n    },\n    styles: [],\n    customBlocks: [],\n    cssVars: [],\n    slotted: false,\n    shouldForceReload: [Function: shouldForceReload]\n  },\n  errors: []\n}\n\n```\n\n接下来就是转换代码了；我们接着 load 钩子开始读\n\n从`resolveScript`我又找到了以下位置\n\n<img src=\"/vite/cyber/scriptSfc.png\" />；\n\n我们引入`compileScript`对 script 标签进行处理;\n\n`let scriptRes = compileScript(vueAst.descriptor, { id: req.url });`\n得到结果\n\n```js\n{\n  type: 'script',\n  content: ...,\n  loc: {\n  ....\n  },\n  attrs: { setup: true, lang: 'ts' },\n  setup: true,\n  lang: 'ts',\n  bindings: {\n    defineComponent: 'setup-const',\n    ref: 'setup-const',\n    count: 'setup-let',\n    add: 'setup-const'\n  },\n  imports: [Object: null prototype] {\n    defineComponent: {\n      isType: false,\n      imported: 'defineComponent',\n      local: 'defineComponent',\n      source: 'vue',\n      isFromSetup: false,\n      isUsedInTemplate: false\n    },\n    ref: {\n      isType: false,\n      imported: 'ref',\n      local: 'ref',\n      source: 'vue',\n      isFromSetup: true,\n      isUsedInTemplate: false\n    }\n  },\n  map: []\n    ,\n    names: [],\n    mappings: '...'\n  },\n  scriptAst: [\n    Node {\n      type: 'ImportDeclaration',\n      start: 2,\n      end: 40,\n      loc: [SourceLocation],\n      importKind: 'value',\n      specifiers: [Array],\n      source: [Node],\n      attributes: []\n    },\n    Node {\n      type: 'ExportDefaultDeclaration',\n      start: 44,\n      end: 222,\n      loc: [SourceLocation],\n      exportKind: 'value',\n      declaration: [Node]\n    }\n  ],\n  scriptSetupAst: [\n    Node {\n      type: 'ImportDeclaration',\n      start: 2,\n      end: 28,\n      loc: [SourceLocation],\n      importKind: 'value',\n      specifiers: [Array],\n      source: [Node],\n      attributes: []\n    },\n    Node {\n      type: 'VariableDeclaration',\n      start: 30,\n      end: 49,\n      loc: [SourceLocation],\n      declarations: [Array],\n      kind: 'let'\n    },\n    Node {\n      type: 'VariableDeclaration',\n      start: 51,\n      end: 92,\n      loc: [SourceLocation],\n      declarations: [Array],\n      kind: 'const'\n    }\n  ],\n  dep\n\n```\n如法炮制 找到`compileTemplate`函数，对模板代码进行处理\n```js\n   let temp = compileTemplate({ source: vueAst.descriptor.template?.content as string, filename: realPath, id: req.url,  });\n```\n\n<img src=\"/vite/cyber/tempSfc.png\" />\n这里是template 的编译结果\n```js\n{\n  code: 'import { toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\\n' +\n    '\\n' +\n    'export function render(_ctx, _cache) {\\n' +\n    '  return (_openBlock(), _createElementBlock(\"div\", null, [\\n' +\n    '    _createElementVNode(\"div\", null, \"hello Vue \" + _toDisplayString(_ctx.count), 1 /* TEXT */),\\n' +\n    '    _createElementVNode(\"button\", {\\n' +\n    '      onClick: _cache[0] || (_cache[0] = (...args) => (_ctx.add && _ctx.add(...args)))\\n' +\n    '    }, \"add\")\\n' +\n    '  ]))\\n' +\n    '}',\n  ast: {\n    type: 0,\n    source: '\\r\\n' +\n      '  <div>\\r\\n' +\n      '    <div>hello Vue {{ count }}</div>\\r\\n' +\n      '    <button  @click=\"add\">add</button>\\r\\n' +\n      '  </div>\\r\\n',\n    children: [ [Object] ],\n    helpers: Set(4) {\n      Symbol(toDisplayString),\n      Symbol(createElementVNode),\n      Symbol(openBlock),\n      Symbol(createElementBlock)\n    },\n    components: [],\n    directives: [],\n    hoists: [],\n    imports: [],\n    cached: [ [Object] ],\n    temps: 0,\n    codegenNode: {\n      type: 13,\n      tag: '\"div\"',\n      props: undefined,\n      children: [Array],\n      patchFlag: undefined,\n      dynamicProps: undefined,\n      directives: undefined,\n      isBlock: true,\n      disableTracking: false,\n      isComponent: false,\n      loc: [Object]\n    },\n    loc: {\n      start: [Object],\n      end: [Object],\n      source: '\\r\\n' +\n        '  <div>\\r\\n' +\n        '    <div>hello Vue {{ count }}</div>\\r\\n' +\n        '    <button  @click=\"add\">add</button>\\r\\n' +\n        '  </div>\\r\\n'\n    },\n    transformed: true,\n    filters: []\n  },\n  preamble: '',\n  source: '\\r\\n' +\n    '  <div>\\r\\n' +\n    '    <div>hello Vue {{ count }}</div>\\r\\n' +\n    '    <button  @click=\"add\">add</button>\\r\\n' +\n    '  </div>\\r\\n',\n  errors: [],\n  tips: [],\n  map: {\n    version: 3,\n    sources: [ 'D:\\\\code\\\\study\\\\vite\\\\minivite\\\\koaVite\\\\src\\\\cyber\\\\App.vue' ],\n    names: [ 'count' ],\n    mappings: ';;;wBACE,oBAGM;IAFJ,oBAAgC,aAA3B,YAAU,oBAAGA,UAAK;IACvB,oBAAkC;MAAxB,OAAK,0CAAE,6BAAG;OAAE,KAAG',\n    sourcesContent: [\n      '\\r\\n' +\n        '  <div>\\r\\n' +\n        '    <div>hello Vue {{ count }}</div>\\r\\n' +\n        '    <button  @click=\"add\">add</button>\\r\\n' +\n        '  </div>\\r\\n'\n    ]\n  }\n}\n\n```\n我们分割了其sfc的代码后，我们该怎么做呢；我们来看看一个vue3的项目,服务器返回的vue文件是什么样子\n\n```js\nimport { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/src/views/index.vue\");import { defineComponent as _defineComponent } from \"/node_modules/.vite/deps/vue.js?v=eaf793ab\";\nimport { ElButton } from \"/node_modules/.vite/deps/element-plus.js?v=eaf793ab\";\nimport { testApi } from \"/src/api/index.js\";\nimport { defineComponent } from \"/node_modules/.vite/deps/vue.js?v=eaf793ab\";\nconst __default__ = defineComponent({\n  name: \"\"\n});\nconst _sfc_main = /* @__PURE__ */ _defineComponent({\n  ...__default__,\n  setup(__props, { expose: __expose }) {\n    __expose();\n    const sendTEst = async () => {\n      let res = await testApi();\n      console.log(\"ok\", res);\n    };\n    const __returned__ = { sendTEst, get ElButton() {\n      return ElButton;\n    } };\n    Object.defineProperty(__returned__, \"__isScriptSetup\", { enumerable: false, value: true });\n    return __returned__;\n  }\n});\nimport { createTextVNode as _createTextVNode, withCtx as _withCtx, createVNode as _createVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"/node_modules/.vite/deps/vue.js?v=eaf793ab\";\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", null, [\n    _createVNode($setup[\"ElButton\"], { onClick: $setup.sendTEst }, {\n      default: _withCtx(() => _cache[0] || (_cache[0] = [\n        _createTextVNode(\"hello world\")\n      ])),\n      _: 1\n      /* STABLE */\n    }),\n    _cache[1] || (_cache[1] = _createTextVNode(\" 1111111 \"))\n  ]);\n}\n_sfc_main.__hmrId = \"b301384e\";\ntypeof __VUE_HMR_RUNTIME__ !== \"undefined\" && __VUE_HMR_RUNTIME__.createRecord(_sfc_main.__hmrId, _sfc_main);\nimport.meta.hot.on(\"file-changed\", ({ file }) => {\n  __VUE_HMR_RUNTIME__.CHANGED_FILE = file;\n});\nimport.meta.hot.accept((mod) => {\n  if (!mod) return;\n  const { default: updated, _rerender_only } = mod;\n  if (_rerender_only) {\n    __VUE_HMR_RUNTIME__.rerender(updated.__hmrId, updated.render);\n  } else {\n    __VUE_HMR_RUNTIME__.reload(updated.__hmrId, updated);\n  }\n});\nimport _export_sfc from \"/@id/__x00__plugin-vue:export-helper\";\nexport default /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"D:/code/work/project/vite-project/src/views/index.vue\"]]);\n\n```\n```js\nexport default (sfc, props) => {\n    const target = sfc.__vccOpts || sfc;\n    for (const [key,val] of props) {\n        target[key] = val;\n    }\n    return target;\n}\n```\n我在阅读源码的时候，发现vue3实际上是通过默认暴露一个vue对象，这个vue对象就是其组件；我从上面源码获取到的信息就是vue文件时暴露一个`default`,这个default会根据改写其render和__file属性；将其视为vue组件，我们做的第一步就是将`_sfc_main`的`render`替换为`compileTemplate`处理过后的`render`方法；要想将其合并，我们先将其拼接\n```js\n     let arr = [scriptRes.content, temp.code]\n        code = arr.join(\"\\n\");\n\n```\n最终我们得到混合的代码块；我们的vue-loader算是初步完成了，接下来我们去处理他的code\n\n#### vue-plugin transform\n因为我们主要处理的是导出模块，我们可以通过` const [imports, exports] = parse(transformedCode);`对他的export进行改写\n```js\n\n if (req.url?.endsWith(\".vue\")) {\n        for (const exportInfo of exports) {\n          const { n: exportId, s: start, e: end } = exportInfo;\n          if (!exportInfo) continue;\n\n          if (exportId === \"default\") ms.overwrite(start, end, \"other\");\n          // console.log(realPath)\n          code = ms.toString() + `let sfc_main =stdin_default.__vccOpts || stdin_default;sfc_main.render =render};\\n sfc_main.__file = \"${realPath}\";\\nexport default /* @__PURE__ */sfc_main`\n        }\n      }\n```\n我们可以看到，我将`default`进行了处理;这是为什么呢；因为他解析出来的代码默认就是一个`default`导出；我将其改写为非`default`导出，这个位置需要留给vue实例;然后我们对其进行改写，将`stdin_default`（这个是script解析的结果）的属性改写，并提供新的名字`sfc_main`;`sfc_main.render =render`将基本信息改写完我们将其导出 `export default /* @__PURE__ */sfc_main`;\n这是App.vue的代码\n```vue\n<template>\n  <div>\n    <div>hello Vue {{ count }}</div>\n    <button  @click=\"add\">add</button>\n  </div>\n</template>\n<script lang=\"ts\">\nimport { defineComponent } from \"vue\";\n\nexport default defineComponent({\n  name: \"App\",\n});\n</script>\n<script setup lang=\"ts\">\nimport { ref } from \"vue\";\nlet count = ref(0);\nconst add = () => {\n  count.value++;\n};\n</script>\n\n```\n我们来看看页面\n<img src=\"/vite/cyber/noref.png\" />\n\n🥜，你又发现了忙点，怎么响应式数据没有\n\n我对其`sfc_main`的render参数进行打印\n\n<img src=\"/vite/cyber/render_arg.png\" />\n\n我发现其是有值的，排除法得到应该是我的render有问题；我在重新去检查`compileTemplate`的参数，并去查询其源码\n<a href=\"https://github.com/vitejs/vite-plugin-vue/blob/main/packages/plugin-vue/src/template.ts\">vite-plugin-vue/packages/plugin-vue/src\n/template.ts</a>\n\n<img src=\"/vite/cyber/tempOptions.png\" />\n\n我发现其`bindingMetadata`；在vue3的源码的阅读中，`bind`我们一般知道含有这个词的一般为传递参数；我刚好发现在script返回值的ts类型中刚好有这个值\n```ts\nexport interface SFCScriptBlock extends SFCBlock {\n    type: 'script';\n    setup?: string | boolean;\n    bindings?: BindingMetadata$1;\n    imports?: Record<string, ImportBinding>;\n    scriptAst?: _babel_types.Statement[];\n    scriptSetupAst?: _babel_types.Statement[];\n    warnings?: string[];\n    /**\n     * Fully resolved dependency file paths (unix slashes) with imported types\n     * used in macros, used for HMR cache busting in @vitejs/plugin-vue and\n     * vue-loader.\n     */\n    deps?: string[];\n}\n```\n那我们把他加进去\n```ts\n       let temp = compileTemplate({ source: vueAst.descriptor.template?.content as string, filename: realPath, id: req.url, slotted: vueAst.descriptor.slotted, compilerOptions: { bindingMetadata: scriptRes.bindings } });\n    \n\n```\n\n我们的代码就能正常工作了，甚至可以使用vue的开发者工具;\n<img src=\"/vite/cyber/res.gif\" />\n\n这里是完整的代码\n```ts\nimport Koa from \"koa\";\nimport { optimize } from \"./node/optimizer\";\nimport { init, parse } from \"es-module-lexer\";\nimport MagicString from \"magic-string\";\nimport fs from \"fs-extra\";\nimport esbuild from \"esbuild\"\nimport path from \"path\";\nimport {\n  parse as vueParse,\n  compileTemplate,\n  compileScript,\n} from \"vue/compiler-sfc\"\nconst root = process.cwd();\n\n\nconst app = new Koa();\n\napp.use(async (ctx, next) => {\n  const { req, res } = ctx;\n  if (req.url === \"/\") {\n    const realPath = path.join(process.cwd(), \"/cyber.html\");\n    //transformHtml\n    if (await fs.pathExists(realPath)) {\n      let code = await fs.readFile(realPath, \"utf-8\");\n      res.setHeader(\"Content-Type\", \"text/html\");\n      res.end(code)\n    }\n  } else if ((req.method === \"GET\" || /\\.(?:j|t)sx?$|\\.mjs$|\\.vue$/.test(req.url as string))) {\n    //resolve\n    const realPath = path.join(process.cwd(), req.url + \"\");\n    //loader\n    if (await fs.pathExists(realPath)) {\n\n      let code = await fs.readFile(realPath, \"utf-8\");\n      //vue-plugin loader\n      if (req.url?.endsWith(\".vue\")) {\n        const vueAst = vueParse(code);\n        let scriptRes = compileScript(vueAst.descriptor, { id: req.url });\n        let temp = compileTemplate({ source: vueAst.descriptor.template?.content as string, filename: realPath, id: req.url, slotted: vueAst.descriptor.slotted, compilerOptions: { bindingMetadata: scriptRes.bindings } });\n    \n \n        let arr = [scriptRes.content, temp.code]\n        code = arr.join(\"\\n\");\n\n      }\n      let exname = path.extname(req.url as string).slice(1) === \"vue\" ? \"js\" :path.extname(req.url as string).slice(1)\n      let { code: transformedCode, map } = await esbuild.transform(code, {\n        target: \"esnext\",\n        format: \"esm\",\n        sourcemap: true,\n        loader: exname as \"js\" | \"ts\" | \"jsx\" | \"tsx\",\n      });\n  \n      //  transform\n      const ms = new MagicString(transformedCode);\n      await init;\n      const [imports, exports] = parse(transformedCode);\n\n      for (const importInfo of imports) {\n        const { n: importedId, s: start, e: end } = importInfo;\n\n        if (!importedId) continue;\n        if (/^[\\w@][^:]/.test(importedId)) {\n\n          let realPath = path.join('/', \"node_modules\", \".m-vite\", `${importedId}.js`);\n          realPath = realPath.replace(/\\\\/g, \"/\");\n         \n          ms.overwrite(start, end, realPath);\n          code = ms.toString();\n        }\n\n      }\n      // vue-plugin transform\n      if (req.url?.endsWith(\".vue\")) {\n        for (const exportInfo of exports) {\n          const { n: exportId, s: start, e: end } = exportInfo;\n          if (!exportInfo) continue;\n\n          if (exportId === \"default\") ms.overwrite(start, end, \"other\");\n          // console.log(realPath)\n          code = ms.toString() + `let sfc_main =stdin_default.__vccOpts || stdin_default;sfc_main.render = function(...arg){console.log(arg);return render(...arg)};\\n sfc_main.__file = \"${realPath}\";\\nexport default /* @__PURE__ */sfc_main`\n        }\n      }\n      res.setHeader(\"Content-Type\", \"application/javascript\");\n\n\n      res.statusCode = 200;\n      res.end(code)\n    }\n  }\n  return next()\n})\n\n\napp.listen(8954, async () => {\n  await optimize(root, \"src/cyber/react.tsx\")\n  await optimize(root, \"src/cyber/vue.ts\")\n  console.log(\"http://localhost:8954 \")\n})\n\n```\n\n什么叫做赛博朋克？这就叫赛博朋克；垃圾佬的哲学观，又不是不能跑😎；\n\n靓仔；都看到这里了，点个赞再走呗\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/project/从零开始搭建vite/koa中间件搭建脚手架(支持tsx,vue).mdx"}},{"pageContent":"# 从 koa 到 mini-vite（一）预构建\n\n### 1、vite 的本质是什么\n\n<p>vite实质上来讲，它是一个node资源服务器，通过搭建mini-vite，我深入的认识到了这点，vite整体的流程就是通过对引入包扫描的预构建，配合插件容器对于预构建资源的处理，最后通过ws和依赖收集，来实现热更新。说实在点就是你想服务器发送请求，他处理js文件返回给你，让你的浏览器能识别，既然是服务器，那我们就可以使用任何的node框架进行搭建；</p>\n\n这个是仓库地址\n\n[![Readme Card](https://github-readme-stats.vercel.app/api/pin/?username=Manshawar&repo=koa_vite)](https://github.com/Manshawar/koa_vite)\n### 2、项目的技术选型\n\nkoa+ts+esbuild+fs-extra\n\n此项目使用 tsx 运行\n\n- tsx 拥有自带的 watch 模式，非常好用\n- ts-node 给我了很多麻烦，因为他会在 commomJs 和 module 模块混用的时候出问题\n- ts-node 的 issue 有人推荐 tsx😏\n\n为什么选择 koa，无他，因为他足够简单，可以直接上手使用。选择用 typescript 进行开发，因为 ts 的好处就在于，我们可以知道引入的包有哪些方法，更加便于我们书写方法，同时减少代码出 bugger 的可能性。\n\n使用 koa 搭建这个项目，这个项目只是一个学习项目，并不是一个具备高可用性的项目，优先级是以如何最容易看懂来实现的，所以 koa 搭建的这个服务器并不会进行任何的打包，如果想体验打包后的产物，建议可以使用一下 tsup，俺实力优先，现阶段没法手写 bundle 就不考虑一切打包相关的东西了。\n\n再次叠甲。这个项目不是那么严谨的，高可用的，这个项目主要目的一是帮助穷哥们叩开工程化的门缝(就这三脚猫功夫，我觉得不能称之为大门🥹)。其次是对自己这段时间的脚手架学习给一个交代，我认为有输入了，还是要有点输出，更能巩固知识点，其次这也是一个备忘录\n\n以下是 package.json 文件，如果有哥们想实现的话可以复制一下。\n\n```json\n{\n  \"dependencies\": {\n    \"@types/connect\": \"^3.4.38\",\n    \"@types/debug\": \"^4.1.12\",\n    \"@types/fs-extra\": \"^11.0.4\",\n    \"@types/resolve\": \"^1.20.6\",\n    \"@types/ws\": \"^8.5.13\",\n    \"cac\": \"^6.7.14\",\n    \"chokidar\": \"^4.0.1\",\n    \"connect\": \"^3.7.0\",\n    \"cross-env\": \"^7.0.3\",\n    \"debug\": \"^4.3.7\",\n    \"es-module-lexer\": \"^1.5.4\",\n    \"esbuild\": \"^0.24.0\",\n    \"fs-extra\": \"^11.2.0\",\n    \"koa\": \"^2.15.3\",\n    \"magic-string\": \"^0.30.13\",\n    \"picocolors\": \"^1.1.1\",\n    \"react\": \"^18.3.1\",\n    \"react-dom\": \"^18.3.1\",\n    \"resolve\": \"^1.22.8\",\n    \"rollup\": \"^4.27.3\",\n    \"sirv\": \"^3.0.0\",\n    \"tsup\": \"^8.3.5\",\n    \"ws\": \"^8.18.0\"\n  },\n\n  \"scripts\": {\n    \"dev\": \"cross-env NODE_ENV=dev tsx watch ./src/index.ts  \"\n  },\n  \"devDependencies\": {\n    \"@types/koa\": \"^2.15.0\",\n    \"@types/node\": \"^22.9.1\",\n    \"file-loader\": \"^6.2.0\"\n  }\n}\n```\n\n### 3、使用 koa 搭建一个服务器\n\n```ts\nimport Koa from \"koa\";\nconst app = new Koa();\n//import { optimize } from \"./node/optimizer\";\n//const root = process.cwd()\napp.use(ctx => {\n  ctx.body = \"hello Koa\";\n});\napp.listen(3000, async () => {\n  //await optimize(root)\n  console.log(\"http://localhost:3000 \");\n});\n```\n\n嗯....，这是个有手就行的工作，不会有人不会吧，不会吧，不会吧，能看到 hello koa 就算成功\n### 4、从zhangsan文件开始，理解何为资源服务器\n\n我们来看这段代码\n\n```ts\nimport fs from \"fs-extra\";\nimport path from \"path\";\n\napp.use(async (ctx, next) => {\n  const { req, res } = ctx;\n\n  if (req.url?.endsWith(\".zhangsan\") || (req.url === \"/zhangsan\"&&req.method === \"GET\")) {\n    const realPath = path.join(process.cwd(), req.url + (req.url === \"/zhangsan\" ? \".html\" : \"\"));\n    if (await fs.pathExists(realPath)) {\n      const code = await fs.readFile(realPath, \"utf-8\");\n      res.statusCode = 200;\n      req.url === \"/zhangsan\" ? res.setHeader(\"Content-Type\", \"text/html\") : res.setHeader(\"Content-Type\", \"application/javascript\");\n      \n      res.end(code)\n    }\n  }\n  return next()\n})\n\n```\n这是一个中间件，他的主要功能就是解析后缀为.zhangsan的文件，同时 再路由导航到zhangsan路由的时候，会读取根目录下的zhangsan.html文件，然后我们通过readFile读取文件，将其返回的content-type，改为html，我们的浏览器就可以读取这个页面了\n\n这里是zhangsan.html 他在根目录下；\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n\n<body>\n  <div id=\"zhangsan\"></div>\n  <script type=\"module\" src=\"src/node/zhangsan/1.zhangsan\"></script>\n</body>\n\n</html>\n\n\n```\n当这段代码被浏览器读取后，他的script标签会向我们的服务器发送请求，这个请求url是`src/node/zhangsan/1.zhangsan`，我们的服务器能直接拦截到后缀为`.zhangsan`的请求 见代码`req.url?.endsWith(\".zhangsan\") `,然后我们验证这个地址是否存在，如果存在，就使用utf-8的格式去读取他，返回时将响应头设置为js，我们的浏览器就会去执行他，这是我们的zhangsan文件\n```js\n//src/node/zhangsan/1.zhangsan\nimport a from \"./a.zhangsan\";\ndocument.getElementById(\"zhangsan\").innerHTML = \"zhangsan\";\nconsole.log(a)\n\n```\n甚至他还支持模块化；\n```js\n//src/node/zhangsan/a.zhangsan\nexport default {\n  a:1\n}\n\n```\n你可以看到页面\n\n<img src=\"/vite/koa_vite/zhangsan.png\" />\n\n你可以通过network查看我们的请求\n<img src=\"/vite/koa_vite/zhangsannet.png\" />\n\n你现在应该了解到一点教授架的基础了，接下来开始上车了哦😚；不了解也没关系，可以去隔壁的cyber脚手架，一个中间件，带你过完react或者vue执行的一生，只不过是朋克风，青春版的而已😏\n这里是掘金地址\n\n\n\n### 5、进行依赖的预构建\n\n提问：为什么要进行依赖的预构建。\n\n当然是对于外部引入的资源进行处理，node_modules 里的包，vite 是不会直接引用的，会先进行依赖扫描，将我们安装的一些包如 vue,react,element 等，这种外部资源包通过 esbuild 进行编译，形成一个.vite 的缓存文件。后续钩子的处理都是从.vite 中提取的资源,按照工地的话讲，这是打灰。😎\n\n#### 5-1、为什么要进一步的处理\n\n如下图：\n\n<div style={{ display: \"flex\", gap: \"10px\" }}>\n  <img width=\"50%\" src=\"/vite/koa_vite/react.png\" />\n  <img width=\"50%\" src=\"/vite/koa_vite/vue.png\" />\n</div>\n我们可以看到,无论是react还是vue,他们打包后的产物都是通过**commonjs**进行的,也就是说,我们是无法在浏览器中直接执行的,所以需要做一次**转换**。其原因是它们的生态系统中很多**库和工具是基于\nNode.js 构建**的。因此，这些库和工具通常会以 **CommonJS 格式**发布，以便于在 **Node.js环境中使用。**,而且，我们需要更快的构建速度，而读取缓存则是常用的方法。** 而且最重要的是，我翻遍了react和react-dom的所有包，它默认没有es模块的包，直接使用`import React from \"react\"`是根本用不了的😒;  **\n\n#### 5-2、打开你的 node_modules 包，找到.vite 文件\n\n有没有发现你的 node_modules 包，vite 项目中有一个.vite 的文件，你删除了你的项目就 G 了 😏，得重新进行 build，这是为什么呢？;让我们来看看.vite 包是由什么构成的\n\n<img src=\"/vite/koa_vite/.vite.png\" />\n\n你会发现，包里会存在似曾相识的包的名字，因为在依赖预构建阶段，**vite 会将 bare import 的路径视作第三方包，**，**使用 esbuild 打包**，**将其缓存到.vite 文件，这也是 vite 高性能的由来，** **vite 是 esbuild 和 rollup 双引擎，rollup 为主体，esbuild 相当于一个催化剂**； \n\n这是 vite 的双引擎流程图，请关注于左边的开发阶段，当前的工作就是 pre-bundle，使用 esbuild 进行依赖预构建\n\n<img src=\"/vite/koa_vite/esbuild&esbuild.png\" />\n\n> bare import 是什么：在 JavaScript 模块系统中，\"bare import\"（裸导入）是指在 import 语句中直接使用一个模块的名称，而不是一个完整的 URL 或相对路径\n\n通俗的讲，将我们要用的依赖包通过 esbuild 转化为缓存，用来提升构建速度，减少性能消耗，这个是有意义的，后续我们对于bare裸引入处理的时候，如import React from \"react\"，我们会直接将路径改写至.vite路径中，直接读取打包好的代码\n\n#### 5-3、开始书写 esbuild 构建代码\n\n这里是入口文件的代码 index.ts，其中的optimizer是进行预构建的函数\n\n```ts\nimport Koa from \"koa\";\nconst app = new Koa();\nimport { optimize } from \"./node/optimizer\";\nconst root = process.cwd();\napp.use(ctx => {\n  ctx.body = \"hello Koa\";\n});\napp.listen(3000, async () => {\n  await optimize(root);\n  console.log(\"http://localhost:3000 \");\n});\n```\n\n我们来康康 optimizer 文件是怎么个事\n\n```ts\nimport path from \"path\";\nimport { build } from \"esbuild\";\nimport { scanPlugin } from \"./scanplugin\";\nimport { preBundlePlugin } from \"./preBundlePlugin\";\nimport { PRE_BUNDLE_DIR } from \"../contants\"; //path.join(\"node_modules\", \".m-vite\")\nexport async function optimize(root: string) {\n  // 1. 确定入口\n  // 2. 从入口处扫描依赖\n  // 3. 预构建依赖;\n  const deps = new Set<string>();\n  const entry = path.resolve(root, \"src/client/main.tsx\");\n  await build({\n    entryPoints: [entry],\n    bundle: true,\n    write: false,\n    plugins: [scanPlugin(deps)],\n  });\n  await build({\n    entryPoints: [...deps],\n    write: true,\n    bundle: true,\n    format: \"esm\",\n    splitting: true,\n    outdir: path.resolve(root, PRE_BUNDLE_DIR), //这个合成路径是 process.cwd() + \"/node_modules/.m-vite\"\n    plugins: [preBundlePlugin(deps)],\n  });\n  console.log(\"需要构建的依赖项\", deps);\n}\n```\n\n我们开始分析这个代码做了哪些事情 😏\n\nbuild 是调用 esbuild 的build，里面的选项都解释一下 \n- entryPoints：是指入口文件 \n - bundle：使用脚本打包，我们使用的 esbuild 的 api，所以我们需要设置为 true\n  - write: 是否写入文件， \n  - plugins: 插件，这里面有 scanPlugin 和 preBundlePlugin， \n  - format : 打包的格式，我们打包的是 esmodule，所以设置为 esm \n  - splitting: 是否拆分打包，我们选择拆分，拆分后代码块更小，速度会提升一些 \n  - outdir：打包后输出的目录\n\n预构建为什么是两次build\n\n1.第一次build不进行打包，快速的将其依赖项过滤出来\n2.第二次build专门对第一次过滤出来的依赖项进行打包，我们就可以得到所有的外部依赖想的包\n\n通俗的讲就是第一个build就是lol的选择英雄，第二部就是选择天赋 召唤师技能全部带好，准备进入召唤师峡谷大杀四方 😏\n\n上面两个插件会在下面单独解析，先给大家说说是干嘛的，\n\n- scanPlugin 做的事情是扫描依赖，将 bare import 进行收集 将他放到**deps 的 Set 集合**中;\n- preBundlePlugin 的作用是，将收集到的依赖进行预构建，将结果**写入到.vite 文件夹**中，同时**返回一个 map，这个 map 中包含了所有的依赖的绝对路径**，后面会用到。导出规范是 esmodule 模块。并且我们会对其的导出进行重写，**将 commomjs 模块重写为大家熟知的 esmodule 模块**\n\n\n这两个插件跑完后，我们的预构建基本就完成了\n\n#### 5-3-1、先来看看 sanPlugin 的代码\n\n在两个插件中，我们涉及到最基础的两个函数，**resolveId**和**load**，他们是 esbuild 插件的基本钩子\n\n- onResolve：在模块路径被解析之前调用，用于修改或重定向模块路径。\n- onLoad：在模块路径确定后调用，用于读取或生成模块内容。\n  在写的时候我们需要注意一点，resolve 中的返回值至关重要，我们需要返回原来的路径，以保证我们能够继续进行下去\n  以下是 scanPlugin 插件的代码\n\n```ts\n// node/contants.ts\nexport const EXTERNAL_TYPES = [\n  \"css\",\n  \"less\",\n  \"sass\",\n  \"scss\",\n  \"styl\",\n  \"stylus\",\n  \"pcss\",\n  \"postcss\",\n  \"vue\",\n  \"svelte\",\n  \"marko\",\n  \"astro\",\n  \"png\",\n  \"jpe?g\",\n  \"gif\",\n  \"svg\",\n  \"ico\",\n  \"webp\",\n  \"avif\",\n];\nexport const BARE_IMPORT_RE = /^[\\w@][^:]/;\n//optimizer/scanPlugin.ts\nimport { Plugin } from \"esbuild\";\nimport { BARE_IMPORT_RE, EXTERNAL_TYPES } from \"../contants\";\nexport function scanPlugin(deps: Set<string>): Plugin {\n  return {\n    name: \"scan-deps\",\n    setup(build) {\n      build.onResolve({ filter: new RegExp(`\\\\.(${EXTERNAL_TYPES.join(\"|\")})$`) }, resolveInfo => {\n        return {\n          path: resolveInfo.path,\n          // 打上 external 标记\n          external: true,\n        };\n      });\n      build.onResolve(\n        {\n          filter: BARE_IMPORT_RE,\n        },\n        resolveInfo => {\n          deps.add(resolveInfo.path);\n          return {\n            path: resolveInfo.path,\n            external: true,\n          };\n        }\n      );\n    },\n  };\n}\n```\n\nbuild.onResolve 钩子，在解析路径之前调用，返回一个对象，onResolve 中的 filter 选项是一个过滤器，会根据正则进行过滤\n\n第一个钩子中 我们过滤掉了无关的资源，他是将 EXTERNAL_TYPES 数组中所有相关的后缀名全部过滤掉， 返回值是一个对象，我们需要返回 path，这个 path 是必传的\n\n> path 字段用于唯一标识一个模块。esbuild 需要一个明确的路径来确定模块的身份，以便在后续的构建过程中正确地处理和引用该模块。\n\n> external 字段，外部资源不需要 esbuild 对其进行处理\n\n我们在这两个钩子中，第一个钩子的任务是排除不必要资源，便于下面的钩子能够更好的解析生成依赖，第二个钩子是过滤出 条件为`/^[\\w@][^:]/`的依赖。`第一个字符必须是字母、数字、下划线 (_) 或者 @。这由 [\\\\w@] 部分表示`,`第二个字符不能是冒号 (:)。这由 [^:] 部分表示`，将`bare import`全部收集到我们依赖集合中。\n\n#### 5-3-2、再来看看 preBundlePlugin 的代码\n\n这位更是重量级，上强度了哦 🥵,我已经汗流浃背了。\n\n```ts\n//optimizer/preBundlePlugin.ts\nimport { Loader, Plugin } from \"esbuild\";\nimport { BARE_IMPORT_RE } from \"../contants\";\nimport { init, parse } from \"es-module-lexer\";\nimport path from \"path\";\nimport resolve from \"resolve\";\nimport fs from \"fs-extra\";\nimport { pathToFileURL } from \"url\"\nimport createDebug from \"debug\";\nimport { normalizePath } from \"../utils\";\nconst debug = createDebug(\"dev\");\nexport function preBundlePlugin(deps: Set<string>): Plugin {\n  return {\n    name: \"esbuild:pre-bundle\",\n    setup(build) {\n\n      build.onResolve(\n        {\n          filter: BARE_IMPORT_RE,\n        },\n        (resolveInfo) => {\n\n          const { path: id, importer } = resolveInfo;\n          const isEntry = !importer;\n          // 命中需要预编译的依赖;\n\n          if (deps.has(id)) {\n\n            // console.log(\"id\", id, isEntry, importer)\n            // 若为入口，则标记 dep 的 namespace\n\n            return isEntry\n              ? {\n                path: id,\n                namespace: \"dep\",\n              }\n              : {\n                // 因为走到 onResolve 了，所以这里的 path 就是绝对路径了\n                path: resolve.sync(id, { basedir: process.cwd() }),\n              };\n          }\n        }\n      );\n      build.onLoad({\n        filter: /.*/,\n        namespace: \"dep\"\n      }, async (loadInfo) => {\n        await init;\n        const id = loadInfo.path;\n\n        const root = process.cwd();\n        const entryPath = normalizePath(resolve.sync(id, { basedir: root }));\n\n        const code = await fs.readFile(entryPath, \"utf-8\");\n        // console.log(\"path-------\", entryPath,)\n        const [imports, exports] = await parse(code);\n        // console.log(\"imports, exports\", imports, exports)\n        let proxyModule = [];\n        let relativePath = normalizePath(path.relative(root, entryPath))\n        if (\n          !relativePath.startsWith('./') &&\n          !relativePath.startsWith('../') &&\n          relativePath !== '.'\n        ) {\n          relativePath = `./${relativePath}`\n        }\n\n        //进行词法解析，将所有require的文件方法提取出来转为es虚拟模块暴露 \n        if (!imports.length && !exports.length) {\n          let res = await import(pathToFileURL(entryPath).toString());\n          const specifiers = Object.keys(res);\n          proxyModule.push(\n            `export { ${specifiers.join(\",\")} } from \"${relativePath}\"`,\n            // `export default import(\"${relativePath}\")`\n          );\n        } else {\n          if ((exports as any).includes(\"default\")) {\n            proxyModule.push(`import d from \"${entryPath}\";export default d`);\n          }\n          proxyModule.push(`export * from \"${relativePath}\"`);\n        }\n\n\n        debug(\"代理模块内容: %o\", proxyModule.join(\"\\n\"));\n        const loader = path.extname(entryPath).slice(1);\n        // console.log(\"resolveDir----------\", root, proxyModule)\n        // console.log(\"proxyModule----------\", proxyModule)\n        return {\n          loader: loader as Loader,\n          contents: proxyModule.join(\"\\n\"),\n          resolveDir: root,\n        }\n      })\n      build.onStart(() => {\n        console.log('build started')\n      })\n    }\n  }\n}\n```\n\n我们将其分成两块来看 🫠\n\n在 onResolve 中，我们继续沿用上一次进行依赖收集的条件，其实进行依赖收集也是为了能更快的找到依赖，**esbuild 在不打包的情况下，速度远快于需要打包的情况**。让我们来康康，他是如何进行精准命中的\n\n第一步，确定入口模块 👻\n一般来说，包里面对其没有引用，我们一般就可以**确认他是入口模块，isEntry 为 true 的话，我们会让他在 onLoad 中进行进一步处理**。如果为 false，则返回其路径为绝对路径。\n我们来看看当他为 false 时的情况\n\n```js\nresolveInfo = {\n  path: \"react\",\n  importer:\n    \"D:\\\\code\\\\study\\\\vite\\\\minivite\\\\koaVite\\\\node_modules\\\\.pnpm\\\\react-dom@18.3.1_react@18.3.1\\\\node_modules\\\\react-dom\\\\cjs\\\\react-dom.development.js\",\n  namespace: \"file\",\n  resolveDir:\n    \"D:\\\\code\\\\study\\\\vite\\\\minivite\\\\koaVite\\\\node_modules\\\\.pnpm\\\\react-dom@18.3.1_react@18.3.1\\\\node_modules\\\\react-dom\\\\cjs\",\n  kind: \"require-call\",\n  pluginData: undefined,\n  with: {},\n};\n```\n\n这个是他的 resolveInfo，我们可以看到，他是在 react-dom 中使用的 react 包，我们是不需要将其进行处理的，我们原本已经处理好了一个模块了，这里我们**只需要将他的路径返回为我们当前包的路径即可**,使用他的时候会在后续的插件容器中进行处理，我们的插件最终会在.m-vite中去读取bare包\n\n第二步，对于入口文件进行重写 💀\n上述满足条件的会标记为 dep 命名空间，我们可以直接在**只用相同的命名空间获取上文中过滤出来的模块**。\n`es-module-lexer`这个包是用于对路径依赖进行分析的，我们**await init 实际上就相当于将其处于了 init.then()的环境下**，我们从 loadInfo 中获取当前路径的 id ，然后**使用 resolve.sync 和 normalizePath,将其转换为可用的路径**\n\n```ts\nexport function normalizePath(id: string): string {\n  return path.posix.normalize(isWindows ? slash(id) : id);\n}\n```\n\n这个方法只是帮我们适配 windows 系统的路径，resolve.sync 是**将如`react`这种路径，拼接成绝对路径**,resolve 是帮助我们从当前根路径下寻找可用的路径。他们会将 id 为`react`,转化为`\"D:/code/study/vite/minivite/koaVite/node_modules/react/index.js\"`这样的路径\n\n`await parse(code)`，解析当前路径是否存在**引入和导出**，`proxyModule`此数组用来收集**依赖**，`relativePath`则是将路径转化为`\"./node_modules/react-dom/index.js\"`这种相对路径，下面的 if 处理也是用于帮助转换为相对路径的。\n\n```ts\nawait init;\nconst id = loadInfo.path;\n\nconst root = process.cwd();\nconst entryPath = normalizePath(resolve.sync(id, { basedir: root }));\n\nconst code = await fs.readFile(entryPath, \"utf-8\");\n// console.log(\"path-------\", entryPath,)\nconst [imports, exports] = await parse(code);\n// console.log(\"imports, exports\", imports, exports)\nlet proxyModule = [];\nlet relativePath = normalizePath(path.relative(root, entryPath));\nif (!relativePath.startsWith(\"./\") && !relativePath.startsWith(\"../\") && relativePath !== \".\") {\n  relativePath = `./${relativePath}`;\n}\n```\n\n我们开始处理是否存在 esmodule 依赖了,`if (!imports.length && !exports.length) `这里的处理是**判断我们是否存在有 es 模块构筑的包**，如果不存在，我们需要将 commonjs 的模块转换为 esmodule 的模块，我们**通过 import 先获取对应文件的导出模块**，我们的入口文件主要功能就是暴露模块，我们只需要关注暴露了哪些模块就好了，最后会**将同一个命名空间下不同的导出模块汇总到一起，形成一个数组**;\n\n> import异步方法可以直接将require的模块变成es模块，非常好用，我们需要注意的是使用pathToFileURL 这个node原生的方法，将其路径变化为文件路径\n\n```ts\n//进行词法解析，将所有require的文件方法提取出来转为es虚拟模块暴露\nif (!imports.length && !exports.length) {\n  const res = require(entryPath);\n\n  const specifiers = Object.keys(res);\n  // console.log(\"res----\", entryPath, res)\n  proxyModule.push(\n    `export { ${specifiers.join(\",\")} } from \"${relativePath}\"`,\n    `export default require(\"${relativePath}\")`\n  );\n} else {\n  if ((exports as any).includes(\"default\")) {\n    proxyModule.push(`import d from \"${entryPath}\";export default d`);\n  }\n  proxyModule.push(`export * from \"${relativePath}\"`);\n}\n```\n\n我们的 else，则是存在 esmodule 模块时的操作，我们只需要，判断是否有默认暴露，有的话就补上，在分别暴露的情况下也只需要使用通配符就可以暴露所有模块，非常方便\n\n为什么要这么处理呢\n\n对于 CommonJS 格式的依赖，单纯用 export default require('入口路径') 是有局限性的，比如对于 React 而言，用这样的方式生成的产物最后只有 default 导出:\n\n```ts\nexport default react_default;\n```\n\n那么用户在使用这个依赖的时候，必须这么使用:\n\n```ts\n// ✅ 正确\nimport React from \"react\";\nconst { useState } = React;\n// ❌ 报错\nimport { useState } from \"react\";\n```\n\n最后,返回一个对象，loader 这里是'js'，将我们的内容打包为 js，` proxyModule.join(\"\\n\")`将收集的依赖数组转化为内容，代替原本的内容进行打包，resolveDir 则是我们当前根目录\n\n```ts\nconst loader = path.extname(entryPath).slice(1);\n// console.log(\"resolveDir----------\", root, proxyModule)\n// console.log(\"proxyModule----------\", proxyModule)\nreturn {\n  loader: loader as Loader,\n  contents: proxyModule.join(\"\\n\"),\n  resolveDir: root,\n};\n```\n\n下面则是我们打包的结果\n\n```js\n// dep:react\nvar import_react = __toESM(require_react());\nvar export_Children = import_react.Children;\nvar export_Component = import_react.Component;\nvar export_Fragment = import_react.Fragment;\nvar export_Profiler = import_react.Profiler;\nvar export_PureComponent = import_react.PureComponent;\nvar export_StrictMode = import_react.StrictMode;\nvar export_Suspense = import_react.Suspense;\nvar export___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = import_react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\nvar export_act = import_react.act;\nvar export_cloneElement = import_react.cloneElement;\nvar export_createContext = import_react.createContext;\nvar export_createElement = import_react.createElement;\nvar export_createFactory = import_react.createFactory;\nvar export_createRef = import_react.createRef;\nvar export_default = import_react.default;\nvar export_forwardRef = import_react.forwardRef;\nvar export_isValidElement = import_react.isValidElement;\nvar export_lazy = import_react.lazy;\nvar export_memo = import_react.memo;\nvar export_startTransition = import_react.startTransition;\nvar export_unstable_act = import_react.unstable_act;\nvar export_useCallback = import_react.useCallback;\nvar export_useContext = import_react.useContext;\nvar export_useDebugValue = import_react.useDebugValue;\nvar export_useDeferredValue = import_react.useDeferredValue;\nvar export_useEffect = import_react.useEffect;\nvar export_useId = import_react.useId;\nvar export_useImperativeHandle = import_react.useImperativeHandle;\nvar export_useInsertionEffect = import_react.useInsertionEffect;\nvar export_useLayoutEffect = import_react.useLayoutEffect;\nvar export_useMemo = import_react.useMemo;\nvar export_useReducer = import_react.useReducer;\nvar export_useRef = import_react.useRef;\nvar export_useState = import_react.useState;\nvar export_useSyncExternalStore = import_react.useSyncExternalStore;\nvar export_useTransition = import_react.useTransition;\nvar export_version = import_react.version;\nexport {\n  export_Children as Children,\n  export_Component as Component,\n  export_Fragment as Fragment,\n  export_Profiler as Profiler,\n  export_PureComponent as PureComponent,\n  export_StrictMode as StrictMode,\n  export_Suspense as Suspense,\n  export___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,\n  export_act as act,\n  export_cloneElement as cloneElement,\n  export_createContext as createContext,\n  export_createElement as createElement,\n  export_createFactory as createFactory,\n  export_createRef as createRef,\n  export_default as default,\n  export_forwardRef as forwardRef,\n  export_isValidElement as isValidElement,\n  export_lazy as lazy,\n  export_memo as memo,\n  export_startTransition as startTransition,\n  export_unstable_act as unstable_act,\n  export_useCallback as useCallback,\n  export_useContext as useContext,\n  export_useDebugValue as useDebugValue,\n  export_useDeferredValue as useDeferredValue,\n  export_useEffect as useEffect,\n  export_useId as useId,\n  export_useImperativeHandle as useImperativeHandle,\n  export_useInsertionEffect as useInsertionEffect,\n  export_useLayoutEffect as useLayoutEffect,\n  export_useMemo as useMemo,\n  export_useReducer as useReducer,\n  export_useRef as useRef,\n  export_useState as useState,\n  export_useSyncExternalStore as useSyncExternalStore,\n  export_useTransition as useTransition,\n  export_version as version\n};\n\n```\n\nexport*useRef 中间加一个*代表之前是 commomjs 的模块，现在变成 esmodule 的模块，所以需要加一个\\_,到这里，我们的依赖预构建终于完成了；\n\n参考：\n\n<a href=\"https://s.juejin.cn/ds/iDy3m2f9/\">深入浅出vite</a>\n\n\n大家可以去学一学这个，此项目的灵感来源，也是带我进入了工程化的大门","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/project/从零开始搭建vite/从koa到mini-vite(一).mdx"}},{"pageContent":"# 从 koa 到 mini-vite（三）资源处理及模块依赖和热更新\n\n这个是仓库地址\n\n[![Readme Card](https://github-readme-stats.vercel.app/api/pin/?username=Manshawar&repo=koa_vite)](https://github.com/Manshawar/koa_vite)\n\n### 1、处理图片资源的路径\n\n我们先对资源路径进行处理，不过`react`和`vue`的资源处理大有不同，我们这里先论证`react`，你可以从`cyber`文件中看到`vue`是如何处理的；\n\n```ts\n//..........\nimport koaStatic from \"koa-static\";\n//..........\nconst serverContext: ServerContext = {\n  root: process.cwd(),\n  PluginContainer,\n  app,\n  plugins: plugins,\n  moduleGraph,\n  ws,\n  clientPath,\n  watcher,\n};\nbindingHMREvents(serverContext);\napp.use(koaStatic(path.join(process.cwd(), \"/src/client/\")));\nfor (const plugin of plugins) {\n  if (plugin.configureServer) {\n    await plugin.configureServer(serverContext);\n  }\n}\napp.use(indexHtmlMiddware(serverContext));\napp.use(transformMiddleware(serverContext));\n//..........\n```\n\n我们这边使用`koa-static`静态资源包对其客户端文件进行代理`/src/client/`;\n\n`react`的资源处理就完成了，但是也是有其局限性的，无法对其**相对路径**进行处理。我在`cyber.ts`中，写了一个简单的 demo，使其`vue`实现了对相对路径的处理，你可以参考一下。\n\n我简单的介绍一下 vue 我是如何处理的；\n\n1. 我通过观察得到，在`vue/compiler-sfc`的处理中，会将`src`请求的`url`，转换为`import`路径，然后使用虚拟`node`，对其进行处理，见图\n   <img src=\"/vite/cyber/pngDeal.png\" />\n2. 解析出来的路径是一个`import`，我们通过`resolve`方法将其路径改写为基于服务器的绝对路径\n3. 我们的图片可不能使用`import`引入，我们暴露一个虚拟模块\n4. 改写路径时在后面加上一个`?import`符号\n5. 在引入时，我们解析此路径，返回`code`为\n\n```js\nexport default \"src/cyber/components/171536_380.png\";\n```\n\n这样我们就能引入图片，并实现引入图片的懒加载了。\n\n### 2、处理 Svg 资源\n\n对于 svg 资源的处理，我在这里书写了一个`plugin`,在书写一个程序前，确立两点有助于帮助我们快速的实现\n\n1. 确定输入的是什么\n2. 确定输出的是什么\n\n实际上也就是确定`I/O`;\n我们来看看，我们需要怎么去实现一个 svg 的处理,先看需求代码\n\n```tsx\nimport \"./App.css\";\nimport React from \"react\";\nimport logo from \"./logo.svg\";\n// import logo from \"./logo.svg\";\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <p>dsdsHell ssf sadsf</p>\n        <p></p>\n        <img src=\"/public/OIP-C.jpg\" alt=\"\" />\n        <p>\n          ds<code>sdssdafsssfadsa</code> sans save es tsest.\n        </p>\n        <img className=\"App-logo\" src={logo} alt=\"\" />\n        <p></p>\n      </header>\n    </div>\n  );\n}\n```\n\n我们可以清晰的看到，我们的 src 值是引入的`logo`，`src`接受的是地址，我们需要处理的是将 logo 转化为`export default 真实路径`；而`vite`插件中，`load`钩子是返回`code`的，我们就在此处做文章\n\n```ts\nimport { Plugin } from \"./plugin\";\nimport { ServerContext } from \"../../index\";\nimport { cleanUrl, getShortName, normalizePath, removeImportQuery } from \"../utils\";\nimport path from \"path\";\nexport function assetPlugin(): Plugin {\n  let serverContext: ServerContext;\n\n  return {\n    name: \"m-vite:asset\",\n    configureServer(s) {\n      serverContext = s;\n    },\n    async load(id) {\n      const cleanedId = removeImportQuery(cleanUrl(id));\n      const resolvedId = `/${path\n        .relative(path.join(serverContext.root, \"/src/client/\"), cleanedId)\n        .replaceAll(\"\\\\\", \"/\")}`;\n\n      if (cleanedId.endsWith(\".svg\")) {\n        return {\n          code: `export default \"${resolvedId}\"`,\n        };\n      }\n    },\n  };\n}\n```\n\n我们在 load 中将传入的`id`，由经`resolve`的处理，我们的`id`是绝对路径，能读取到位置的绝对路径，后续再使用`path.relative`，将路径做相对路径处理，这样我们就能得到相对于当前文件的位置，因为我们在前文`koa-static`代理的路径是`/src/client/`,所以我们需要在此处进行一下处理\n\n### 3、css 处理\n\n我们`css`的处理用一个`plugin`,我们来确定一下思路，我们的目的是将`import \"./index.css\";`转化为浏览器可读的`style`样式；我们来梳理一下处理思路；\n\n1. 将 css 文本进行读取\n2. 使用 style 标签注入 css\n3. 将 style 标签注入`html`\n\n这里是`css`plugin 代码，后续会为了热更新我们会进行进一步的改善\n\n```ts\n// plugins/css.ts\nimport { readFile } from \"fs-extra\";\nimport { Plugin } from \"../plugin\";\n\nexport function cssPlugin(): Plugin {\n  return {\n    name: \"m-vite:css\",\n    load(id) {\n      // 加载\n      if (id.endsWith(\".css\")) {\n        return readFile(id, \"utf-8\");\n      }\n    },\n    // 转换逻辑\n    async transform(code, id) {\n      if (id.endsWith(\".css\")) {\n        // 包装成 JS 模块\n        const jsContent = `\nconst css = \"${code.replace(/\\n/g, \"\")}\";\nconst style = document.createElement(\"style\");\nstyle.setAttribute(\"type\", \"text/css\");\nstyle.innerHTML = css;\ndocument.head.appendChild(style);\nexport default css;\n`.trim();\n        return {\n          code: jsContent,\n        };\n      }\n      return null;\n    },\n  };\n}\n```\n\n### 4、依赖图谱\n\n依赖图谱主要有以下几个作用\n\n1. 构建依赖关系\n2. 进行缓存\n3. 热更新的索引映射\n\n我们来确定一下，我们的依赖图谱每一个节点需要的是哪些参数，这里提供一个`class`，我们来进行参考\n\n```ts\nexport class ModuleNode {\n  // 资源访问 url\n  url: string;\n  // 资源绝对路径\n  id: string | null = null;\n  importers = new Set<ModuleNode>();\n  importedModules = new Set<ModuleNode>();\n  transformResult: TransformResult | null = null;\n  lastHMRTimestamp = 0;\n  constructor(url: string) {\n    this.url = url;\n  }\n}\n```\n\n我们可以看到，一个 moduleNode 类，需要的是\n\n- `url`请求连接\n- `id`模块的绝对路径\n- `importers`引入者(该`id`被谁引入)\n- `importedModules`被引入者(该`id`引入了哪些模块)\n- `transformResult`代码片段\n- `lastHMRTimestamp`时间戳，用于判断是否需要重新编译\n\n此类，在后续的生成中，我们命名为`mod`节点,我们从`url`到`importAnalysis`中间件，来看看他是如何处理的\n\n首先，我们从 url 的中间件开始\n\n<img src=\"/vite/koa_vite/中间件流程图.png\" />\n\n这里有张流程图，我们的代码处理如下\n\n```ts\n//src\\node\\middlewares\\transformMiddleware.ts\n//........\nasync function transformRequest(url: string, serverContext: ServerContext) {\n  const { PluginContainer, moduleGraph } = serverContext;\n  let query = url.split(\"?\")[1];\n\n  url = cleanUrl(url);\n\n  let mod = await moduleGraph.getModuleByUrl(url);\n  if (mod && mod.transformResult && !query) {\n    return mod.transformResult;\n  }\n  let res;\n  let resolveId = await PluginContainer.resolveId(url);\n  if (resolveId?.id) {\n    let code = await PluginContainer.load(resolveId?.id);\n    if (typeof code === \"object\" && code !== null) {\n      code = code.code;\n    }\n\n    mod = await moduleGraph.ensureEntryFromUrl(url);\n    if (code) {\n      res = await PluginContainer.transform(code, resolveId?.id);\n    }\n    if (mod) {\n      mod.transformResult = res;\n    }\n  }\n  return res;\n}\n//........\n```\n\n我们的`moduleGraph`对象会一点一点的进行介绍，一下子说完会感觉有点乱，\n我们来看看，他这里调用的`getModuleByUrl`方法是什么\n\n```ts\n//src\\node\\ModuleGraph.ts\n//moduleGraph.getModuleByUrl(url);\nexport class ModuleGraph {\n  urlToModuleMap = new Map<string, ModuleNode>();\n  idToModuleMap = new Map<string, ModuleNode>();\n  constructor(private resolveId: (url: string) => Promise<PartialResolvedId | null>) {}\n  getModuleById(url: string): ModuleNode | undefined {\n    return this.idToModuleMap.get(url);\n  }\n  async getModuleByUrl(rawUrl: string): Promise<ModuleNode | undefined> {\n    const { url } = await this._resolve(rawUrl);\n    return this.urlToModuleMap.get(cleanUrl(url));\n  }\n  async ensureEntryFromUrl(rawUrl: string): Promise<ModuleNode | undefined> {\n    const { url, resolvedId } = await this._resolve(rawUrl);\n    if (this.urlToModuleMap.has(url)) {\n      return this.urlToModuleMap.get(url) as ModuleNode;\n    }\n    const mod = new ModuleNode(url);\n    mod.id = resolvedId;\n    this.urlToModuleMap.set(url, mod);\n    this.idToModuleMap.set(resolvedId, mod);\n    return mod;\n  }\n}\n\n//src\\index.ts\nconst moduleGraph = new ModuleGraph(url => PluginContainer.resolveId(url));\n```\n\n这个类的`constructor`的参数传入的是插件容器定义的 resolveId 路径解析方法\n他会帮助我们解析路径，返回由插件容器解析的路径；\n\n- `getModuleById` 通过 id 寻找模块\n- `getModuleByUrl` 通过 url 转换成 id 寻找模块\n- `ensureEntryFromUrl` 通过 url 转换成 id 寻找模块，如果存在则获取模块，如果不存在，则创建一个模块，并添加到模块依赖的缓存中\n\n我们从流程图上来看：\n\n1. 判断是否存在于模块依赖的缓存中\n2. 如果存在，则从缓存中提取模块依赖（不会再重复相同的文件进行重复读写，esbuild 进行读写和修改 import 引入是及其`heavy`）\n3. 如果不存在，则再`load`后，使用`ensureEntryFromUrl`判断是否存在该缓存，如果存在则获取模块，如果不存在，则创建一个模块，并添加到模块依赖的缓存中\n4. 对于转换好的`code`，则写入缓存中\n\n`importAnalysis`预设进行依赖收集\n\n```ts\n// src\\node\\plugins\\importAnalysis.ts\n\n//.....length\nasync transform(code, id) {\n      const { moduleGraph } = serverContext;\n      const curmod = moduleGraph.getModuleById(id)!;\n      const importedModules = new Set<string>();\n      //....\n        for (const importInfo of imports) {\n        const { s: modStart, e: modEnd, n: modSource } = importInfo;\n        if (!modSource) continue;\n        //....\n        if (BARE_IMPORT_RE.test(modSource as string)) {\n          const bundlePath = normalizePath(\n            path.join('/', PRE_BUNDLE_DIR, `${modSource}.js`)\n          );\n          importedModules.add(bundlePath);\n\n          ms.overwrite(modStart, modEnd, bundlePath as string)\n        } else if (modSource.startsWith(\".\") || modSource.startsWith(\"/\")) {\n        //....\n          if (resolved) {\n            ms.overwrite(modStart, modEnd, resolved);\n            importedModules.add(resolved);\n          }\n        }\n      };\n      //....\n      moduleGraph.updataModuleInfo(curmod, importedModules);\n        return {\n        code: ms.toString(),\n        map: ms.generateMap()\n      }\n}\n\n\n```\n\n<img src=\"/vite/koa_vite/importAnalysis依赖分析.png\" />\n我们跟着流程图看 \n1. 通过`getModuleById`获取前文的`mod模块` \n2. 在`imports`的依赖分析中收集子模块数组 \n3. 使用`moduleGraph.updataModuleInfo`方法对依赖进行标记 \n4. 确保依赖是否存在，如果存在则获取，不存在则新建，并将依赖写入map中\n5. 在当前`mod`上写入`dep`作为`importedModules`\n6. 在`dep`上写入引入`mod`作为源头`importers`\n7. 该`mod`上一次的`importedModules`是否存在于当前传入的模块数组中，如果不存在，则删除\n\n```ts\nexport class ModuleGraph {\n  urlToModuleMap = new Map<string, ModuleNode>();\n  idToModuleMap = new Map<string, ModuleNode>();\n  //....\n\n  async updateModuleInfo(mod: ModuleNode, importedModules: Set<string | ModuleNode>) {\n    const prevImports = mod.importedModules;\n    for (const curImports of importedModules) {\n      const dep =\n        typeof curImports === \"string\"\n          ? await this.ensureEntryFromUrl(cleanUrl(curImports))\n          : curImports;\n      if (dep) {\n        mod.importedModules.add(dep);\n        dep.importers.add(mod);\n      }\n    }\n    // 清除已经不再被引用的依赖\n    for (const prevImport of prevImports) {\n      if (!importedModules.has(prevImport.url)) {\n        prevImport.importers.delete(mod);\n      }\n    }\n  }\n}\n//....\n```\n这里是完整的ModuleGraph代码，可以参考一下，具体更改的文件过多，请于仓库中查看\n```ts\nimport { PartialResolvedId, TransformResult } from \"rollup\";\nimport { cleanUrl } from \"./utils\";\nimport { debug } from \"console\";\nimport { getboundaries } from \"./plugins/hmr/boundaries\"\nexport class ModuleNode {\n  url: string = \"\";\n  id: string = \"\";\n  importers = new Set<ModuleNode>();\n  importedModules = new Set<ModuleNode>();\n  transformResult: TransformResult | null = null;\n  lastHMRTimetamp = 0;\n  constructor(url: string) {\n    this.url = url\n  }\n};\nexport class ModuleGraph {\n  urlToModuleMap = new Map<string, ModuleNode>();\n  idToModuleMap = new Map<string, ModuleNode>();\n  constructor(private resolveId: (url: string) => Promise<PartialResolvedId | null>) { };\n  getModuleById(url: string): ModuleNode | undefined {\n    return this.idToModuleMap.get(url)\n  }\n  async getModuleByUrl(rawUrl: string): Promise<ModuleNode | undefined> {\n    const { url } = await this._resolve(rawUrl);\n    return this.urlToModuleMap.get(cleanUrl(url))\n  }\n  async ensureEntryFromUrl(rawUrl: string): Promise<ModuleNode | undefined> {\n\n    const { url, resolvedId } = await this._resolve(rawUrl);\n    if (this.urlToModuleMap.has(url)) {\n      return this.urlToModuleMap.get(url) as ModuleNode\n    }\n    const mod = new ModuleNode(url);\n    mod.id = resolvedId;\n    this.urlToModuleMap.set(url, mod);\n    this.idToModuleMap.set(resolvedId, mod)\n    return mod;\n  };\n  async updataModuleInfo(mod: ModuleNode, importedModules: Set<string | ModuleNode>) {\n    const prevImports = mod.importedModules;\n\n    for (const curImports of importedModules) {\n\n\n      const dep = typeof curImports === \"string\" ? await this.ensureEntryFromUrl(cleanUrl(curImports)) : curImports;\n      if (dep) {\n\n        mod.importedModules.add(dep);\n        dep.importers.add(mod);\n      }\n    }\n    for (const preImport of prevImports) {\n      // console.log(importedModules.has(preImport.url as string))\n      if (!importedModules.has(preImport.url as string)) {\n        preImport.importers.delete(mod)\n      }\n    }\n  };\n  invalidateModule(file: string) {\n    const mod = this.idToModuleMap.get(file);\n    if (mod) {\n      mod.lastHMRTimetamp = Date.now();\n      mod.transformResult = null;\n      mod.importers.forEach((importer) => {\n        this.invalidateModule(importer.id!)\n      })\n    }\n  }\n  private async _resolve(url: string): Promise<{ url: string, resolvedId: string }> {\n    const resolved = await this.resolveId(url);\n    const resolvedId = resolved?.id as string;\n    return { url, resolvedId }\n  }\n  getboundaries(url: string) {\n    let curmod = this.urlToModuleMap.get(url)!;\n\n    return Array.from(getboundaries(curmod, new Set()))\n  }\n}\n\n```\n\n### 5、热更新\n\n热更新这里还有一些问题值得思考，我会带大家实现一个无状态保留的热更新，具体的热更新政策，我们还是需要去读react或者vue的热更新源码，这里就不做详细介绍。\n我们来确定，热更新需要的一些物料\n1. 使用`ws`像客户端传递信息\n2. 使用`chokidar`监听文件更新\n\n热更新整体流程图如下\n<img src=\"/vite/koa_vite/hmr大纲.png\" />\n\n```ts\n//src\\index.ts\nconst watcher = chokidar.watch(clientPath, {\n  ignored: [/node_modules/, /\\.git/],\n  ignoreInitial: true\n});\nconst ws = createWebSocketServer(app);\nconst serverContext: ServerContext = {\n  root: process.cwd(),\n  PluginContainer,\n  app,\n  plugins: plugins,\n  moduleGraph,\n  ws,\n  clientPath,\n  watcher\n};\nbindingHMREvents(serverContext)\n```\n我们先来看看`webSokect`\n```ts\n//src\\node\\ModuleGraph.ts\nimport { WebSocketServer, WebSocket } from \"ws\";\nimport { HMR_PORT } from \"./contants\";\nimport color from \"picocolors\";\nexport function createWebSocketServer(server: any): { send: (msg: string) => void; close: () => void } {\n  let wss: WebSocketServer;\n  wss = new WebSocketServer({ port: HMR_PORT });\n  wss.on(\"connection\", (socket) => {\n    socket.send(JSON.stringify({ type: \"connected\" }))\n  });\n  wss.on(\"error\", (e: Error & { code: string }) => {\n    if (e.code !== \"EADDRINUSE\") {\n      console.error(color.red(`WebSocket server error:\\n${e.stack || e.message}`))\n    }\n  })\n  return {\n    send(payload: Object) {\n      const stringified = JSON.stringify(payload);\n      wss.clients.forEach((client) => {\n        if (client.readyState === WebSocket.OPEN) {\n          client.send(stringified)\n        }\n      })\n    },\n    close() { \n      wss.close()\n    }\n  }\n}\n\n```\n这是封装的一个websocket服务,他会返回一个对象，这个对象可以向我们的服务端广播更新的信息，我们只需要调用这个对象的send方法即可\n\n再来看看`hmr`的代码\n\n```ts\nimport { ServerContext } from './../index';\nimport picocolors from \"picocolors\";\nimport { getShortName } from \"./utils\";\nexport function bindingHMREvents(serverContext: ServerContext) {\n  const { watcher, ws, root } = serverContext;\n  watcher.on(\"change\", async (file) => {\n    console.log(`✨${picocolors.blue(\"[hmr]\")} ${picocolors.green(file)} changed`);\n    const { moduleGraph } = serverContext;\n    await moduleGraph.invalidateModule(file);\n    let arr = moduleGraph.getboundaries(\"/\" + getShortName(file, root)).map(item => ({\n      type: \"js-update\",\n      timeStamp: Date.now(),\n      path: item,\n      acceptedPath: item\n    }))\n    ws.send({\n      type: \"update\",\n      updates: arr,\n    })\n  })\n}\n```\n这里是监听文件变化，如果文件发送变化，则使用`ws`发动更新信息，通知客户端，这里有个边界寻找方法`moduleGraph.getboundaries(\"/\" + getShortName(file, root))`这个方法会帮助我们找到所有的依赖此文件的父级。\n\n这是一个虚拟模块，它会将`src\\node\\plugins\\hmr\\client.ts`中的代码注入到客户端中\n\n```ts\n//src\\node\\plugins\\clientInject.ts\nimport { CLIENT_PUBLIC_PATH, HMR_PORT } from \"../contants\";\nimport { Plugin } from \"./plugin\";\nimport fs from \"fs-extra\";\nimport esbuild from \"esbuild\"\nimport path from \"path\";\nimport { ServerContext } from \"../../index\";\nfunction clientInjectPlugin(): Plugin {\n  let serverContext: ServerContext;\n  return {\n    name: \"m-vite:client-inject\",\n    configureServer(s) {\n      serverContext = s\n    },\n    resolveId(id) {\n      if (id === CLIENT_PUBLIC_PATH) {\n        return { id }\n      }\n      return null\n    },\n    async load(id) {\n      if (id === CLIENT_PUBLIC_PATH) {\n\n        let realpath = path.join(import.meta.dirname, \"hmr\", \"client.ts\");\n        let { code } = await esbuild.transform(await fs.readFile(realpath, \"utf-8\"), {\n          loader: \"ts\",\n          target: \"esnext\"\n        })\n        code = code.replace(\"__HMR_PORT__\", JSON.stringify(HMR_PORT));\n        return code\n      }\n\n    },\n    transformIndexHtml(raw) {\n      return raw.replace(/(<head[^>]*>)/i, `$1<script type=\"module\" src=\"${CLIENT_PUBLIC_PATH}\"></script>`)\n    }\n  }\n}\nexport { clientInjectPlugin }\n\n```\n与此同时，`src\\node\\plugins\\importAnalysis.ts`中也要修改一下`code`，方便客户端使用。\n\n```ts\n      if (!id.includes(\"node_modules\")) {\n        let res = Array.from(getboundaries(curmod, new Set()));\n        ms.prepend(`import { createHotContext as __vite__createHotContext } from \"${CLIENT_PUBLIC_PATH}\";` + `import.meta.hot = __vite__createHotContext(${JSON.stringify(cleanUrl(curmod.url))},${JSON.stringify(res)});`)\n      }\n\n\n```\n\n\n这里我们建立websocket的链接，一旦我们接受到服务器的信息，就会执行`handleMessage`方法；\n```ts\nconst socket = new WebSocket(`ws://localhost:__HMR_PORT__`, \"vite-hmr\");\nlet boundaries: any;\nsocket.addEventListener(\"message\", async ({ data }) => {\n\n  handleMessage(JSON.parse(data)).catch(console.error)\n});\n```\n\n\n```ts\nasync function handleMessage(payload: any) {\n  switch (payload.type) {\n    case \"connection\":\n      console.log(`[vite] connected.`);\n      setInterval(() => socket.send(\"ping\"), 1000);\n      break;\n    case \"update\":\n      console.log(payload.updates)\n      payload.updates.forEach((update: any) => {\n        if (update.type === \"js-update\") {\n          fetchUpdate(update)\n        }\n      })\n      break;\n  }\n}\n\n```\n我们会使用心跳检测，去判断是否能链接上服务器，如果能链接上，则会发送一个心跳包\n如果是服务端发送的更新请求，则会调用`fetchUpdate`方法对依赖进行重新拉取\n```ts\nasync function fetchUpdate({ path, timeStamp }: any) {\n  // console.log(path)\n  const mod = hotModulesMap.get(path);\n  console.log(boundaries, \"mod---------------------\", path)\n  if (!mod) return;\n  const moduleMap = new Map();\n  const modulesToUpdate = new Set<string>();\n  modulesToUpdate.add(path);\n  // boundaries.forEach((item:string) => {\n  //   modulesToUpdate.add(item);\n  // })\n  await Promise.all(Array.from(modulesToUpdate).map(async (dep) => {\n    const [path, query] = dep.split(\"?\");\n\n    try {\n      const newMod = await import(path + `?t=${timeStamp}${query ? `&${query}` : \"\"}`);\n      moduleMap.set(dep, newMod)\n    } catch (e) {\n      console.error(e)\n    }\n  }))\n  return () => {\n    for (const { deps, fn } of mod.callbacks) {\n      fn(deps.map(dep => moduleMap.get(dep)));\n      console.log(`[vite] hot updated: ${path}`);\n    }\n  }\n}\n\n```\n这里我们就将更新过的`mod`信息，通过`fetchUpdate`方法，重新加载模块，然后执行回调函数，实现热更新。\n\n我们css的热更新也是这个方式，只不过我们是在更新的时候重新读取css文件，将文件写入style标签中，每一次更新 则是委托客户端重新引入新的css`content`文件；\n\n我们的热更新也就初步实现了\n\n但我们还有以下几个问题\n1. 写入`import.meta.hot`上面的方法，对齐热更新依赖图谱\n2. 这个热更新是摧毁式的热更新，我们该怎么处理\n\n\n我在这里抛砖引玉，这也就是剩下的一部分工作了，我先提几个点，日后有时间会续写上去的。\n\n### 5.1、探讨如何写入import.meta.hot方法和其作用\n```ts\n      if (!id.includes(\"node_modules\")) {\n        let res = Array.from(getboundaries(curmod, new Set()));\n        ms.prepend(`import { createHotContext as __vite__createHotContext } from \"${CLIENT_PUBLIC_PATH}\";` + `import.meta.hot = __vite__createHotContext(${JSON.stringify(cleanUrl(curmod.url))},${JSON.stringify(res)});`)\n      }\n\n```\n这里个方法主要目的是接受服务端的`mod`信息，构建热更新环境\n```ts\nexport const createHotContext = (ownerPath: string, arr: any) => {\n\n  boundaries = arr;\n  const mod: HotModule = hotModulesMap.get(ownerPath) || {\n    id: ownerPath,\n    callbacks: []\n  };\n  hotModulesMap.set(ownerPath, mod)\n\n  if (mod) {\n    mod.callbacks = []\n  }\n  function acceptDeps(deps: string[], callback: any) {\n\n    const mod: HotModule = hotModulesMap.get(ownerPath) || {\n      id: ownerPath,\n      callbacks: []\n    };\n    mod.callbacks.push({ deps, fn: callback });\n    hotModulesMap.set(ownerPath, mod)\n  }\n  return {\n    accept(deps: any, callback?: any) {\n\n      if (typeof deps === \"function\" || !deps) {\n        //@ts-ignore\n        acceptDeps([ownerPath], ([mod]) => deps && deps(mod))\n      }\n    },\n    prune(cb: (data: any) => void) {\n      pruneMap.set(ownerPath, cb)\n    }\n  }\n}\n\n```\n我们这里会对依赖进行收集，但这个代码并不能使用来实现毫秒级的保留状态的热更新，我们在acceptDeps方法中，并没有实现提取该依赖更新的`deps`，我们提取`deps`后，需要重新的根据`deps`引入新的代码块，来实现重新渲染，之前使用的方法则是不管其他，我们将所有相关的文件重新拉去，这里则是需要进行细化的地方，比如寻找热更新的边界，如何确定`热更新`最大影响的区域。确定后我们需要重新的对`deps`进行拉去，需要由一定的`vue-hmr`和`react-hmr`插件的支持，我们要将发送过来的`code`文本，进行重新的渲染；\n\n#### 5.2、探讨如何寻找热更新边界\n\n第二个难点是如何去进行热更新边界的判断，在`vite`源码中，是通过`propagateUpdate`这个方法递归往上查找的，如果往上查找到了热更新边界则会退出，如果没查到则会一直查下去，直到没有为止，这个代码改写难度太大了，希望各位有更好的方法融入\n\n```ts\n// 热更新边界收集\nfunction propagateUpdate(\n  node: ModuleNode,\n  boundaries: Set<{\n    boundary: ModuleNode\n    acceptedVia: ModuleNode\n  }>,\n  currentChain: ModuleNode[] = [node]\n): boolean {\n   // 接受自身模块更新\n   if (node.isSelfAccepting) {\n    boundaries.add({\n      boundary: node,\n      acceptedVia: node\n    })\n    return false\n  }\n  // 入口模块\n  if (!node.importers.size) {\n    return true\n  }\n  // 遍历引用方\n  for (const importer of node.importers) {\n    const subChain = currentChain.concat(importer)\n    // 如果某个引用方模块接受了当前模块的更新\n    // 那么将这个引用方模块作为热更新的边界\n    if (importer.acceptedHmrDeps.has(node)) {\n      boundaries.add({\n        boundary: importer,\n        acceptedVia: node\n      })\n      continue\n    }\n\n    if (currentChain.includes(importer)) {\n      // 出现循环依赖，需要强制刷新页面\n      return true\n    }\n    // 递归向更上层的引用方寻找热更新边界\n    if (propagateUpdate(importer, boundaries, subChain)) {\n      return true\n    }\n  }\n  return false\n}\n\n```\n\n\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/project/从零开始搭建vite/从koa到mini-vite(三).mdx"}},{"pageContent":"# 从 koa 到 mini-vite（二）插件容器\n\n\n这个是仓库地址\n\n[![Readme Card](https://github-readme-stats.vercel.app/api/pin/?username=Manshawar&repo=koa_vite)](https://github.com/Manshawar/koa_vite)\n\n### 1、什么是插件容器\n\nvite 的插件容器是使用的管线设计模式，其设计参考了 rollup 的插件机制\n\n- 在生产环境中 Vite 直接调用 Rollup 进行打包，所以 Rollup 可以调度各种插件；\n- 在开发环境中，Vite 模拟了 Rollup 的插件机制，设计了一个 PluginContainer 对象来调度各个插件。\n### 2、插件容器的流程以及和vite的关系\n插件顺序\n\n一个 Vite 插件可以额外指定一个 enforce 属性（类似于 webpack 加载器）来调整它的应用顺序。enforce 的值可以是 pre 或 post。解析后的插件将按照以下顺序排列：\n\n- Alias\n- 带有 enforce: 'pre' 的用户插件\n- Vite 核心插件\n- 没有 enforce 值的用户插件\n- Vite 构建用的插件\n- 带有 enforce: 'post' 的用户插件\n- Vite 后置构建插件（最小化，manifest，报告）\n\n相当数量的 Rollup 插件将直接作为 Vite 插件工作（例如：@rollup/plugin-alias 或 @rollup/plugin-json），但并不是所有的，因为有些插件钩子在非构建式的开发服务器上下文中没有意义。\n\n一般来说，只要 Rollup 插件符合以下标准，它就应该像 Vite 插件一样工作：\n\n没有使用 moduleParsed 钩子。\n它在打包钩子和输出钩子之间没有很强的耦合。\n如果一个 Rollup 插件只在构建阶段有意义，则在 build.rollupOptions.plugins 下指定即可。它的工作原理与 Vite 插件的 enforce: 'post' 和 apply: 'build' 相同。\n\n你也可以用 Vite 独有的属性来扩展现有的 Rollup 插件:\n\n```js\nimport example from \"rollup-plugin-example\";\nimport { defineConfig } from \"vite\";\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...example(),\n      enforce: \"post\",\n      apply: \"build\",\n    },\n  ],\n});\n```\n\n从官网上获取的信息来看，我们的插件容器是和rollup高度一致的，我们先建立ts类型文件\n```ts\n// src/node/pluginContainer.ts\nimport type {\n  LoadResult,\n  PartialResolvedId,\n  SourceDescription,\n  PluginContext as RollupPluginContext,\n  ResolvedId,\n} from \"rollup\";\n\nexport interface PluginContainer {\n  resolveId(id: string, importer?: string): Promise<PartialResolvedId | null>;\n  load(id: string): Promise<LoadResult | null>;\n  transform(code: string, id: string): Promise<SourceDescription | null>;\n}\n\n```\n插件容器基本为rollup插件的封装，所以我们的类型也应该保持一致；\n来看看最核心的插件容器代码\n```ts\nexport const createPluginContainer = (plugins: Plugin[]): PluginContainer => {\n  // 插件上下文对象\n  // @ts-ignore 这里仅实现上下文对象的 resolve 方法\n  class Context implements RollupPluginContext {\n    async resolve(id: string, importer?: string) {\n      let out = await pluginContainer.resolveId(id, importer);\n      if (typeof out === \"string\") out = { id: out };\n      return out as ResolvedId | null;\n    }\n  }\n  // 插件容器\n  const pluginContainer: PluginContainer = {\n    async resolveId(id: string, importer?: string) {\n      const ctx = new Context() as any;\n      for (const plugin of plugins) {\n        if (plugin.resolveId) {\n          const newId = await plugin.resolveId.call(ctx as any, id, importer);\n          if (newId) {\n            id = typeof newId === \"string\" ? newId : newId.id;\n            return { id };\n          }\n        }\n      }\n      return null;\n    },\n    async load(id) {\n      const ctx = new Context() as any;\n      for (const plugin of plugins) {\n        if (plugin.load) {\n          const result = await plugin.load.call(ctx, id);\n          if (result) {\n            return result;\n          }\n        }\n      }\n      return null;\n    },\n    async transform(code, id) {\n      const ctx = new Context() as any;\n      for (const plugin of plugins) {\n        if (plugin.transform) {\n          const result = await plugin.transform.call(ctx, code, id);\n          if (!result) continue;\n          if (typeof result === \"string\") {\n            code = result;\n          } else if (result.code) {\n            code = result.code;\n          }\n        }\n      }\n      return { code };\n    },\n  };\n\n  return pluginContainer;\n};\n\n```\n\n这个后续会添加到我们的koa中间件中，先来看看他的每个函数方法代表什么\n\n### 3、插件容器的方法解析\n\n**resolveId**\n\n我们来看我们`pluginContainer`第一个方法`resolveId`\n他做了什么事情呢，他会解析我们的路径，事实上，他的工作是帮我们筛选路径\n```js\n async resolveId(id, importer) {\n      const ctx = new Context();\n      for (const plugin of plugins) {\n        if (plugin.resolveId) {\n          const newId = await plugin.resolveId.call(ctx, id, importer);\n          if (newId) {\n            id = typeof newId === 'string' ? newId : newId.id;\n            return newId;\n          }\n        }\n      }\n      return null\n    },\n\n```\n此方法会接受两个参数，一个是id，一个是importer，id是当前路径，importer的其入口文件\n```js\n//a.tsx\nimport b from './b'\n```\n我们在读取`./b`的时候 ，id是b，importer是a.tsx;这个方法在后期的引入路径解析和模块依赖开发中十分有效；\n```ts\n  class Context implements RollupPluginContext {\n    async resolve(id: string, importer?: string) {\n      let out = await pluginContainer.resolveId(id, importer);\n      if (typeof out === \"string\") out = { id: out };\n      return out as ResolvedId | null;\n    }\n  }\n```\n我们会看到我们在方法执行的第一步，`const ctx = new Context();`这个方法会帮助我们创建一个上下文对象，他将我们的resolve插件方法，挂载到了`Context`上，这个方法继承于`RollupPluginContext`,我们后续可以使用`this`，在每一个插件中去调用路径处理方法；\n\n```ts\nfor (const plugin of plugins) {\n        if (plugin.resolveId) {\n          const newId = await plugin.resolveId.call(ctx, id, importer);\n          if (newId) {\n            id = typeof newId === 'string' ? newId : newId.id;\n            return newId;\n          }\n        }\n      }\n```\n这里会遍历我们后续书写的插件，调用每一个插件上的`resolveId`方法，调用该方法时，其`this`会指向我们创建的`ctx`；如果我们能得到新的id返回值，如果存在。则会将其返回，不存在则返回null；\n\n**load**\n\n```ts\n    async load(id) {\n      const ctx = new Context();\n      for (const plugin of plugins) {\n        if (plugin.load) {\n          const res = await plugin.load.call(ctx, id);\n          if (res) {\n            return res\n          }\n        }\n      }\n      return null\n    },\n\n```\n我们`load`方法，实际上和上文的`resolve`方法时一致的，**这两个方法都会在有返回值的时候将循环中断**。我们的路径和对应的代码片段，应该时在找到时就返回了，而不是循环遍历完所有的插件；\n\n**transform**\n\n```ts\n async transform(code, id) {\n      const ctx = new Context();\n      for (const plugin of plugins) {\n        if (plugin.transform) {\n          code = code.trim()\n          const res = await plugin.transform.call(ctx, code, id);\n          if (!res) {\n            continue\n          }\n          if (typeof res === 'string') {\n            code = res\n          } else {\n            code = res.code\n          }\n        }\n      }\n      return { code }\n    }\n```\ntransform方法他会接受`load`的返回值`code`，和其处理的`id`；这里的处理和上文`resolve`和`load`不一致，他会在获取到值后持续循环，并不会退出，code每一次在循环中重新赋值，最后会返回所有transform处理后的code；\n\n下面开始会在处理流程上进行解析\n\n### 4、上下文环境\n```ts\nimport { indexHtmlMiddware } from \"./node/middlewares/indexHtml\";\nimport { transformMiddleware } from \"./node/middlewares/transformMiddleware\";\nconst root = process.cwd();\n\nexport interface ServerContext {\n  root: string;\n  PluginContainer: PluginContainer,\n  app: Koa;\n  plugins: Plugin[]\n\n}\nconst plugins = resolvePlugins();\nconst PluginContainer = createPluginContainer(plugins)\nconst serverContext: ServerContext = {\n  root: process.cwd(),\n  PluginContainer,\n  app,\n  plugins: plugins\n}\nfor (const plugin of plugins) {\n  if (plugin.configureServer) {\n    await plugin.configureServer(serverContext)\n  }\n}\napp.use(indexHtmlMiddware(serverContext));\napp.use(transformMiddleware(serverContext));\n```\n`resolvePlugins`这个方法返回的是一个插件数组，如`[resolvePath(),esbuildTransformPlugin(),importAnalysisPlugin()]`;我们的服务端上下文环境是一个对象，他包含根目录对象，插件容器，koa实例，以及插件数组，我们会将上下文环境分发给每一个中间件\n```ts\nfor (const plugin of plugins) {\n  if (plugin.configureServer) {\n    await plugin.configureServer(serverContext)\n  }\n}\n```\n此处是将插件中，每一个`configureServer`钩子中，能获取到服务器环境的上下文环境，我们后续会用到；\n### 5、html文件的读取\n```ts\nimport path from \"path\";\nimport fs from \"fs-extra\";\nimport { ServerContext } from \"../../index\";\nimport { Middleware } from \"koa\";\nexport function indexHtmlMiddware(serverContext: ServerContext): Middleware {\n  return async (ctx, next) => {\n    const { res, req } = ctx;\n  \n    if (req.url === \"/\") {\n      const { root } = serverContext;\n      const indexHtmlPath = path.resolve(root, \"index.html\");\n      if (await fs.pathExists(indexHtmlPath)) {\n        const readHtml = await fs.readFile(indexHtmlPath, \"utf-8\");\n        let html = readHtml;\n      \n        for (const plugin of serverContext.plugins) {\n          if (plugin.transformIndexHtml) {\n            html = await plugin.transformIndexHtml(html)\n          }\n        }\n\n        res.statusCode = 200;\n        res.setHeader(\"Content-Type\", \"text/html\");\n\n        ctx.body = html\n      }\n    }\n    return next();\n\n  }\n\n}\n```\n当我们的路径为`\\`时，开始读取我们的`index.html`文件，如果存在，则读取文件内容，然后遍历我们的插件，如果存在`transformIndexHtml`方法，则调用该方法，将返回值赋值给html，最后将html返回给客户端；\n```ts\n       let html = readHtml;\n       for (const plugin of serverContext.plugins) {\n          if (plugin.transformIndexHtml) {\n            html = await plugin.transformIndexHtml(html)\n          }\n        }\n\n```\n此处的for循环会反复的遍历`transformIndexHtml`钩子，并对我们的`html`进行处理，每一次在插件循环中，只要我们的插件有对`html`处理的钩子，处理后就会对`html`重新赋值,最终将处理后的`html`返回给客户端；\n\n### 6、插件中间件\n```ts\nimport { SourceDescription } from \"rollup\"\nimport { Middleware } from \"koa\";\nimport { ServerContext } from \"../../index\";\nimport createDebug from \"debug\";\nimport { isJSRequest, cleanUrl } from \"../utils\"\nconst debug = createDebug(\"dev\");\n\n//transformRequest .......\n\n//transformRequest\nexport function transformMiddleware(serverContext: ServerContext): Middleware {\n  return async (ctx, next) => {\n    const { req, res } = ctx\n    if (req.method !== \"GET\" || !req.url) {\n      return next()\n    }\n    const url = req.url;\n    debug(\"transformMiddleware: %s\", url);\n    if (isJSRequest(url)) {\n      let resCode = await transformRequest(url, serverContext);\n\n      if (!resCode) {\n        return next();\n      }\n\n      if (resCode && typeof resCode !== \"string\") {\n        resCode = resCode.code;\n      }\n      res.statusCode = 200;\n      res.setHeader(\"Content-Type\", \"application/javascript\");\n      return res.end(resCode);\n    }\n  }\n\n}\n```\n我们的`transformRequest`方法，他会在请求会js请求的时候进行处理，可以打开谷歌控制台，我们在network中可以找到`js`区块，这个请求主要是处理script标签的src和其中的import引入；都是我们的js请求，这里的会有一个正则进行校验`/\\.(?:j|t)sx?$|\\.mjs$/`;\n我们的插件容器，最后会返回一个js片段出来，这个片段则是我们给客户端的代码片段\n我们来看看`transformRequest`; 是怎么对插件进行处理的\n```ts\nasync function transformRequest(url: string, serverContext: ServerContext): Promise<SourceDescription | null | string | undefined> {\n  const { PluginContainer } = serverContext;\n  url = cleanUrl(url);\n  let res;\n  let resolveId = await PluginContainer.resolveId(url);\n  if (resolveId?.id) {\n    let code = await PluginContainer.load(resolveId?.id);\n    if (typeof code === \"object\" && code !== null) {\n      code = code.code\n    }\n    if (code) {\n      res = await PluginContainer.transform(code, resolveId?.id);\n    }\n  }\n\n  return res\n}\n\n```\n我们可以看到具体的处理流程\n1. 使用`resolveId`方法先对路径进行处理，判断路径是否存在\n2. 如果路径存在，则通过`load`方法获取code，判断代码是否存在\n3. 如果代码存在吗，则对代码片段使用transform进行处理，这个处理于上文不同的是，他会将每一个`plugin`的`transform`钩子进行调用，拿到最终值\n\n### 7、插件\n```js\n// plugins/index.ts\nimport { Plugin } from \"./plugin\";\nimport { allin } from \"./allin\";\nimport { resolvePath } from \"./resolve\";\nimport { esbuildTransformPlugin } from \"./esbuild\";\nimport { importAnalysisPlugin } from \"./importAnalysis\"\nexport const resolvePlugins = (): Plugin[] => {\n  return [\n    // allin(),\n    resolvePath(),\n    esbuildTransformPlugin(),\n    importAnalysisPlugin()\n  ]\n}\n```\n这三个插件是vite的基石插件，我这边写了一个allin的插件，一个插件总和了其他插件的功能，可以在代码库中阅读该代码进一步理解\n#### 7-1、resolvePath插件\n\n```ts\nimport { ServerContext } from './../../index';\nimport resolve from \"resolve\";\nimport { Plugin } from \"./plugin\";\n\nimport path from \"path\";\nimport fs, { pathExists } from \"fs-extra\";\nimport { DEFAULT_EXTERSIONS } from \"../contants\";\nimport { cleanUrl, normalizePath } from \"../utils\";\nexport function resolvePath(): Plugin {\n  let serverContext: ServerContext\n  return {\n    name: \"resolvePlugin\",\n    configureServer(s) {\n      serverContext = s\n    },\n    async resolveId(id, importer) {\n      if (path.isAbsolute(id)) {\n        if (await pathExists(id)) {\n          return {\n            id\n          }\n        }\n        id = path.join(serverContext.root, id);\n        if (await pathExists(id)) {\n          return {\n            id\n          }\n        }\n      } else if (id.startsWith(\".\")) {\n        if (!importer) {\n          throw new Error(\"`importer` should not be undefined\");\n        }\n        const hasExtension = path.extname(id).length > 1;\n        let resolvedId: string;\n      \n        if (hasExtension) {\n          //请于test中查看resolve.test.ts测试\n        \n          resolvedId = normalizePath(resolve.sync(id, { basedir: path.dirname(importer) }));\n          if (await pathExists(resolvedId)) {\n            return {\n              id: resolvedId,\n            }\n          }\n        } else {\n          \n          for (const extname of DEFAULT_EXTERSIONS) {\n            try {\n              const withExtension = `${id}${extname}`;\n           \n              resolvedId = normalizePath(resolve.sync(withExtension, {\n                basedir: path.dirname(importer),\n              }));\n            \n              if (await pathExists(resolvedId)) {\n            \n                return {\n                  id: resolvedId\n                }\n              }\n            } catch (error) {\n              continue\n            }\n          }\n        }\n      }\n      return null\n    },\n\n\n  }\n}\n\n```\n这个插件主要是对路径进行处理\n1. 第一个if是处理绝对路径，绝对路径找到后直接返回，如果没找到进一步拼接服务器地址再进行查找\n2. else if的处理主要是针对`./`相对路径的处理，处理后对其后缀名进行查验\n3. 如果存在存在文件拓展名，会使用resolve方法处理引入路径，通过相关关系获取到对应的文件路径\n4. 如果不存在拓展名，会去循环查找所有的拓展名，如果存在就返回对应的文件路径，否则返回null\n\n\n这里是一个测试代码，用于测试resolve方法\n以下是测试代码\n```ts\nimport resolve from \"resolve\";\nimport path from \"path\";\n\ntest('resolveImporter', () => {\n  let id = \"./App.tsx\";\n  let importer = \"src/client/main.tsx\"\n  let res = resolve.sync(id, { basedir: path.dirname(importer) });\n  expect(res).toBe(`D:\\code\\study\\vite\\minivite\\koaVite\\src\\client\\App.tsx`);\n});\n```\n\n#### 7-2、esbuildTransformPlugin插件\n这个插件主要是用于帮助我们获取对应的`code`片段；\n```ts\nimport { Plugin } from \"./plugin\";\nimport { isJSRequest } from \"../utils\";\nimport path from \"path\";\nimport fs from \"fs-extra\";\nimport esbuild from \"esbuild\";\nexport function esbuildTransformPlugin(): Plugin {\n  return {\n    name: \"esbuild-transform\",\n    async load(id) {\n      if (isJSRequest(id)) {\n        try {\n          let code = await fs.readFile(id, \"utf-8\");\n          return code\n        } catch (error) {\n          return null\n        }\n      }\n    },\n    async transform(code, id) {\n      if (isJSRequest(id)) {\n        const extname = path.extname(id).slice(1);\n        const { code: resCode, map } = await esbuild.transform(code, {\n          target: \"esnext\",\n          format: \"esm\",\n          sourcemap: true,\n          loader: extname as \"js\" | \"ts\" | \"jsx\" | \"tsx\",\n        })\n        return {\n          code: resCode,\n          map\n        }\n      }\n      return null\n    }\n  }\n\n}\n\n```\n这个插件有两步，一是读取对应的`code`片段，二是对其`code`片段使用`esbuild`进行处理；\n\n1. load方法，通过`fs`读取对应的`code`片段，如果存在就返回，否则返回null\n2. transform方法，此处处理后返回值`code`会作为下一个钩子的参数进行处理\n3. 在transform的处理中，我们获取到对应的拓展名作为esbuild的loader参数\n4. 通过esbuild生成打包后的代码片段和源代码映射，返回给下一个钩子进行处理\n\n\n#### 7-3、importAnalysisPlugin插件\n```ts\nimport { Plugin } from \"./plugin\";\nimport {\n  BARE_IMPORT_RE,\n  DEFAULT_EXTERSIONS,\n  PRE_BUNDLE_DIR,\n} from \"../contants\";\nimport { ServerContext } from \"../../index\";\nimport { init, parse } from \"es-module-lexer\";\nimport MagicString from \"magic-string\";\nimport {\n  cleanUrl,\n  isJSRequest,\n  normalizePath\n} from \"../utils\";\nimport path from \"path\";\n\nexport function importAnalysisPlugin(): Plugin {\n  let serverContext: ServerContext;\n  return {\n    name: \"m-vite:import-analysis\",\n    configureServer(s) {\n      serverContext = s\n    },\n    async transform(code, id) {\n      const resolve = async (id: string, importer?: string) => {\n        let resolved = await serverContext.PluginContainer.resolveId(id, normalizePath(importer as string));\n\n        if (!resolved) {\n          return\n        }\n        const relPath = resolved.id.startsWith(\"/\") ? resolved.id : normalizePath(\n          path.join('/', path.relative(serverContext.root, resolved.id))\n        );\n        return relPath\n      }\n      if (!isJSRequest(id)) {\n        return null\n      }\n      await init;\n      const [imports] = parse(code);\n      const ms = new MagicString(code);\n\n      for (const importInfo of imports) {\n        const { s: modStart, e: modEnd, n: modSource } = importInfo;\n        if (!modSource) continue;\n        if (BARE_IMPORT_RE.test(modSource as string)) {\n          const bundlePath = normalizePath(\n            path.join('/', PRE_BUNDLE_DIR, `${modSource}.js`)\n          );\n          ms.overwrite(modStart, modEnd, bundlePath as string)\n        } else if (modSource.startsWith(\".\") || modSource.startsWith(\"/\")) {\n          const resolved = await resolve(modSource, id) as string;\n          if (resolved) {\n            ms.overwrite(modStart, modEnd, resolved)\n          }\n        }\n      }\n      return {\n        code: ms.toString(),\n        map: ms.generateMap()\n      }\n    }\n  }\n}\n\n```\n\n我们由main.tsx开始，来看看他是如何进行处理的\n- 解析出真实的路`D:\\code\\study\\vite\\minivite\\koaVite\\src\\client\\main.tsx`\n- 在上一个插件中读取代码，通过`esbuild`打包并返回\n- 首先通过`isJSRequest`判断是否是js请求，如果不是就直接返回null\n- 通过`init`初始化es-module-lexer，然后获取到对应的`imports`\n- `magic-string`环境搭建，方便后续处理\n- 处理`main.tsx`中的`import React from \"react\";import App from \"./App\"`进行处理，这是两种情况，一种为裸引入，一种为相对路径的处理\n- `react`是`bare`裸引入，满足`BARE_IMPORT_RE`条件，将其指向我们上文`PRE_BUNDLE_DIR`进行预构建的目录下也就是`/node_modules/.m-vite/react.js`\n- 处理完后，使用`magic-string`改写路径，将`import React from \"react\"`改写为`import React from \"/node_modules/.m-vite/react.js\";`\n- 如果是相对路径，则进入`resolve`方法进行处理\n- resolve方法会将路径改写为`import App from \"/src/client/App.tsx\";`\n- 通过不停的改写`import`路径，将每一个代码文件中的相对引入改写为绝对路径，便于我们的`node`服务器找到其真实存在的路径\n\n\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/project/从零开始搭建vite/从koa到mini-vite(二).mdx"}},{"pageContent":"### 基本操作方法\n\n1. !符号，系统宏使用这个\n2. use std::io 引入 想象成 std.io\n3. 变量名前添加 `mut`（mutability，可变性）let mut bananas = 5;\n4. `::new` 那一行的 `::` 语法表明 `new` 是 `String` 类型的一个关联函数\n5. read_line(&mut guess) `&` 表示这个参数是一个**引用**\n6. `{}` 也可以打印多个值：第一对 `{}` 使用格式化字符串之后的第一个值，第二对则使用第二个值，\n7. use rand::Rng `Rng` 是一个 trait，它定义了随机数生成器应实现的方法\n8. 区间表达式采用的格式为 `start..end 1..=100`\n9. `cargo doc --open` 命令来构建所有本地依赖提供的文档;\n10. 不过 Rust 允许用一个新值来**遮蔽**\n11. loop 循环 会持续循环内容 知道 break 退出 continu 中断进入下一次循环\n12. match 可以比较多次情况，选项为 Ok 和 Err 时能代替 expect\n\n## 1、基本概念\n\n### 1-1、变量和可变性\n\n#### 1-1-1-1、 可变性\n\n```rust\nlet space = \"     \";\nlet space = space.len();\n这样可以遮蔽 但如果你使用变量 则会报错 因为我们不能修改变量的类型 涉及到变量类型的修改需要遮蔽\n错误示例\nlet mut spaces = \"   \";\n spaces = spaces.len();\n```\n\n### 1-2、数据类型\n\n#### 1-2-1、基本数据类型\n\n**标量** （ _scalar_ ）类型表示单个值。Rust 有 4 个基本的标量类型：整型、浮点型、布尔型和字符\n\ni&u 可选值 8，16，32，64，128，size\n\n整型\n\n`i` 是英文单词 _integer_ 的首字母，与之相反的是 `u`,`u无符号 i有符号`\n\n| 类型 |       存储数字范围       |   十进制   |\n| :--- | :----------------------: | :--------: |\n| i8   | $-(2 ^7^ ) ~ 2^7^ - 1$ | -128 ~ 127 |\n| u8   |     $0 ~ 2^8^ - 1$     |  0 ~ 255  |\n\n数字字面量还可以使用 `_` 作为可视分隔符以方便读数，如 `1_000`，此值和 `1000` 相同\n\n整数溢出 在 `u8` 的情况下，256 变成 0，257 变成 1，依此类推\n\n| 类型 | 知识点               |\n| ---- | -------------------- |\n| 浮点 | f64(default)更加精准 |\n| 布尔 | bool                 |\n\n#### 1-2-2、符合数据类型\n\n1、元组类型\n\n```rust\n let tup: (i32, f64, u8) = (500, 6.4, 1);\ntup.0\n let (x,y,z) = tup\n```\n\n2、数组类型\n\n明确元素数量不需要改变时，数组会更有用,大小**允许**增长或缩小。如果不确定是使用数组还是 vector，那就应该使用一个 vector\n\n```rust\nlet a: [i32; 5] = [1, 2, 3, 4, 5];\nlet a=[3;5] 等效于let a = [3, 3, 3, 3, 3]\n```\n\n### 1-3、函数\n\nRust 代码中的函数和变量名使用下划线命名法（ _snake case_ ，直译为蛇形命名法）规范风格 another_function\n\n函数调用是一个表达式。宏调用是一个表达式。我们用来创建新作用域的大括号（代码块） `{}` 也是一个表达式，表达式的结尾没有分号。如果在表达式的末尾加上分号，那么它就转换为语句，而语句不会返回值。\n\n> 返回值\n\n1. 在 Rust 中，函数的返回值等同于函数体最后一个表达式的值\n2. 使用 `return` 关键字和指定值，可以从函数中提前返回；但大部分函数隐式返回最后一个表达式。\n\n```rust\n    let y = {\n        let x = 3;\n        x + 1\n    };\n    println!(\"这是y{}\", y);//这个是成立的 但加上;后，会从表达式变成语句,会报错\n\tfn five() -> i8 {\n    \treturn -2 + 2;\n\t}\n等效于\nfn five() -> i8 {\n    \t -2 + 2\n\t}\n不能加;\n```\n\n### 1-4、控制流\n\n#### 1-4-1、if\n\n`if` 是一个表达式，我们可以在 `let` 语句的右侧使用它来将结果赋值给一个变量;\n\n> `if` 的每个分支的可能的返回值都必须是相同类型；\n\n```rust\n let  condition = false;\n let number = if condition { 5 } else { 6 };\n```\n\n#### 1-4-2、循环\n\nRust 有三种循环：`loop`、`while` 和 `for`。\n\n##### loop\n\n`loop` 关键字告诉 Rust 一遍又一遍地执行一段代码直到你明确要求停止。停止关键字 break\n\n```rust\nfn loopfn() {\n    let mut x = 0;\n    let _res = loop {\n        if x == 100 {\n            break x;\n        }\n        x += 1;\n    };\n    println!(\"值{}\", x)\n}//loop新婚换可以使用break 返回出值 类似于 if\n```\n\n##### while\n\n在程序中计算循环的条件也很常见。当条件为真，执行循环。当条件不再为真，调用 `break` 停止循环。这个循环类型可以通过组合 `loop`、`if`、`else` 和 `break` 来实现；\n\n##### for\n\n可以使用 `for` 循环来对一个集合的每个元素执行一些代码。\n\n`Range`，它是标准库提供的类型，用来生成从一个数字开始到另一个数字之前结束的所有数字的序列,start..end 包左不包右\n\n```rust\nfn main() {\n    for number in (1..4).rev() {\n        println!(\"{}!\", number);\n    }\n    println!(\"LIFTOFF!!!\");\n}\n```\n\n## 2、所有权\n\n所有权规则\n\n- Rust 中的每一个值都有一个被称为其 **所有者** （ _owner_ ）的变量。\n- 值在任一时刻有且只有一个所有者。\n- 当所有者（变量）离开作用域，这个值将被丢弃。\n\n### 2-1、所有权基本概论\n\n#### 2-1-1、string\n\nRust 有第二个字符串类型，`String`。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 `from` 函数基于字符串字面量来创建 `String`\n\n双冒号（`::`）运算符允许我们将特定的 `from` 函数置于 `String` 类型的命名空间（namespace）下,而不需要使用类似 `string_from` 这样的名字\n\n```rust\nlet s = String::from(\"hello\");\n s.push_str(\", world!\"); // push_str() 在字符串后追加字面值\n```\n\n#### 2-1-2、移动\n\n栈内存\n\n所以这两个 `5` 被放入了栈中\n\n```rust\n let x = 5;\n let y = x;\n```\n\n以下的代码会对指针产生移动，为了性能考虑，并不会赋值堆内存，而是移动其指针\n\nRust 同时使第一个变量无效了，这个操作被称为 **移动** （ _move_ ）\n\n```rust\n   let s1 = String::from(\"hello\");\n   let s2 = s1;\n//这段代码不能运行\n//当变量离开作用域后，Rust 自动调用 drop 函数并清理变量的堆内存。\n```\n\n两个指针指向同一个堆，这样会导致在离开时进行两次释放，这是一个叫做 **二次释放** （ _double free_ ）的错误\n\nRust 永远也不会自动创建数据的 “深拷贝”。因此，任何 **自动** 的复制可以被认为对运行时性能影响较小。\n\n#### 2-1-3、克隆\n\n可以使用一个叫做 `clone` 的通用函数\n\n```rust\n let s1 = String::from(\"hello\");\n let s2 = s1.clone();\n\n println!(\"s1 = {}, s2 = {}\", s1, s2);\n```\n\n#### 2-1-4、拷贝\n\n```rust\n   let x = 5;\n   let y = x;\n\n   println!(\"x = {}, y = {}\", x, y);\n```\n\n像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的\n\nRust 有一个叫做 `Copy` trait 的特殊标注，可以用在类似整型这样的存储在栈上的类型上\n\n#### 2-1-5、所有权函数\n\n将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。\n\n```rust\nfn main() {\n    let s: String = String::from(\"hello\");\n    let s1: String = s.clone();\n    takes_ownership(s);\n    println!(\"smain{}\", s1);\n\n    let x = 5; // x 进入作用域\n\n    makes_copy(x);\n    println!(\"xmain{}\", x);\n}\nfn takes_ownership(s: String) {\n    println!(\"s,{}\", s)\n}\nfn makes_copy(some_integer: i32) {\n    // some_integer 进入作用域\n    println!(\"{}\", some_integer);\n}\n```\n\n传入值进入函数 栈类型会重新赋值\n\n传入堆的值，会将指针改变指向，因为后续指针变了所以 s 的值就没有了。形参 s 的指针就指向实参的堆了\n\n返回值也可以转移所有权\n\n我们可以使用元组来返回多个值\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let (s2, len) = calculate_length(s1);\n\n    println!(\"The length of '{}' is {}.\", s2, len);\n}\n\nfn calculate_length(s: String) -> (String, usize) {\n    let length = s.len(); // len() 返回字符串的长度\n\n    (s, length)\n}\n```\n\n### 2-2、引用\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n    let s1 = String::from(\"hello\");\n    let len = calculate_length(&s1);\n    println!(\"len{},s1{}\", len, s1);\n}\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n//传入后都不会改变指针位置\n```\n\n& 符号就是 **引用** ，它们允许你使用值但不获取其所有权。\n\n> 注意：与使用 `&` 引用相反的操作是 **解引用** （ _dereferencing_ ），它使用解引用运算符，`*`。\n\n函数签名使用 `&` 来表明参数 `s` 的类型是一个引用；\n\n可变引用\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(\", world\");\n}\n```\n\n可变引用有一个很大的限制：在同一时间，只能有一个对某一特定数据的可变引用。尝试创建两个可变引用的代码将会失败\n\n```rust\n let mut s = String::from(\"hello\");\n\n    let r1 = &mut s;\n    let r2 = &mut s;\n\n    println!(\"{}, {}\", r1, r2);\n数据竞争，rust不会编译\n* 两个或更多指针同时访问同一数据。\n* 至少有一个指针被用来写入数据。\n* 没有同步数据访问的机制。\n```\n\n可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 **同时** 拥有\n\n```rust\n    let mut s = String::from(\"hello\");\n\n    {\n        let r1 = &mut s;\n    } // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用\n\n    let r2 = &mut s;\n```\n\n```rust\n    let mut s = String::from(\"hello\");\n\n    let r1 = &s; // 没问题\n    let r2 = &s; // 没问题\n    let r3 = &mut s; // 大问题\n\n    println!(\"{}, {}, and {}\", r1, r2, r3);\n```\n\n可变会通过指针访问堆数据，如果不用 mut,&仅仅是借用，无法进行修改，没有存在所有权在&中；\n\n不能在拥有不可变引用的同时拥有可变引用，多个不可变引用是可以的\n\n> 一个引用的作用域从声明的地方开始一直持续到最后一次使用为止\n\n```rust\nlet mut s = String::from(\"hello\");\n\n    let r1 = &s; // 没问题\n    let r2 = &s; // 没问题\n    println!(\"{} and {}\", r1, r2);\n    // 此位置之后 r1 和 r2 不再使用\n\n    let r3 = &mut s; // 没问题\n    println!(\"{}\", r3);\n    let r4 = &mut s; // 没问题\n    println!(\"r4{}\", r4);\n//不可变引用 r1 和 r2 的作用域在 println! 最后一次使用之后结束，这也是创建可变引用 r3 的地方。它们的作用域没有重叠，所以代码是可以编译的\n```\n\n#### 2-2-1、悬垂指针\n\n    悬垂指针是其指向的内存可能已经被分配给其它持有者\n\n```rust\nfn dangle() -> &String { // dangle 返回一个字符串的引用\n\n    let s = String::from(\"hello\"); // s 是一个新字符串\n\n    &s // 返回字符串 s 的引用\n} // 这里 s 离开作用域并被丢弃。其内存被释放。\n  // 危险！\n```\n\n#### 2-2-2、引用总结\n\n- 在任意给定时间，**要么** 只能有一个可变引用，**要么** 只能有多个不可变引用。\n- 引用必须总是有效的。\n- 如果要有多个可用，需要不在一个作用域内\n- 一个引用的作用域从声明的地方开始一直持续到最后一次使用为止\n\n### 2-3、切片 slice\n\n另一个没有所有权的数据类型是 _slice_ 。slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。\n\n#### 2-3-1、**字符串 slice**\n\n```rust\n   let s = String::from(\"hello world\");\n\n    let hello = &s[0..5];\n    let world = &s[6..11];\n    let slice = &s[0..2];\n    let slice = &s[..2];\n    let slice = &s[3..len];\n    let slice = &s[3..];\n    let slice = &s[0..len];\n    let slice = &s[..];\n```\n\n“字符串 slice” 的类型声明写作 `&str`\n\n字符串 slice，正如你想象的那样，是针对字符串的。不过也有更通用的 slice 类型。考虑一下这个数组\n\n## 3、结构体组织关联数据\n\n### 3-1、定义\n\n#### 3-1-1、结构体\n\n类似于对象\n\n```rust\n\n#[derive(Debug)]\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\nfn main() {\n    let mut user1 = User {\n        email: String::from(\"hello.com\"),\n        active: true,\n        username: String::from(\"姬霓太美\"),\n        sign_in_count: 123456,\n    };\n    user1.email = String::from(\"我是你的谁.com\");\n    // println!(\"{:?}\", user1);\n    test_fn(&mut user1);\n    println!(\"{:?}\", user1);\n}\n\nfn test_fn(test: &mut User) {\n    test.sign_in_count = 5;\n    println!(\"{:?}\", test);\n}\n\n```\n\n注意 所有权机制\n\n**字段初始化简写语法**\n\n```rust\nfn build_user(email: String, username: String) -> User {\n    User {\n        email,\n        username,\n        active: true,\n        sign_in_count: 1,\n    }\n}\n```\n\n`..` 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值 `..user1` 必须放在最后\n\n```rust\n.. 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。\n  let user2 = User {\n        username: String::from(\"马喽\"),\n        ..user1\n    };\n```\n\n所有权会发生移动\n\n#### 3-1-2、元组\n\n```rust\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n}\n\n//元组实际使用场景\nfn main() {\n    let rect1 = (30, 50);\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(rect1)\n    );\n}\n\nfn area(dimensions: (u32, u32)) -> u32 {\n    dimensions.0 * dimensions.1\n}\n```\n\n#### 3-1-3、单元结构体\n\n你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用\n\n```rust\nstruct AlwaysEqual;\n\nfn main() {\n    let subject = AlwaysEqual;\n}\n```\n\n#### 3-1-4、打印结构体\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\"rect1 is {:?}\", rect1);\n}\n```\n\n在结构体定义之前加上外部属性 `#[derive(Debug)]`\n\n两种风格 `{:?}` `{:#?}`\n\ndbg!宏打印\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let scale = 2;\n    let rect1 = Rectangle {\n        width: dbg!(30 * scale),\n        height: 50,\n    };\n\n    dbg!(&rect1);\n}\n//[src/main.rs:14] &rect1 = Rectangle {\n    //width: 60,\n    //height: 50,\n//}\n```\n\n### 3-2、方法语法\n\n**方法** 与函数类似：它们使用 `fn` 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文，将分别在第 6 章和第 17 章讲解），并且它们第一个参数总是 `self`，它代表调用该方法的结构体实例。\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {//impl 块中的所有内容都将与 Rectangle 类型相关联\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }//在 area 的签名中，使用 &self 来替代 rectangle: &Rectangle，&self 实际上是 self: &Self 的缩写\n    fn width(&self) -> bool {\n        self.width > 0\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        rect1.area()\n    );\nprintln!(\"Hello, world!{}\", rect1.width());同名的情况下，()是方法，不加（）是值\nprintln!(\"Hello, world!{}\", rect1.width);\n}\n```\n\n> 如果想要在方法中改变调用方法的实例，需要将第一个参数改为 `&mut self `通过仅仅使用 `self` 作为第一个参数来使方法获取实例的所有权是很少见的 这种技术通常用在当方法将 `self` 转换成别的实例的时候，这时我们想要防止调用者在转换之后使用原始的实例。\n\n> 当我们在 `rect1.width` 后面加上括号时。Rust 知道我们指的是方法 `width`。当我们不使用圆括号时，Rust 知道我们指的是字段 `width`。\n\n#### 3-2-1、关联函数\n\n所有在 `impl` 块中定义的函数被称为 **关联函数** （ _associated function_ ）\n\n我们可以定义不以 `self` 为第一参数的关联函数（因此不是方法）\n\n```rust\nimpl Rectangle {\n    fn square(size: u32) -> Rectangle {\n        Rectangle {\n            width: size,\n            height: size,\n        }\n    }\n}\n```\n\n使用结构体名和 `::` 语法来调用这个关联函数：比如 `let sq = Rectangle::square(3);`。这个方法位于结构体的命名空间中：`::` 语法用于关联函数和模块创建的命名空间。第 7 章会讲到模块。\n\n> **区别 关联函数需要通过::语法调用**\n\n#### 3-2-2、多个 impl 块\n\n```rust\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\n\nimpl Rectangle {\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n}\n```\n\n## 4、枚举和模式匹配\n\n### 4-1、枚举\n\n`枚举::枚举值`\n\n#### 4-1-1、定义枚举\n\n```rust\n#[derive(Debug)]\nenum IpAddrkind {\n    V4,\n    V6,\n}\nstruct IpAddr {\n    kind: IpAddrkind,\n    address: String,\n}\nfn main() {\n    let four = dbg!(IpAddrkind::V4);\n    let six = IpAddrkind::V6;\n    dbg!(four);\n    route(IpAddrkind::V4);\n    route(IpAddrkind::V6);\n    let home = IpAddr {\n        kind: IpAddrkind::V4,\n        address: String::from(\"127.0.0.1\"),\n    };\n    let loopback = IpAddr {\n        kind: IpAddrKind::V6,\n        address: String::from(\"::1\"),\n    };\n}\nfn route(ip_type: IpAddrkind) {}\n\n```\n\n注意枚举的成员位于其标识符的命名空间中，并使用两个冒号分开。这么设计的益处是现在 `IpAddrKind::V4` 和 `IpAddrKind::V6` 都是 `IpAddrKind` 类型的。例如，接着可以定义一个函数来获取任何 `IpAddrKind`：\n\n#### 4-1-2、枚举成员\n\n```rust\n    #[derive(Debug)]\n    enum IpAddr {\n        V4(String),\n        V6(String),\n    }\n    let home = IpAddr::V4(String::from(\"127.0.0.1\"));\n    let loopback = IpAddr::V6(String::from(\"::1\"));\n    println!(\"home,{:?}\", home)\n```\n\n我们直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体了\n\n每个成员可以处理不同类型和数量的数据。IPv4 版本的 IP 地址总是含有四个值在 0 和 255 之间的数字部分。如果我们想要将 `V4` 地址存储为四个 `u8` 值而 `V6` 地址仍然表现为一个 `String`，这就不能使用结构体了。枚举则可以轻易地处理这个情况：\n\n莫非 模板字符串出现了\n\n```rust\nenum IpAddr {\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\n\nlet home = IpAddr::V4(127, 0, 0, 1);\n\nlet loopback = IpAddr::V6(String::from(\"::1\"));\n```\n\n兼容各种类型\n\n```rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n/////////\nstruct Ipv4Addr {\n    // --snip--\n}\n\nstruct Ipv6Addr {\n    // --snip--\n}\n\nenum IpAddr {\n    V4(Ipv4Addr),\n    V6(Ipv6Addr),\n}\n```\n\n#### 4-1-3、枚举的 impl\n\n```rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\nimpl Message {\n    fn call(&self) {\n        println!(\"hello\")\n    }\n}\nfn impl_test() {\n    let msg = Message::Write(String::from(\"wukong\"));\n    println!(\"msg{:?}\", msg);\n    msg.call()\n}\n\n```\n\n#### 4-1-4、Option 枚举\n\n`Option` 类型应用广泛是因为它编码了一个非常普遍的场景，即一个值要么有值要么没值\n\nRust 并没有很多其他语言中有的空值功能。 **空值** （_Null_ ）是一个值，它代表没有值。在有空值的语言中，变量总是这两种状态之一：空值和非空值。不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 `Option<T>,枚举可以直接拿出来`\n\n可以推论出不同类型\n\n可以在函数中直接使用 `None`，而不需要写成 `Option::None`，这是因为 Rust 提供了一个方便的语法糖，使得 `None` 可以直接作为 `Option` 类型的值使用\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n  let some_number = Some(5);\n  let some_string = Some(\"a string\");\n```\n\n```rust\nlet x: i8 = 5;\nlet y: Option<i8> = Some(5);\n\nlet sum = x + y;\n//这段代码不能编译，因为它尝试将 Option<i8> 与 i8 相加\n```\n\noption 是内置的，可以直接调用\n\n```rust\n#[derive(Debug)]\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n    None,\n}\nfn main() {\n    println!(\"Hello, world!\");\n    let val = Value_in_cents(Coin::Penny);\n\n    let val: Option<u8> = Value_in_cents(Coin::None);\n    println!(\"{:?}\", val)\n}\nfn Value_in_cents(coin: Coin) -> Option<u8> {\n    match coin {\n        Coin::Penny => {\n            println!(\"Lucky penny!\");\n            Some(1)\n        }\n        Coin::Dime => Some(5),\n        Coin::Nickel => Some(10),\n        Coin::Quarter => Some(25),\n        Coin::None => None,\n    }\n}\n\n```\n\n#### 4-2-5、例子\n\n```rust\npub mod staff_mod {\n    use crate::const_v::arr_enum::staff::StaffEnum;\n    use std::collections::HashMap;\n    #[derive(Debug)]\n    pub struct Company {\n        department: HashMap<String, Vec<String>>,\n    }\n\n    impl Company {\n        pub fn new() -> Self {\n            Company {\n                department: HashMap::new(),\n            }\n        }\n        pub fn add(&mut self, name: String, department: String) {\n            self.department\n                .entry(department)\n                .or_insert(vec![])\n                .push(name)\n        }\n        pub fn get_department(&self, department_name: String) -> Option<Vec<String>> {\n            let res: Option<&Vec<String>> = self.department.get(&department_name);\n            let res: Option<Vec<String>> = res.cloned();\n\n            if let Some(mut vec) = res {\n                vec.sort();\n                return Some(vec);\n            } else {\n                return None;\n            }\n\n            // match res {\n            //     Some(vec) => println!(\"{:?}\", vec),\n            //     None => println!(\"None\"),\n            // }\n        }\n    }\n}\n\n```\n\n### 4-2、match\n\n可以把 `match` 表达式想象成某种硬币分类器：硬币滑入有着不同大小孔洞的轨道，每一个硬币都会掉入符合它大小的孔洞。同样地，值也会通过 `match` 的每一个模式，并且在遇到第一个 “符合” 的模式时，值会进入相关联的代码块并在执行中被使用。\n\n#### 4-2-1、绑定值\n\n```rust\n#[derive(Debug)]\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n    None,\n}\n#[derive(Debug)] // 这样可以立刻看到州的名称\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\nfn main() {\n    println!(\"Hello, world!\");\n    let val = Value_in_cents(Coin::Penny);\n\n    let val: Option<u8> = Value_in_cents(Coin::None);\n    let val: Option<u8> = Value_in_cents(Coin::Quarter(UsState::Alabama));\n    println!(\"{:?}\", val)\n}\nfn Value_in_cents(coin: Coin) -> Option<u8> {\n    match coin {\n        Coin::Penny => {\n            println!(\"Lucky penny!\");\n            Some(1)\n        }\n        Coin::Dime => Some(5),\n        Coin::Nickel => Some(10),\n        Coin::Quarter(state) => {\n            println!(\"State quarter from {:?}!\", state);\n            Some(25)\n        }\n        Coin::None => None,\n    }\n}\n\n```\n\n可以传入枚举值 在 match 中的回调获取当前传入的值\n\n#### 4-2-2、Option 匹配\n\n```rust\n#[derive(Debug)]\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n    None,\n}\n#[derive(Debug)] // 这样可以立刻看到州的名称\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\nfn main() {\n    println!(\"Hello, world!\");\n    let val = Value_in_cents(Coin::Penny);\n\n    let val: Option<u8> = Value_in_cents(Coin::None);\n    let val: Option<u8> = Value_in_cents(Coin::Quarter(UsState::Alabama));\n    println!(\"{:?}\", val);\n    let five: Option<i32> = dbg!(Some(5));\n    println!(\"{:?}\", five);\n    let six = plus_one(five);\n    println!(\"{:?}\", six);\n    let none = plus_one(None);\n}\nfn Value_in_cents(coin: Coin) -> Option<u8> {\n    match coin {\n        Coin::Penny => {\n            println!(\"Lucky penny!\");\n            Some(1)\n        }\n        Coin::Dime => Some(5),\n        Coin::Nickel => Some(10),\n        Coin::Quarter(state) => {\n            println!(\"State quarter from {:?}!\", state);\n            Some(25)\n        }\n        Coin::None => None,\n    }\n}\nfn plus_one(x: Option<i32>) -> Option<i32> {\n    match x {\n        None => None,\n        Some(i) => Some(i + 1),\n    }\n}\n```\n\n可以通过使用 some，来对值进行处理\n\nRust 知道我们没有覆盖所有可能的情况甚至知道哪些模式被忘记了！Rust 中的匹配是 **穷举式的** （ _exhaustive_ ）：必须穷举到最后的可能性来使代码有效。特别的在这个 `Option<T>` 的例子中，Rust 防止我们忘记明确的处理 `None` 的情况，这让我们免于假设拥有一个实际上为空的值，从而使之前提到的价值亿万的错误不可能发生。\n\n#### 4-2-3、通配模式和\\_占位符\n\n```rust\n    let dice_roll = 9;\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        other => move_player(other),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn move_player(num_spaces: u8) {}\n```\n\n最后一个分支则涵盖了所有其他可能的值，模式是我们命名为 `other` 的一个变量。`other` 分支的代码通过将其传递给 `move_player` 函数来使用这个变量。\n\n因为最后一个模式将匹配所有未被特殊列出的值\n\nRust 还提供了一个模式，当我们不想使用通配模式获取的值时，请使用 `_` ，这是一个特殊的模式，可以匹配任意值而不绑定到该值。\n\n我们必须将通配分支放在最后，因为模式是按顺序匹配的。\n\nother 和*区别 *获取不到参数 ，而 other 则是最后一位，能获取到参数\n\n#### 4-2-4、if let\n\n`if let` 获取通过等号分隔的一个模式和一个表达式。\n\n```rust\nfn main() {\n    let mut some_u8_value = 3;\n    if let 3 = some_u8_value {\n        println!(\"three\");\n    } else {\n        some_u8_value += 1;\n        println!(\"some_u8_value{}\", some_u8_value)\n    }\n}\n\n```\n\n使用 `if let` 意味着编写更少代码，更少的缩进和更少的样板代码。然而，这样会失去 `match` 强制要求的穷尽性检查。\n\n可以在 `if let` 中包含一个 `else`。`else` 块中的代码与 `match` 表达式中的 `_` 分支块中的代码相同，这样的 `match` 表达式就等同于 `if let` 和 `else`\n\n## 5、包、create、模块\n\n### 5-1、包和 create\n\n#### 5-1-1、包\n\n一个包中至多 **只能** 包含一个库 crate（library crate）；包中可以包含任意多个二进制 crate（binary crate）；包中至少包含一个 crate，无论是库的还是二进制的\n\n在此，我们有了一个只包含 _src/main.rs_ 的包，意味着它只含有一个名为 `my-project` 的二进制 crate。如果一个包同时含有 _src/main.rs_ 和 _src/lib.rs_ ，则它有两个 crate：一个库和一个二进制项，且名字都与包相同。通过将文件放在 _src/bin_ 目录下，一个包可以拥有多个二进制 crate：每个 _src/bin_ 下的文件都会被编译成一个独立的二进制 crate。\n\n将一个 crate 的功能保持在其自身的作用域中，可以知晓一些特定的功能是在我们的 crate 中定义的还是在 `rand` crate 中定义的，这可以防止潜在的冲突。例如，`rand` crate 提供了一个名为 `Rng` 的特性（trait）。我们还可以在我们自己的 crate 中定义一个名为 `Rng` 的 `struct`。因为一个 crate 的功能是在自身的作用域进行命名的，当我们将 `rand` 作为一个依赖，编译器不会混淆 `Rng` 这个名字的指向。在我们的 crate 中，它指向的是我们自己定义的 `struct Rng`。我们可以通过 `rand::Rng` 这一方式来访问 `rand` crate 中的 `Rng` 特性（trait）。\n\n#### 5-1-2、模块的作用域和私有性\n\n通过执行 `cargo new --lib restaurant`，来创建一个新的名为 `restaurant` 的库。然后将示例 7-1 中所罗列出来的代码放入 _src/lib.rs_ 中，来定义一些模块和函数\n\n```rust\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n\n        fn seat_at_table() {}\n    }\n\n    mod serving {\n        fn take_order() {}\n\n        fn serve_order() {}\n\n        fn take_payment() {}\n    }\n}\n```\n\n_src/main.rs_ 和 _src/lib.rs_ 被称为 crate 根。如此称呼的原因是，这两个文件中任意一个的内容会构成名为 `crate` 的模块，且该模块位于 crate 的被称为 _模块树_ 的模块结构的根部\n\n#### 5-1-3、路径用于引用模块树中的项\n\n路径有两种形式：\n\n- **绝对路径** （ _absolute path_ ）从 crate 根部开始，以 crate 名或者字面量 `crate` 开头。\n- **相对路径** （ _relative path_ ）从当前模块开始，以 `self`、`super` 或当前模块的标识符开头。\n\n> 包的移动用相对\n>\n> 包内移动用绝对\n\n作用域\n\nRust 中默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的。父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用他们父模块中的项。\n\n##### pub\n\n可以通过使用 `pub` 关键字来创建公共项，使子模块的内部部分暴露给上级模块\n\n`add_to_waitlist` 函数是私有的。私有性规则不但应用于模块，还应用于结构体、枚举、函数和方法\n\n```rust\n#[cfg(test)]\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n        fn seat_at_table() {}\n    }\n    mod serving {\n        fn take_order() {}\n        fn serve_order() {}\n        fn take_payment() {}\n    }\n}\npub fn eat_at_restaurant() {\n    // 绝对路径\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // 相对路径\n    front_of_house::hosting::add_to_waitlist();\n}\n\n```\n\n我们还可以使用 `pub` 来设计公有的结构体和枚举，不过有一些额外的细节需要注意。如果我们在一个结构体定义的前面使用了 `pub` ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的\n\n```rust\n\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n        fn seat_at_table() {}\n    }\n    mod serving {\n        fn take_order() {}\n        fn serve_order() {}\n        fn take_payment() {}\n    }\n}\npub fn eat_at_restaurant() {\n    // 绝对路径\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // 相对路径\n    front_of_house::hosting::add_to_waitlist();\n    let mut meal = back_of_house::Breakfast::summer(\"Rye\");\n    meal.toast = String::from(\"Wheat\");\n//不能修改seasonal_fruit 因为它是私有的\n    println!(\"I'd like {} toast please\", meal.toast);\n}\nfn serve_order() {}\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        super::serve_order();\n    }\n    pub struct Breakfast {\n        pub toast: String,\n        seasonal_fruit: String,\n    }\n    impl Breakfast {\n        pub fn summer(toast: &str) -> Breakfast {\n            Breakfast {\n                toast: String::from(toast),\n                seasonal_fruit: String::from(\"peaches\"),\n            }\n        }\n    }\n}\n\n\n\n```\n\n###### 枚举\n\n```rust\n\nmod back_of_house {\n    pub enum Appetizer {\n        Soup,\n        Salad,\n    }\n}\n\npub fn eat_at_restaurant() {\n    let order1 = back_of_house::Appetizer::Soup;\n    let order2 = back_of_house::Appetizer::Salad;\n}\n```\n\n如果枚举成员不是公有的，那么枚举会显得用处不大；给枚举的所有成员挨个添加 `pub` 是很令人恼火的，因此枚举成员默认就是公有的。结构体通常使用时，不必将它们的字段公有化，因此结构体遵循常规，内容全部是私有的，除非使用 `pub` 关键字。\n\n##### super\n\n我们还可以使用 `super` 开头来构建从父模块开始的相对路径。这么做类似于文件系统中以 `..` 开头的语法。\n\n```rust\nfn serve_order() {}\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        super::serve_order();\n    }\n}\n\n```\n\n我们认为 `back_of_house` 模块和 `serve_order` 函数之间可能具有某种关联关系，并且，如果我们要重新组织这个 crate 的模块树，需要一起移动它们。因此，我们使用 `super`，这样一来，如果这些代码被移动到了其他模块，我们只需要更新很少的代码\n\n#### 5-1-4、use\n\n在作用域中增加 `use` 和路径类似于在文件系统中创建软连接（符号连接，symbolic link）。通过在 crate 根增加 `use crate::front_of_house::hosting`，现在 `hosting` 在作用域中就是有效的名称了，如同 `hosting` 模块被定义于 crate 根一样。通过 `use` 引入作用域的路径也会检查私有性，同其它路径一样\n\n`use` 和相对路径来将一个项引入作用域\n\n```rust\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\nuse crate::front_of_house::hosting;\n//use front_of_house::hosting;\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist;\n}\n```\n\n其他包引入\n\n```rust\nuse std::fmt;\nuse std::io;\n\nfn function1() -> fmt::Result {\n    // --snip--\n}\n\nfn function2() -> io::Result<()> {\n    // --snip--\n}\n//使用as关键字来解决\nuse std::fmt::Result;\nuse std::io::Result as IoResult;\n\nfn function1() -> Result {\n    // --snip--\n}\n\nfn function2() -> IoResult<()> {\n    // --snip--\n}\n```\n\n如你所见，使用父模块可以区分这两个 `Result` 类型。如果我们是指定 `use std::fmt::Result` 和 `use std::io::Result`，我们将在同一作用域拥有了两个 `Result` 类型，当我们使用 `Result` 时，Rust 则不知道我们要用的是哪个。\n\n我们可以使用 as 关键字来提供新名称\n\n##### 重导出\n\n当使用 `use` 关键字将名称导入作用域时，在新作用域中可用的名称是私有的。如果为了让调用你编写的代码的代码能够像在自己的作用域内引用这些类型，可以结合 `pub` 和 `use`。这个技术被称为 “ _重导出_ （ _re-exporting_ ）”\n\n```rust\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub use crate::front_of_house::hosting;\n// pub use，我们可以使用一种结构编写代码，却将不同的结构形式暴露出来。这样做使我们的库井井有条，方便开发这个库的开发者和调用这个库的开发者之间组织起来\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n```\n\n通过 `pub use`，现在可以通过新路径 `hosting::add_to_waitlist` 来调用 `add_to_waitlist` 函数。如果没有指定 `pub use`，`eat_at_restaurant` 函数可以在其作用域中调用 `hosting::add_to_waitlist`，但外部代码则不允许使用这个新路径。\n\n##### 使用外部包\n\n```rust\nuse rand::Rng;\nuse std::collections::HashMap;\nfn main() {\n    let secret_number = rand::thread_rng().gen_range(1..101);\n}\n```\n\n注意标准库（`std`）对于你的包来说也是外部 crate。因为标准库随 Rust 语言一同分发，无需修改 _Cargo.toml_ 来引入 `std`，不过需要通过 `use` 将标准库中定义的项引入项目包的作用域中来引用它们，比如我们使用的 `HashMap`：\n\n##### 嵌套路径\n\n```rust\nuse std::cmp::Ordering;\nuse std::io;\n等同于\nuse std::{cmp::Ordering, io}; 一样的可以合在一起\n```\n\n##### glob\n\n```rust\nuse std::collections::*;\n```\n\n这个 `use` 语句将 `std::collections` 中定义的所有公有项引入当前作用域。使用 glob 运算符时请多加小心！Glob 会使得我们难以推导作用域中有什么名称和它们是在何处定义的。\n\n#### 5-1-5 分割不同的文件\n\n```rust\n\n/lib.rs\nmod front_of_house;\n需要再同级目录下有这个文件名\n/front_of_house.rs\npub mod hosting;\n\n//需要再同名目录下有这个文件名\n/front_of_house/hosting\npub fn add_to_waitlist() {}\n\n上述后两步等效\npub mod hosting {\n    pub fn add_to_waitlist() {}\n}\n在 mod front_of_house 后使用分号，而不是代码块，这将告诉 Rust 在另一个与模块同名的文件中加载模块的内容。继续重构我们例子，将 hosting 模块也提取到其自己的文件中，仅对 src/front_of_house.rs 包含 hosting 模块的声明进行修改：\n```\n\n> lib.rs 是根目录，会直接在 src 下面寻找 ，而不是根目录的包 则需要在同名的文件名下有这个包名\n>\n> 引入包后才能开始使用\n>\n> crate 可以在子目录中寻找父级\n\n## 6、常见集合\n\n### 6-1、vec\n\n是的，Rust 中的 `Vec`（动态数组）也要求其所有元素必须是同一类型。`Vec` 是 Rust 标准库中提供的一种动态大小的数组类型，但它仍然遵循 Rust 的类型系统规则，即所有元素必须是同质的。\n\n类似于任何其他的 `struct`，vector 在其离开作用域时会被释放，如示例 8-4 所标注的\n\n#### 6-1-1、语法\n\n```rust\nlet v: Vec<i32> = Vec::new();\nlet v = vec![1, 2, 3];\n```\n\nRust 提供了 `vec!` 宏。这个宏会根据我们提供的值来创建一个新的 `Vec`\n\n修改值必须使用 `mut` 关键字使其可变。放入其中的所有值都是 `i32` 类型的，\n\n注:用此方法超出范围不会报错\n\n```rust\n    match v.get(100) {\n        Some(x) => println!(\"{:?}\", x),\n        None => println!(\"None\"),\n    }\n```\n\n|      | 方法                    |                                                        |\n| ---- | ----------------------- | ------------------------------------------------------ |\n| 新增 | v.push                  |                                                        |\n| 索引 | &v[index]，超出范围报错 | v.get(index),返回一个 `Option<&T>，超出范围返回none` |\n\n```rust\n//报错\nlet mut v = vec![1, 2, 3, 4, 5];\n\nlet first = &v[0];\n\nv.push(6);\n\nprintln!(\"The first element is: {}\", first);\n\n//修正\nlet mut v = vec![1, 2, 3, 4, 5];\nv.push(6);\nlet first = &v[0];\nprintln!(\"The first element is: {}\", first);\n```\n\n在读取元素后再添加，内存会发生变化，前面的代码不知有它，不认过去，君生我未生；\n\n#### 6-1-2、循环\n\n```rust\n    for i in &mut v {\n        *i += 50\n    }\n```\n\n为了修改可变引用所指向的值，在使用 `+=` 运算符之前必须使用解引用运算符（`*`）获取 `i` 中的值\n\n#### 6-1-3、枚举结合 vec\n\n```rust\n    enum spreadsheetceel {\n        Int(i32),\n        Float(f64),\n        Text(String),\n    };\n    let row = vec![\n        spreadsheetceel::Int(3),\n        spreadsheetceel::Text(String::from(\"blue\")),\n        spreadsheetceel::Float(10.12),\n    ];\n```\n\n用枚举生成 vec，可以存储不同的类型，另外 可以使用 match 来对不同的值进行匹配 确保不会报错\n\n### 6-2、字符串\n\n#### 6-2-1、初始化\n\n以下两个方法等效\n\n字符串是 UTF-8 编码的，所以可以包含任何正确编码的数据\n\n```rust\n    let s = \"initContent\".to_string();\n    let s = String::from(\"initial contents\");\n    println!(\"{}\", s);\n```\n\n#### 6-2-2、更新字符串\n\n可以通过 `push_str` 方法来附加字符串 slice，从而使 `String` 变长，如示例 8-15 所示。\n\n```rust\nlet mut s1 = String::from(\"foo\");\nlet s2 = \"bar\";\ns1.push_str(s2);\nprintln!(\"s2 is {}\", s2);\n```\n\ns2 是 slice，我们不能获取其所有权，避免自身所有权失效\n\n`push` 方法被定义为获取一个单独的字符作为参数，并附加到 `String` 中\n\n```rust\nlet mut s = String::from(\"lo\");\ns.push('l');\n```\n\n拼接，遵循所有权规则\n\n```rust\n    let s1 = String::from(\"Hello, \");\n    let s2 = String::from(\"world\");\n    let res = s1 + &s2;\n    println!(\"{},{}\", res, s2);\n```\n\n`+` 运算符使用了 `add` 函数，这个函数签名看起来像这样：\n\nself 的所有权会被获取\n\n```rust\nfn add(self, s: &str) -> String {\n\n```\n\n`s2` 使用了 `&`，意味着我们使用第二个字符串的 **引用** 与第一个字符串相加。这是因为 `add` 函数的 `s` 参数：只能将 `&str` 和 `String` 相加，不能将两个 `String` 值相加。\n\n`&String` 可以被 **强转** （ _coerced_ ）成 `&str`。当 `add` 函数被调用时，Rust 使用了一个被称为 **解引用强制转换** （ _deref coercion_ ）的技术，你可以将其理解为它把 `&s2` 变成了 `&s2[..]`\n\n#### 6-2-3、 `format!` 宏\n\n`format!` 与 `println!` 的工作原理相同，不过不同于将输出打印到屏幕上，它返回一个带有结果内容的 `String`。这个版本就好理解的多，并且不会获取任何参数的所有权。\n\n```rust\n let s1 = String::from(\"tic\");\n    let s2 = String::from(\"tic\");\n    let s3 = String::from(\"tic\");\n    let s = format!(\"{}-{}-{}\", s1, s2, s3);\n    println!(\"{}\", s);\n```\n\n#### 6-2-4、索引字符串\n\nRust 不允许使用索引获取 `String` 字符的原因是，索引操作预期总是需要常数时间 (O(1))。但是对于 `String` 不可能保证这样的性能，因为 Rust 必须从开头到索引位置遍历来确定有多少有效的字符。\n\n比如一些非英文字符，在字节码中不能确保是第一位\n\n我们可以用 slice 来解决\n\n```rust\n    let hello = \"Здравствуйте\";\n    let s = &hello[0..4];\n    println!(\"{}\", s)\n这里，s 会是一个 &str，它包含字符串的头 4 个字节。早些时候，我们提到了这些字母都是 2 个字节长的，所以这意味着 s 将会是 “Зд”。\n```\n\n#### 6-2-5、遍历字符串\n\n如果你需要操作单独的 Unicode 标量值，最好的选择是使用 `chars` 方法。对 “नमस्ते” 调用 `chars` 方法会将其分开并返回六个 `char` 类型的值，接着就可以遍历其结果来访问每一个元素了：\n\n```rust\n    for c in hello.chars() {\n        println!(\"{}\", c);\n    }\n\n```\n\n`bytes` 方法返回每一个原始字节，这可能会适合你的使用场景\n\n```rust\nfor b in \"नमस्ते\".bytes() {\n    println!(\"{}\", b);\n}\n```\n\n### 6-3、hash-map\n\n像 vector 一样，哈希 map 将它们的数据储存在堆上，这个 `HashMap` 的键类型是 `String` 而值类型是 `i32`。类似于 vector，哈希 map 是同质的：所有的键必须是相同类型，值也必须都是相同类型。\n\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Yellow\"), 50);\n```\n\n#### 6-3-1、元组构建\n\n是使用一个元组的 vector 的 `collect` 方法，其中每个元组包含一个键值对。`collect` 方法可以将数据收集进一系列的集合类型，包括 `HashMap`。例如，如果队伍的名字和初始分数分别在两个 vector 中，可以使用 `zip` 方法来创建一个元组的 vector，其中 “Blue” 与 10 是一对，依此类推。接着就可以使用 `collect` 方法将这个元组 vector 转换成一个 `HashMap`，如示例 8-21 所示：\n\n必须规定类型\n\n```rust\n   let teams = vec![String::from(\"Blue\"), String::from(\"Yellow\")];\n    let initial_scores = vec![10, 50];\n    let score: HashMap<_, _> = teams.iter().zip(initial_scores).collect();\n    println!(\"{:?}\", score);\n```\n\n在类型中规定借用即可\n\n```rust\n  let a = [1, 2, 3];\n  let b = [4, 5, 6];\n\n    let zipped: Vec<(&i32, &i32)> = a.iter().zip(b.iter()).collect();\n```\n\n这里 `HashMap<_, _>` 类型标注是必要的，因为 `collect` 有可能当成多种不同的数据结构，而除非显式指定否则 Rust 无从得知你需要的类型。但是对于键和值的类型参数来说，可以使用下划线占位，而 Rust 能够根据 vector 中数据的类型推断出 `HashMap` 所包含的类型。\n\n#### 6-3-2、hashma 和所有权\n\n```rust\nuse std::collections::HashMap;\n\nlet field_name = String::from(\"Favorite color\");\nlet field_value = String::from(\"Blue\");\n\nlet mut map = HashMap::new();\nmap.insert(field_name, field_value);\n// 这里 field_name 和 field_value 不再有效，\n// 尝试使用它们看看会出现什么编译错误！\n```\n\n当 `insert` 调用将 `field_name` 和 `field_value` 移动到哈希 map 中后，将不能使用这两个绑定。\n\n#### 6-3-3、访问 hashmap 中的值\n\n通过 get 访问 hashmap 的值，注意所有权及借用\n\n`get` 返回 `Option<V>`，所以结果被装进 `Some`如果没有对应值，会返回 `None`\n\n```rust\n    let field_name = String::from(\"Favorite color\");\n    let field_value = String::from(\"Blue\");\n\n    let mut map = HashMap::new();\n    map.insert(&field_name, &field_value);\n\n    let val = map.get(&field_name);\n    println!(\"{:?}\", val);\n```\n\n使用与 vector 类似的方式来遍历哈希 map 中的每一个键值对，也就是 `for` 循环：\n\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Yellow\"), 50);\n\nfor (key, value) in &scores {\n    println!(\"{}: {}\", key, value);\n}\n```\n\n#### 6-3-4、键入\n\n覆盖值\n\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Blue\"), 25);\n\nprintln!(\"{:?}\", scores);\n```\n\n没有对应值\n\n哈希 map 有一个特有的 API，叫做 `entry`，它获取我们想要检查的键作为参数。`entry` 函数的返回值是一个枚举，`Entry`\n\n```rust\n  let mut map: HashMap<&String, &String> = HashMap::new();\n    map.insert(&field_name, &field_value);\n\n    let val = map.get(&field_name);\n    println!(\"{:?}\", val);\n    let str: String = String::from(\"haha\");\n    let name: String = String::from(\"haha\");\n    map.entry(&field_name).or_insert(&str);\n    let enter_v = map.entry(&name).or_insert(&str);\n    println!(\"{:?}\", enter_v);\n    println!(\"{:?}\", map);\n```\n\nmap 和 get 不能一起，`map.entry(name.clone())` 对 `map` 进行了可变借用，而 `map.get(&name)` 对 `map` 进行了不可变借用。\n\n#### 6-3-5、根据旧值更新\n\n`or_insert` 方法事实上会返回这个键的值的一个可变引用（`&mut V`）,所以为了赋值必须首先使用星号（`*`）解引用 `count`\n\n```rust\n    let text = \"hello world wonderful world\";\n    let mut map = HashMap::new();\n    for word in text.split_whitespace() {\n        let count = map.entry(word).or_insert(0);\n        *count += 1;\n    }\n```\n\n## 7、处理错误\n\n### 7-1、Result 与可恢复的错误\n\n```rust\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let f = File::open(\"hello.txt\");\n\n    let f = match f {\n        Ok(file) => file,\n        Err(error) => match error.kind() {\n            ErrorKind::NotFound => match File::create(\"hello.txt\") {\n                Ok(fc) => fc,\n                Err(e) => panic!(\"Problem creating the file: {:?}\", e),\n            },\n            other_error => panic!(\"Problem opening the file: {:?}\", other_error),\n        },\n    };\n}\n```\n\n#### 7-1-1、panic 简写:unwrap 和 expect\n\n`unwrap`，它的实现就类似于示例 9-4 中的 `match` 语句。如果 `Result` 值是成员 `Ok`，`unwrap` 会返回 `Ok` 中的值。如果 `Result` 是成员 `Err`，`unwrap` 会为我们调用 `panic!`。这里是一个实践 `unwrap` 的例子：\n\n```rust\nuse std::fs::File;\n\nfn main() {\n    let f = File::open(\"hello.txt\").unwrap();\n}\n\n```\n\n使用 `expect` 而不是 `unwrap` 并提供一个好的错误信息可以表明你的意图并更易于追踪 panic 的根源。`expect` 的语法看起来像这样\n\n```rust\nuse std::fs::File;\n\nfn main() {\n    let f = File::open(\"hello.txt\").expect(\"Failed to open hello.txt\");\n}\n```\n\n`expect` 在调用 `panic!` 时使用的错误信息将是我们传递给 `expect` 的参数，而不像 `unwrap` 那样使用默认的 `panic!` 信息,expect 是自定义的，帮助我们更容易找到错误信息\n\n#### 7-1-2、错误传播简写 ?UI 运算符\n\n```rust\nuse std::io;\nuse std::io::Read;\nuse std::fs::File;\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut f = File::open(\"hello.txt\")?;\n    let mut s = String::new();\n    f.read_to_string(&mut s)?;\n    Ok(s)\n}\n```\n\n`?` 运算符消除了大量样板代码并使得函数的实现更简单。我们甚至可以在 `?` 之后直接使用链式方法调用来进一步缩短代码，如示例 9-8 所示：\n\n```rust\nuse std::io;\nuse std::io::Read;\nuse std::fs::File;\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut s = String::new();\n\n    File::open(\"hello.txt\")?.read_to_string(&mut s)?;\n\n    Ok(s)\n}\n```\n\n#### 7-1-3、main 的?处理\n\n`main` 函数是特殊的，其必须返回什么类型是有限制的。`main` 函数的一个有效的返回值是 `()`，同时出于方便，另一个有效的返回值是 `Result<T, E>`，如下所示：\n\n```rust\nuse std::error::Error;\nuse std::fs::File;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let f = File::open(\"hello.txt\")?;\n\n    Ok(())\n}\n```\n\n`main` 函数是特殊的，其必须返回什么类型是有限制的。`main` 函数的一个有效的返回值是 `()`，同时出于方便，另一个有效的返回值是 `Result<T, E>`\n\n#### 7-1-4、可以帮助函数中断\n\n```rust\nimpl Guess {\n    pub fn new(value: i32) -> Guess {\n        if value < 1 || value > 100 {\n            panic!(\"Guess value must be between 1 and 100, got {}.\", value);\n        }\n\n        Guess { value }\n    }\n\n    pub fn value(&self) -> i32 {\n        self.value\n    }\n}\n```\n\n## 8、泛型、trait、和生命周期\n\n### 8-1、泛型\n\n#### 8-1-1、函数泛型\n\n```rust\nfn largest<T: PartialOrd + Copy>(list: &Vec<T>) -> T {\n    let mut largest = list[0];\n    for &item in list.iter() {\n        if item > largest {\n            largest = item;\n        }\n    }\n    largest\n}\n```\n\n涉及到 trait\n\n#### 8-1-2、结构体和枚举\n\n```rust\nstruct PointA<T> {\n    x: T,\n    y: T,\n}\n//两个类型一致\nstruct Point<T, U> {\n    x: T,\n    y: U,\n}\n//可以不一致\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n#### 8-1-3、方法\n\n```rust\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n}\n\nfn main() {\n    let p = Point { x: 5, y: 10 };\n\n    println!(\"p.x = {}\", p.x());\n}\n```\n\n必须在 `impl` 后面声明 `T`，这样就可以在 `Point<T>` 上实现的方法中使用它了。在 `impl` 之后声明泛型 `T` ，这样 Rust 就知道 `Point` 的尖括号中的类型是泛型而不是具体类型。\n\n```rust\nstruct Point<T, U> {\n    x: T,\n    y: U,\n}\nimpl<T, U> Point<T, U> {\n    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {\n        Point {\n            x: self.x,\n            y: other.y,\n        }\n    }\n}\n```\n\n可以用类型推断，多个类型会根据方法参数的类型进行推断\n\n### 8-2、trait\n\n_trait_ 类似于其他语言中常被称为 **接口** （ _interfaces_ ）的功能，虽然有一些不同。\n\n#### 8-2-1、定义 trait\n\n如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。trait 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合\n\n```rust\npub mod _trait {\n    pub trait Summary {\n        fn summarize(&self) -> String;\n    }\n}\n```\n\ntrait 体中可以有多个方法：一行一个方法签名且都以分号结尾。\n\n#### 8-2-2、结构体\n\n```rust\nmod _trait;\npub use _trait::_trait::Summary;\npub struct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&self) -> String {\n        format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n    }\n}\n\npub struct Tweet {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub retweet: bool,\n}\n\nimpl Summary for Tweet {\n    fn summarize(&self) -> String {\n        format!(\"{}: {}\", self.username, self.content)\n    }\n}\n```\n\n它们并不位于 `aggregator` crate 本地作用域中。这个限制是被称为 **相干性** （ _coherence_ ） 的程序属性的一部分，或者更具体的说是 **孤儿规则** （ _orphan rule_ ），其得名于不存在父类型。这条规则确保了其他人编写的代码不会破坏你代码，反之亦然。没有这条规则的话，两个 crate 可以分别对相同类型实现相同的 trait，而 Rust 将无从得知应该使用哪一个实现。\n\n不能修改其他的 trait\n\n#### 8-2-3、默认实现\n\n```rust\npub mod _trait {\n    pub trait Summary {\n        fn summarize(&self) -> String;\n        fn default_summarize(&self) -> String {\n            String::from(\"Read more ...\")\n        }\n    }\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&self) -> String {\n        format!(\"{},by {} ({})\", self.headline, self.author, self.author)\n    }\n    fn default_summarize(&self) -> String {\n        format!(\"默认实现取消\")\n    }\n}\nimpl Summary for Tweet {\n    fn summarize(&self) -> String {\n        format!(\"{}:{}\", self.username, self.content)\n    }\n}\n```\n\n该 impl 如果重新定义默认实现的函数 则优先调用定义后的值，\n\n无法从相同方法的重载实现中调用默认方法\n\n#### 8-2-4、可作为参数\n\n```rust\npub fn notify(item: impl Summary) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n```\n\n#### 8-2-5、trait Bound 语法\n\n可以通过作为泛型的值来进行简写\n\n`<T:trait>`\n\n```rust\npub fn notify(item: &impl Summary, item2: &impl Summary) {\n    // println!(\"{:?}\", item)\n}\npub fn notify2<T: Summary>(item: &T, item2: &T) {\n    // println!(\"{:?}\", item)\n}\nfn main() {\n    let article = NewsArticle {\n        headline: String::from(\"Penguins win the Stanley Cup Championship!\"),\n        location: String::from(\"Pittsburgh, PA, USA\"),\n        author: String::from(\"Iceburgh\"),\n        content: String::from(\n            \"The Pittsburgh Penguins once again are the best\n    hockey team in the NHL.\",\n        ),\n    };\n    notify(&article, &article);\n    notify2(&article, &article);\n    // notify();\n    println!(\"Hello, world!\");\n}\n```\n\n#### 8-2-6、通过+指定多个 bound\n\n两个 debug 都需要\n\n```rust\nuse std::fmt::Debug;\n#[derive(Debug, Clone)]\npub struct NewsArticle {\n.....\n}\npub fn notify<T: Summary + Clone + Debug>(item: &T, item2: &T) {\n    let res = format!(\"{}\", item.clone().summarize());\n    let res2 = item2.clone();\n    println!(\"{},{:#?}\", res, res2)\n}\n```\n\n简写\n\n```rust\npub fn notify3<T, U>(item: &T, item2: &U)\nwhere\n    T: Summary,\n    U: Summary + Debug + Clone,\n{\n    let res = format!(\"{}\", item.summarize());\n    let res2 = item2.clone();\n    println!(\"{},{:#?}\", res, res2)\n}\n```\n\n8-2-7、retrun 定义 trait\n\n```rust\nfn returns_summarizable() -> impl Summary {\n    Tweet {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\"of course, as you probably already know, people\"),\n        reply: false,\n        retweet: false,\n    }\n}\n```\n\n- `&dyn Summary` 表示一个实现了 `Summary` trait 的动态类型引用。\n- `impl Summary` 表示一个实现了 `Summary` trait 的具体类型\n\n```rust\n  returns_summarizable(&mut article);\n  fn returns_summarizable(_item: &mut NewsArticle) -> &dyn Summary {\n    _item\n}\n\n```\n\n只适用于返回单一类型的情况\n\n#### 8-2-7、可选 impl\n\n只有满足打印 Display，且比较 PartialOrd 此函数才会生效\n\n```rust\nimpl<T: Display + PartialOrd> Pair<T> {\n    fn cmp_display(&self) {\n        if self.x >= self.y {\n            println!(\"The largest member is x = {}\", self.x);\n        } else {\n            println!(\"The largest member is y = {}\", self.y);\n        }\n    }\n}\n```\n\n标准库\n\n```rust\nimpl<T: Display> ToString for T {\n    // --snip--\n}\n```\n\n我们可以对任何实现了 `Display` trait 的类型调用由 `ToString` 定义的 `to_string` 方法,可以将整型转换为对应的 `String` 值，因为整型实现了 `Display`\n\n### 8-3、生命周期\n\n主要用来处理引用数据类型发生的错误\n\n#### 8-3-1、函数中的泛型生命周期\n\n生命周期参数名称必须以撇号（`'`）开头，其名称通常全是小写，类似于泛型其名称非常短。`'a` 是大多数人默认使用的名称。生命周期参数标注位于引用的 `&` 之后，并有一个空格来将引用类型与生命周期标注分隔开。\n\n`'a` 所替代的具体生命周期是 `x` 的作用域与 `y` 的作用域相重叠的那一部分。换一种说法就是**泛型生命周期 `'a` 的具体生命周期等同于 `x` 和 `y` 的生命周期中较小的那一个**。因为我们用相同的生命周期参数 `'a` 标注了返回的引用值，所以返回的引用值就能保证在 `x` 和 `y` 中较短的那个生命周期结束之前保持有效。\n\n```\nuse std::env;\nuse std::fs;\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let query = &args[1];\n    let filename = &args[2];\n    let contents = fs::read_to_string(filename).expect(\"Error reading file\");\n    println!(\"With text:\\n{}\", contents);\n    parse_config(query, filename);\n}\nfn parse_config<'a>(query: &'a str, filename: &'a str) -> (&'a str, &'a str) {\n    // let query = &args[1];\n    // let filename = &args[2];\n    (query, filename)\n}\n\n```\n\n```rust\n\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n```\n\n成功\n\n```rust\n  let string1 = String::from(\"long string is long\");\n\n    {\n        let string2 = String::from(\"xyz\");\n        let result = longest(string1.as_str(), string2.as_str());\n        println!(\"The longest string is {}\", result);\n    }\n```\n\n失败\n\n```rust\n   let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(\"The longest string is {}\", result);\n```\n\n该函数的生命周期与较短的保持一致，说明在 string2 生命周期结束时，rusult 的生命周期就结束了\n\n报错,如果直接返回 String 不会报错 ，as_str 返回的是一个&str 类型 是一个引用，没有所有权\n\n```rust\n\nfn longest2() -> &str {\n    let result = String::from(\"really long string\");\n    let res = result.as_str();\n    res\n}\n\n```\n\n最好的解决方案是返回一个有所有权的数据类型而不是一个引用，这样函数调用者就需要负责清理这个值了。\n\n#### 8-3-2、结构体定义的生命周期\n\n这是一个引用值，我们可以在 struct 中定义它的生命周期，novel 在上面 他的生命周期比 import 的生命周期更长，当 import 退出的时候 novel 都不会退出 所以 他的引用值是有效的\n\n```rust\nstruct ImportantExcerpt<'a> {\n    part: &'a str,\n}\n\nfn main() {\n    let novel = String::from(\"Call me Ishmael. Some years ago...\");\n    let first_sentence = novel.split('.')\n        .next()\n        .expect(\"Could not find a '.'\");\n    let i = ImportantExcerpt { part: first_sentence };\n}\n```\n\n在 Rust 中，如果你有一个结构体包含**引用类型**的字段，你必须为这些引用字段指定生命周期参数。这是因为 Rust 需要确保这些引用的生命周期是有效的，并且不会在结构体实例的生命周期内变得无效。\n\n> 生命周期如何添加，应该注意其返回值又没有对其是否进行操作\n\n#### 8-3-3、省略生命周期\n\n**生命周期省略规则**\n\n第一条规则是每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：`fn foo<'a>(x: &'a i32)`，有两个引用参数的函数有两个不同的生命周期参数，`fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`，依此类推。\n\n第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：`fn foo<'a>(x: &'a i32) -> &'a i32`。\n\n第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 `&self` 或 `&mut self`，说明是个对象的方法(method)(译者注： 这里涉及 Rust 的面向对象，参见第 17 章), 那么所有输出生命周期参数被赋予 `self` 的生命周期。第三条规则使得方法更容易读写，因为只需更少的符号。\n\n#### 8-3-4、方法的生命周期\n\n`impl` 之后和类型名称之后的生命周期参数是必要的，不过因为第一条生命周期规则我们并不必须标注 `self` 引用的生命周期。\n\n```rust\nimpl<'a> ImportantExcerpt<'a> {\n    fn level(&self) -> i32 {\n        3\n    }\n}\n```\n\n这里是一个适用于第三条生命周期省略规则的例子：\n\n因为其中一个参数是 `&self`，返回值类型被赋予了 `&self` 的生命周期，这样所有的生命周期都被计算出来了\n\n```rust\nimpl<'a> ImportantExcerpt<'a> {\n    fn announce_and_return_part(&self, announcement: &str) -> &str {\n        println!(\"Attention please: {}\", announcement);\n        self.part\n    }\n}\n```\n\n#### 8-3-5、静态生命周期\n\n这里有一种特殊的生命周期值得讨论：`'static`，其生命周期**能够**存活于整个程序期间。所有的字符串字面量都拥有 `'static` 生命周期，我们也可以选择像下面这样标注出来：\n\n```rust\nlet s: &'static str = \"I have a static lifetime.\";\n```\n\n因为生命周期也是泛型，所以生命周期参数 `'a` 和泛型类型参数 `T` 都位于函数名后的同一尖括号列表中\n\n##### 8-3-6、生命周期与 trait\n\n```rust\nfn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str\nwhere\n    T: Display,\n{\n    println!(\"Announcement! {}\", ann);\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n```\n\n这个额外的参数会在函数比较字符串 slice 的长度之前被打印出来，这也就是为什么 `Display` trait bound 是必须的。因为生命周期也是泛型，所以生命周期参数 `'a` 和泛型类型参数 `T` 都位于函数名后的同一尖括号列表中。\n\n如果不加 Display，无法确定泛型类型，也就无法判断能否打印\n\n总结 trait 帮其规定为泛型时候的行为\n\n## 9、测试\n\n### 9-1、编写测试\n\n#### 9-1-1、#[test]\n\n`#[test]`：这个属性表明这是一个测试函数\n\n```rust\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        assert_eq!(2 + 2, 4);\n    }\n}\n```\n\n函数体通过使用 `assert_eq!` 宏来断言 2 加 2 等于 4。一个典型的测试的格式，就是像这个例子中的断言一样。接下来运行就可以看到测试通过。\n\n#### 9-1-2、`assert!`\n\n`assert!` 宏由标准库提供，在希望确保测试中一些条件为 `true` 时非常有用。需要向 `assert!` 宏提供一个求值为布尔值的参数\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn larger_can_hold_smaller() {\n        let larger = Rectangle { width: 8, height: 7 };\n        let smaller = Rectangle { width: 5, height: 1 };\n\n        assert!(larger.can_hold(&smaller));\n    }\n}\n```\n\n注意在 `tests` 模块中新增加了一行：`use super::*;`。`tests` 是一个普通的模块，它遵循第 7 章 [“路径用于引用模块树中的项”](https://rustwiki.org/zh-CN/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html) 部分介绍的可见性规则。因为这是一个内部模块，要测试外部模块中的代码，需要将其引入到内部模块的作用域中。**这里选择使用 glob 全局导入，以便在 `tests` 模块中使用所有在外部模块定义的内容**。\n\n让我们为测试函数增加一个自定义失败信息参数：带占位符的格式字符串，以及 `greeting` 函数的值：\n\n```rust\n#[test]\nfn greeting_contains_name() {\n    let result = greeting(\"Carol\");\n    assert!(\n        result.contains(\"Carol\"),\n        \"Greeting did not contain name, value was `{}`\", result\n    );\n}\n```\n\n#### 9-1-2、`assert_eq!` 和 `assert_ne!`\n\n这两个宏分别比较两个值是相等还是不相等。当断言失败时他们也会打印出这两个值具体是什么，以便于观察测试 **为什么** 失败\n\n```rust\n    fn exploration() {\n        assert_eq!(2 + 2, 4);\n    }\n```\n\n`assert_ne!` 宏在传递给它的两个值不相等时通过，而在相等时失败。在代码按预期运行，我们不确定值 **会** 是什么，不过能确定值绝对 **不会** 是什么的时候，这个宏最有用处。\n\n#### 9-1-3、#[should_panic]\n\n可以通过对函数增加另一个属性 `should_panic` 来实现这些。这个属性在函数中的代码 panic 时会通过，而在其中的代码没有 panic 时失败。\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn greater_than_100() {\n        Guess::new(200);\n    }\n}\n```\n\n我们可以给 `should_panic` 属性增加一个可选的 `expected` 参数。测试工具会确保错误信息中包含其提供的文本\n\n```rust\n#[should_panic(expected = \"Guess value must be less than or equal to 100\")]\n```\n\n#### 9-1-4 Result\n\n不能在使用 `Result<T, E>` 的测试中使用 `#[should_panic]` 注解。要断言操作返回 `Err` 值，*不要*在 `Result<T, E>` 值上使用问号运算符。相反，请使用 `assert!(value.is_err())`\n\n```rust\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() -> Result<(), String> {\n        if 2 + 2 == 4 {\n            Ok(())\n        } else {\n            Err(String::from(\"two plus two does not equal four\"))\n        }\n    }\n}\n```\n\n### 9-2、运行测试\n\n```rust\n$ cargo test -- --test-threads=1\n```\n\n这里将测试线程设置为 `1`，告诉程序不要使用任何并行机制。这也会比并行运行花费更多时间，不过在有共享的状态时，测试就不会潜在的相互干扰了。\n\n```rust\n$ cargo test -- --show-output\n\n```\n\n如果你希望也能看到通过的测试中打印的值，可以通过在末尾增加 `--show-output` 参数来告知 Rust 显示通过测试的输出\n\n```rust\ncargo test #[test]函数名称\n```\n\n可以向 `cargo test` 传递任意测试的名称来只运行这个测试，这个也可以过滤 名称中携带这个字段的都会进行测试\n\n```rust\ncargo test -- --ignored\n```\n\n可以使用 `ignore` 属性来标记耗时的测试并排除他们\n\n```rust\n#[test]\nfn it_works() {\n    assert_eq!(2 + 2, 4);\n}\n\n#[test]\n#[ignore]\nfn expensive_test() {\n    // 需要运行一个小时的代码\n}\n```\n\n### 9-3、测试结构\n\n#### 9-3-1、单元测试\n\n测试模块的 `#[cfg(test)]` 标注告诉 Rust 只在执行 `cargo test` 时才编译和运行测试代码，而在运行 `cargo build` 时不这么做。\n\n你需要使用 `#[cfg(test)]` 来指定他们不应该被包含进编译结果中\n\nrust 可以测试私有函数\n\n```rust\npub fn add_two(a: i32) -> i32 {\n    internal_adder(a, 2)\n}\n\nfn internal_adder(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn internal() {\n        assert_eq!(4, internal_adder(2, 2));\n    }\n}\n```\n\n#### 9-3-2、集成测试\n\n为了编写集成测试，需要在项目根目录创建一个 _tests_ 目录，与 _src_ 同级。Cargo 知道如何去寻找这个目录中的集成测试文件。接着可以随意在这个目录中创建任意多的测试文件，Cargo 会将每一个文件当作单独的 crate 来编译。\n\n集成测试对于你需要测试的库来说完全是外部的。同其他使用库的代码一样使用库文件，也就是说它们只能调用一部分库中的公有 API 。集成测试的目的是测试库的多个部分能否一起正常工作。一些单独能正确运行的代码单元集成在一起也可能会出现问题，所以集成测试的覆盖率也是很重要的。\n\n```rust\nuse adder;\n\n#[test]\nfn it_adds_two() {\n    assert_eq!(4, adder::add_two(2));\n}\n```\n\n如果我们可以创建 一个*tests/common.rs* 文件并创建一个名叫 `setup` 的函数，我们希望这个函数能被多个测试文件的测试函数调用\n\n```rust\npub fn setup() {\n    // 编写特定库测试所需的代码\n}\n\n```\n\n为了不让 `common` 出现在测试输出中，我们将创建 _tests/common/mod.rs_ ，而不是创建 _tests/common.rs_ 。这是一种 Rust 的命名规范，这样命名告诉 Rust 不要将 `common` 看作一个集成测试文件。将 `setup` 函数代码移动到 _tests/common/mod.rs_ 并删除 _tests/common.rs_ 文件之后，测试输出中将不会出现这一部分。_tests_ 目录中的子目录不会被作为单独的 crate 编译或作为一个测试结果部分出现在测试输出中。\n\n一旦拥有了 _tests/common/mod.rs_ ，就可以将其作为模块以便在任何集成测试文件中使用。这里是一个 _tests/integration_test.rs_ 中调用 `setup` 函数的 `it_adds_two` 测试的例子：\n\n```rust\nuse adder;\n\nmod common;\n\n#[test]\nfn it_adds_two() {\n    common::setup();\n    assert_eq!(4, adder::add_two(2));\n}\n```\n\n## 10、闭包与迭代器\n\n### 10-1、闭包\n\n#### 10-1-1、使用闭包存储结果\n\n```rust\nlet expensive_closure = |num| {\n    println!(\"calculating slowly...\");\n    thread::sleep(Duration::from_secs(2));\n    num\n};\n   println!(\"today,do{}pushups!\", res.value(4));\n    println!(\"Next, do {} situps!\", res.value(3));\n```\n\n闭包不要求像 `fn` 函数那样在参数和返回值上注明类型。函数中需要类型标注是因为他们是暴露给用户的显式接口的一部分。严格的定义这些接口对于保证所有人都认同函数使用和返回值的类型来说是很重要的。但是闭包并不用于这样暴露在外的接口：他们储存在变量中并被使用，不用命名他们或暴露给库的用户调用。\n\n闭包通常很短，并只关联于小范围的上下文而非任意情境。\n\n\n\n如果尝试调用闭包两次，第一次使用 `String` 类型作为参数而第二次使用 `u32`，则会得到一个错误：\n\n```rust\nlet example_closure = |x| x;\n\nlet s = example_closure(String::from(\"hello\"));\nlet n = example_closure(5);\n```\n\n#### 10-1-2、cacher单例模式\n\n```rust{\nimpl<T> Cacher<T>\n    where T: Fn(u32) -> u32\n{\n    fn new(calculation: T) -> Cacher<T> {\n        Cacher {\n            calculation,\n            value: None,\n        }\n    }\n\n    fn value(&mut self, arg: u32) -> u32 {\n        match self.value {\n            Some(v) => v,\n            None => {\n                let v = (self.calculation)(arg);\n                self.value = Some(v);\n                v\n            },\n        }\n    }\n}\n```\n\n#### 10-1-3、闭包与环境\n\n闭包从环境中捕获一个值，闭包会在闭包体中储存这个值以供使用\n\n```rust\nfn main() {\n    let x = 4;\n\n    let equal_to_x = |z| z == x;\n\n    let y = 4;\n\n    assert!(equal_to_x(y));\n}\n```\n\n以下不能编译，因为作用域的生命周期中没有x\n\n```rust\nfn main() {\n    let x = 4;\n\n    fn equal_to_x(z: i32) -> bool { z == x }\n\n    let y = 4;\n\n    assert!(equal_to_x(y));\n}\n```\n\n闭包可以通过三种方式捕获其环境，他们直接对应函数的三种获取参数的方式：获取所有权，可变借用和不可变借用。这三种捕获值的方式被编码为如下三个 `Fn` trait：\n\n- `FnOnce` 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 **环境**，*environment*。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 `Once` 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。\n- `FnMut` 获取可变的借用值所以可以改变其环境\n- `Fn` 从其环境获取不可变的借用值\n\nRust 根据其如何使用环境中变量来推断我们希望如何引用环境。由于所有闭包都可以被调用至少一次，所以所有闭包都实现了 `FnOnce` 。那些并没有移动被捕获变量的所有权到闭包内的闭包也实现了 `FnMut` ，而不需要对被捕获的变量进行可变访问的闭包则也实现了 `Fn`\n\n### 10-2、迭代器\n\n#### 10-2-1、Iterator trait 和 next 方法\n\ntrait 是类型规范 impl trait for struct 可以理解成extends trait的类型\n\n```rust\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n\n    // 此处省略了方法的默认实现\n}\n```\n\n`next` 是 `Iterator` 实现者被要求定义的唯一方法。`next` 一次返回迭代器中的一个项，封装在 `Some` 中，当迭代器结束时，它返回 `None`。\n\n```rust\n#[test]\nfn iterator_demonstration() {\n    let v1 = vec![1, 2, 3];\n\n    let mut v1_iter = v1.iter();\n\n    assert_eq!(v1_iter.next(), Some(&1));\n    assert_eq!(v1_iter.next(), Some(&2));\n    assert_eq!(v1_iter.next(), Some(&3));\n    assert_eq!(v1_iter.next(), None);\n}\n```\n\n这些调用 `next` 方法的方法被称为 **消费适配器**（*consuming adaptors*），因为调用他们会消费迭代器。一个消费适配器的例子是 `sum` 方法。这个方法获取迭代器的所有权并反复调用 `next` 来遍历迭代器，因而会消费迭代器\n\n#### 10-2-2、迭代器方法\n\n`Iterator` trait 中定义了另一类方法，被称为 **迭代器适配器**（*iterator adaptors*），他们允许我们将当前迭代器变为不同类型的迭代器。可以链式调用多个迭代器适配器。不过因为所有的迭代器都是惰性的，必须调用一个消费适配器方法以便获取迭代器适配器调用的结果。\n\n```rust\nlet v1: Vec<i32> = vec![1, 2, 3];\n\nlet v2: Vec<_> = v1.iter().map(|x| x + 1).collect();\n\nassert_eq!(v2, vec![2, 3, 4]);\n```\n\n`collect()` 可以将任何可迭代的东西变成一个相关的集合。 这是在各种上下文中使用的标准库中功能更强大的方法之一。\n\n#### 10-2-3、闭包获取环境\n\n```rust\n\n#[derive(PartialEq, Debug)]\nstruct Shoe {\n    size: u32,\n    style: String,\n}\n\nfn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {\n    shoes.into_iter()\n        .filter(|s| s.size == shoe_size)\n        .collect()\n}\n\n#[test]\nfn filters_by_size() {\n    let shoes = vec![\n        Shoe { size: 10, style: String::from(\"sneaker\") },\n        Shoe { size: 13, style: String::from(\"sandal\") },\n        Shoe { size: 10, style: String::from(\"boot\") },\n    ];\n\n    let in_my_size = shoes_in_my_size(shoes, 10);\n\n    assert_eq!(\n        in_my_size,\n        vec![\n            Shoe { size: 10, style: String::from(\"sneaker\") },\n            Shoe { size: 10, style: String::from(\"boot\") },\n        ]\n    );\n}\n```\n\n如果是函数的话，需要规定其生命周期，shoe_size的生命周期和筛选的生命周期不一致\n\n#### 10-2-4、自定义迭代器\n\n```rust\n\nstruct Counter {\n    count: u32,\n}\n\nimpl Counter {\n    fn new() -> Counter {\n        Counter { count: 0 }\n    }\n}\nimpl Iterator for Counter {\n    type Item = u32;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.count += 1;\n\n        if self.count < 6 {\n            Some(self.count)\n        } else {\n            None\n        }\n    }\n}\n```\n\n## 11、智能指针\n\n### 11-1、Box\n\nbox 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。\n\n使用场景\n\n- 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候\n- 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候\n- 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候\n\n#### 11-1-1、Box<T>存储\n\n```rust\nfn main() {\n    let b = Box::new(5);\n    println!(\"b = {}\", b);\n}\n```\n\n其值是一个指向被分配在堆上的值 `5` 的 `Box`。这个程序会打印出 `b = 5`；\n\n#### 11-1-2、Box递归类型\n\n```rust\nenum List{\n    Cons(i32, Box<List>),\n    Nil,\n}\nuse crate::List::{Cons, Nil};\nfn main() {\n    let list = Cons(1,\n        Box::new(Cons(2,\n            Box::new(Cons(3,\n                Box::new(Nil))))));\n}\n```\n\n因为 `Box<T>` 是一个指针，我们总是知道它需要多少空间：指针的大小并不会根据其指向的数据量而改变。\n\n现在实现这个概念的方式更像是一个项挨着另一项，而不是一项包含另一项。\n\n### 11-2、Deref智能指针\n\n实现 `Deref` trait 允许我们重载 **解引用运算符**\n\n#### 11-2-1、解引用\n\n```rust\nfn main() {\n    let x = 5;\n    let y = &x;\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n```\n\n一旦解引用了 `y`，就可以访问 `y` 所指向的整型值并可以与 `5` 做比较\n\n11-2-2、deref的trait\n\n```rust\nuse std::ops::Deref;\n\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &self.0\n    }\n}\n```\n\n没有 `Deref` trait 的话，编译器只会把 `&` 引用类型解引用。`deref` 方法向编译器提供了一种能力：能够获取任何实现了 `Deref` trait 的类型的值，并且可以通过调用这个类型的 `deref` 方法来获取一个解引用方法已知的 `&` 引用。\n\n#### 11-2-3、解引用转换规则\n\n类似于使用 `Deref` trait 重载不可变引用的 `*` 运算符，Rust 提供了 `DerefMut` trait 用于重载可变引用的 `*` 运算符。\n\nRust 在发现类型和 trait 的实现满足以下三种情况时会进行解引用强制转换：\n\n- 当 `T: Deref<Target=U>` ：从 `&T` 到 `&U`。\n- 当 `T: DerefMut<Target=U>` ：从 `&mut T` 到 `&mut U`。\n- 当 `T: Deref<Target=U>` ：从 `&mut T` 到 `&U`。\n\n前两种情况除了可变性之外是相同的：第一种情况表明如果有一个 `&T`，而 `T` 实现了返回 `U` 类型的 `Deref`，则可以直接得到 `&U`。第二种情况表明对于可变引用也有着相同的行为。\n\n第三种情况有些微妙：Rust 也会将可变引用强转为不可变引用，但是反之是 **不可能** 的，因为不可变引用永远也不能强转为可变引用。因为根据借用规则，如果有一个可变引用，其必须是这些数据的唯一引用（否则程序将无法编译）。将一个可变引用转换为不可变引用永远也不会打破借用规则。将不可变引用转换为可变引用则需要数据只能有一个不可变引用，而借用规则无法保证这一点。因此，Rust 无法假设将不可变引用转换为可变引用是可能的。\n\n#### 11-2-4、解引用转换\n\n```rust\nuse std::ops::Deref;\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &self.0\n    }\n}\nfn hello(name: &str) {\n    println!(\"Hello, {}!\", name);\n}\nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(&(*m)[..]);\n}\n```\n\n&因为切片需要显示书写\n\nmyBox实现了Deref的trait，这个里面对Box<T>进行解引用,解引用得到String，可以对string进行操作，如果没有这个智能指针，则接出来的是MyBox\n\n### 11-3、Drop\n\n我们在智能指针上下文中讨论 `Drop` 是因为其功能几乎总是用于实现智能指针。例如，`Box<T>` 自定义了 `Drop` 用来释放 box 所指向的堆空间。\n\n#### 11-3-1、std::mem::drop\n\n```RUST\nuse std::mem::drop\nfn main() {\n    let c = CustomSmartPointer { data: String::from(\"some data\") };\n    println!(\"CustomSmartPointer created.\");\n    drop(c);\n    println!(\"CustomSmartPointer dropped before the end of main.\");\n}\n```\n\n#### 11-4、Rc<T>\n\n`Rc<T>` 的类型。其名称为 **引用计数**\n\n注意 `Rc<T>` 只能用于单线程场景；\n\n#### 11-4-1、Rc共享数据\n\n每次调用 `Rc::clone`，`Rc<List>` 中数据的引用计数都会增加，直到有零个引用之前其数据都不会被清理。\n\n```rust\nenum List {\n    Cons(i32, Rc<List>),\n    Nil,\n}\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    let b = Cons(3, Rc::clone(&a));\n    let c = Cons(4, Rc::clone(&a));\n}\n```\n\n在程序中每个引用计数变化的点，会打印出引用计数，其值可以通过调用 `Rc::strong_count` 函数获得。\n\n```rust\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    println!(\"count after creating a = {}\", Rc::strong_count(&a));\n    let b = Cons(3, Rc::clone(&a));\n    println!(\"count after creating b = {}\", Rc::strong_count(&a));\n    {\n        let c = Cons(4, Rc::clone(&a));\n        println!(\"count after creating c = {}\", Rc::strong_count(&a));\n    }\n    println!(\"count after c goes out of scope = {}\", Rc::strong_count(&a));\n}\n```\n\n`Rc<T>` 允许在程序的多个部分之间只读地共享数据,`Drop` trait 的实现当 `Rc<T>` 值离开作用域时自动减少引用计数。\n\n### 11-5、RefCell\n\n#### 11-5-1、RefCell<T>和内部可变模式\n\n`RefCell<T>` 代表其数据的唯一的所有权,\n\n类似于 `Rc<T>`，`RefCell<T>` 只能用于单线程场景。如果尝试在多线程上下文中使用`RefCell<T>`，会得到一个编译错误。第 16 章会介绍如何在多线程程序中使用 `RefCell<T>` 的功能。\n\n如下为选择 `Box<T>`，`Rc<T>` 或 `RefCell<T>` 的理由：\n\n- `Rc<T>` 允许相同数据有多个所有者；`Box<T>` 和 `RefCell<T>` 有单一所有者。\n- `Box<T>` 允许在编译时执行不可变或可变借用检查；`Rc<T>`仅允许在编译时执行不可变借用检查；`RefCell<T>` 允许在运行时执行不可变或可变借用检查。\n- 因为 `RefCell<T>` 允许在运行时执行可变借用检查，所以我们可以在即便 `RefCell<T>` 自身是不可变的情况下修改其内部的值。\n\n#### 11-5-2、refcell用于进行可变借用\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    struct MockMessenger {\n   //     sent_messages: Vec<String>,//2、因为&self并不是可变\n        //3、进行refcell借用\n           sent_messages: RefCell<Vec<String>>,\n        \n    }\n\n    impl MockMessenger {\n        fn new() -> MockMessenger {\n            MockMessenger { sent_messages: vec![] }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n     //1、self只是借用无法进行可变            self.sent_messages.push(String::from(message));\n            //4、可以使用borrow_mut进行修改\n             self.sent_messages.borrow_mut().push(String::from(message));\n          \n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        let mock_messenger = MockMessenger::new();\n        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);\n\n        limit_tracker.set_value(80);\n\n        assert_eq!(mock_messenger.sent_messages.len(), 1);\n    }\n}\n```\n\n`borrow` 方法返回 `Ref<T>` 类型的智能指针，`borrow_mut` 方法返回 `RefMut<T>` 类型的智能指针。这两个类型都实现了 `Deref`。\n\n#### 11-5-3、*Rc<T>和RefCell<T>可以拥有多个可变数据所有者\n\nRc是不允许可变的,它可以让数据有多个指针，可以进行共享，，理解为一个电视机多个人看\n\n```RUST\n#[derive(Debug)]\nenum List {\n    Cons(Rc<RefCell<i32>>, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&a));\n    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&a));\n//此处 对所有使用value的值进行处理 对所有的value值+10，a是value的值\n    *value.borrow_mut() += 10;\n\n    println!(\"a after = {:?}\", a);15，nil\n    println!(\"b after = {:?}\", b);6,15\n    println!(\"c after = {:?}\", c);10,15\n}\n```\n\nRefCell用于此处是用来进行可变处理的，\n\n### 11-6、循环引用\n\n```rust\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse crate::List::{Cons, Nil};\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell<Rc<List>>),\n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n        match self {\n            Cons(_, item) => Some(item),\n            Nil => None,\n        }\n    }\n}\nfn main() {\n    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n\n    println!(\"a initial rc count = {}\", Rc::strong_count(&a));\n    println!(\"a next item = {:?}\", a.tail());\n\n    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));\n\n    println!(\"a rc count after b creation = {}\", Rc::strong_count(&a));\n    println!(\"b initial rc count = {}\", Rc::strong_count(&b));\n    println!(\"b next item = {:?}\", b.tail());\n\n    if let Some(link) = a.tail() {\n        //将其Cons中的第二位RefCell的值就是a的RefCell::new(Rc::new(Nil))  但b里面又有a所以循环引用了\n        *link.borrow_mut() = Rc::clone(&b);\n    }\n\n    println!(\"b rc count after changing a = {}\", Rc::strong_count(&b));\n    println!(\"a rc count after changing a = {}\", Rc::strong_count(&a));\n\n    // Uncomment the next line to see that we have a cycle;\n    // it will overflow the stack\n    // println!(\"a next item = {:?}\", a.tail());\n}\n```\n\n避免循环引用\n\n#### 11-6、weak\n\n```rust\nuse std::rc::{Rc, Weak};\nuse std::cell::RefCell;\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n\n    let branch = Rc::new(Node {\n        value: 5,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![Rc::clone(&leaf)]),\n    });\n//调用 Rc::downgrade 时会得到 Weak<T> 类型的智能指针\n    //强引用代表如何共享 Rc<T> 实例的所有权，但弱引用并不属于所有权关系。他们不会造成引用循环，因为任何弱引用的循环会在其相关的强引用计数为 0 时被打断。\n    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n}\n```\n\n结果\n\n```rust\nleaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [] } }] } })\n```\n\n`Rc<Node>` 的强引用计数减少为 0，所以其 `Node` 被丢弃。来自 `leaf.parent` 的弱引用计数 1 与 `Node` 是否被丢弃无关，所以并没有产生任何内存泄漏！\n\n## 12、并发\n\n### 12-1、线程\n\n- 竞争状态（Race conditions），多个线程以不一致的顺序访问数据或资源\n- 死锁（Deadlocks），两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行\n- 只会发生在特定情况且难以稳定重现和修复的 bug\n\n#### 12-1-1、spawn新线程\n\n```rust\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n\nhi number 1 from the main thread!\nhi number 1 from the spawned thread!\nhi number 2 from the main thread!\nhi number 2 from the spawned thread!\nhi number 3 from the main thread!\nhi number 3 from the spawned thread!\nhi number 4 from the main thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\n```\n\n`thread::sleep` 调用强制线程停止执行一小段时间，这会允许其他不同的线程运行。这些线程可能会轮流运行，不过并不保证如此：这依赖操作系统如何调度线程\n\n#### 12-1-2、join等待所有线程结束\n\n线程是异步操作，**阻塞**（*Blocking*） 线程意味着阻止该线程执行工作或退出\n\n```rust\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    println!(\"hello world1\");\n    let handle = thread::spawn(|| {\n        println!(\"hello world2\");\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n    println!(\"hello world3\");\n    handle.join().unwrap();\n    println!(\"hello world4\");\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\nhello world1\nhello world3\nhello world2\nhi number 1 from the spawned thread!\nhi number 2 from the spawned thread!\nhi number 3 from the spawned thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\nhi number 6 from the spawned thread!\nhi number 7 from the spawned thread!\nhi number 8 from the spawned thread!\nhi number 9 from the spawned thread!\nhello world4\nhi number 1 from the main thread!\nhi number 2 from the main thread!\nhi number 3 from the main thread!\nhi number 4 from the main thread!\n```\n\n#### 12-1-3、move转移所有权\n\n通过move捕获环境中的所有权并且实现转移，不能在主线程中使用drop清理代码，所有权转移到spawn中了\n\n```rust\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n\n    let handle = thread::spawn(move || {\n        println!(\"Here's a vector: {:?}\", v);\n    });\n\n    handle.join().unwrap();\n}\n```\n\n### 12-2、通讯\n\n#### 12-2-1、mpsc::channel\n\n`mpsc::channel` 函数返回一个元组：第一个元素是发送端，而第二个元素是接收端。由于历史原因，`tx` 和 `rx` 通常作为 **发送者**（*transmitter*）和 **接收者**（*receiver*）的缩写\n\n\n\n```rust\nuse std::thread;\nuse std::sync::mpsc;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n    });\n    let received = rx.recv().unwrap();\n    println!(\"Got: {}\", received);\n}\n```\n\n`send` 函数获取其参数的所有权并移动这个值归接收者所有\n\n#### 12-2-2、发送多个值\n\n```rust\nuse std::thread;\nuse std::sync::mpsc;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n}\n```\n\n将 `rx` 当作一个迭代器。对于每一个接收到的值，我们将其打印出来。当通道被关闭时，迭代器也将结束\n\n#### 12-2-3、通过克隆创建多个发送者\n\n```rust\n\nlet (tx, rx) = mpsc::channel();\n\nlet tx1 = tx.clone();\nthread::spawn(move || {\n    let vals = vec![\n        String::from(\"hi\"),\n        String::from(\"from\"),\n        String::from(\"the\"),\n        String::from(\"thread\"),\n    ];\n\n    for val in vals {\n        tx1.send(val).unwrap();\n        thread::sleep(Duration::from_secs(1));\n    }\n});\n\nthread::spawn(move || {\n    let vals = vec![\n        String::from(\"more\"),\n        String::from(\"messages\"),\n        String::from(\"for\"),\n        String::from(\"you\"),\n    ];\n\n    for val in vals {\n        tx.send(val).unwrap();\n        thread::sleep(Duration::from_secs(1));\n    }\n});\n\nfor received in rx {\n    println!(\"Got: {}\", received);\n}\n\nGot: hi\nGot: more\nGot: from\nGot: messages\nGot: for\nGot: the\nGot: thread\nGot: you\n```\n\n这一次，在创建新线程之前，我们对通道的发送端调用了 `clone` 方法。这会给我们一个可以传递给第一个新建线程的发送端句柄。我们会将原始的通道发送端传递给第二个新建线程。这样就会有两个线程，每个线程将向通道的接收端发送不同的消息。\n\n## 12-3、共享状态并发\n\n### 12-3-1、互斥器\n\n**互斥器**（*mutex*）是 *mutual exclusion* 的缩写，也就是说，任意时刻，其只允许一个线程访问某些数据。为了访问互斥器中的数据，线程首先需要通过获取互斥器的 **锁**（*lock*）来表明其希望访问数据。锁是一个作为互斥器一部分的数据结构，它记录谁有数据的排他访问权。因此，我们描述互斥器为通过锁系统 **保护**（*guarding*）其数据。\n\n1. 在使用数据之前尝试获取锁。\n2. 处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。\n\n#### 12-3-2、Mutex<T>的api\n\n```rust\nuse std::sync::Mutex;\n\nfn main() {\n    let m = Mutex::new(5);\n\n    {\n        let mut num = m.lock().unwrap();\n        *num = 6;\n        //离开此作用域时，lock锁自动释放\n    }\n\n    println!(\"m = {:?}\", m);\n}\n```\n\n`Mutex<T>` 是一个智能指针。更准确的说，`lock` 调用 **返回** 一个叫做 `MutexGuard` 的智能指针。这个智能指针实现了 `Deref` 来指向其内部数据；其也提供了一个 `Drop` 实现当 `MutexGuard` 离开作用域时自动释放锁，这正发生于示例 16-12 内部作用域的结尾。为此，我们不会冒忘记释放锁并阻塞互斥器为其它线程所用的风险，因为锁的释放是自动发生的。\n\n#### 12-3-3、共享Mutex<T>\n\n所幸 `Arc<T>` **正是** 这么一个类似 `Rc<T>` 并可以安全的用于并发环境的类型。字母 “a” 代表 **原子性**（*atomic*），所以这是一个**原子引用计数**（*atomically reference counted*）类型。原子性是另一类这里还未涉及到的并发原语：请查看标准库中 `std::sync::atomic` 的文档来获取更多细节。其中的要点就是：原子性类型工作起来类似原始类型，不过可以安全的在线程间共享。\n\n```rust\nuse std::sync::{Mutex, Arc};\nuse std::thread;\n\nfn main() {\n    //问题，多个线程中move会多次获取counter的所有权我们该怎么解决\n    //方案一 使用Rc获取多个所有权，但每次使用需要使用Rc.clone()对其进行计数，无法实现，此方案不可行\n    //方案二 使用Arc进行原子引用计数\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n```\n\n#### 12-3-4、RefCell<T>/Rc<T>与Mutex<T>/Arc<T>的相似性\n\n使用 `RefCell<T>` 可以改变 `Rc<T>` 中的内容那样，同样的可以使用 `Mutex<T>` 来改变 `Arc<T>` 中的内容\n\n`Mutex<T>` 提供了内部可变性;\n\n都是通过先引用计数再获取其所有权\n\n```RUST\n let receiver = Arc::new(Mutex::new(receiver));\n let value = Rc::new(RefCell::new(5));\n```\n\n\n\n这时两个 `Rc<T>` 值相互引用，造成内存泄漏。同理，`Mutex<T>` 也有造成 **死锁**（*deadlock*） 的风险。这发生于当一个操作需要锁住两个资源而两个线程各持一个锁，这会造成它们永远相互等待。如果你对这个主题感兴趣，尝试编写一个带有死锁的 Rust 程序，接着研究任何其他语言中使用互斥器的死锁规避策略并尝试在 Rust 中实现他们。标准库中 `Mutex<T>` 和 `MutexGuard` 的 API 文档会提供有用的信息。\n\n### 12-4、使用Sync与Send的Trait\n\n1. `Send` 标记 trait 表明类型的所有权可以在线程间传递\n2. `Sync` 标记 trait 表明一个实现了 `Sync` 的类型可以安全的在多个线程中拥有其值的引用。\n3. 通常并不需要手动实现 `Send` 和 `Sync` trait，因为由 `Send` 和 `Sync` 的类型组成的类型，自动就是 `Send` 和 `Sync` 的。手动实现是不安全的\n\n## 13、Rust的面向对象\n\n### 13-1、特点\n\n另一个通常与面向对象编程相关的方面是 **封装**（*encapsulation*）的思想：对象的实现细节不能被使用对象的代码获取到。所以唯一与对象交互的方式是通过对象提供的公有 API；使用对象的代码无法深入到对象内部并直接改变数据或者行为。封装使得改变和重构对象的内部时无需改变使用对象的代码。\n\n**继承**（*Inheritance*）是一个很多编程语言都提供的机制，一个对象可以定义为继承另一个对象的定义，这使其可以获得父对象的数据和行为，而无需重新定义。\n\n Rust 代码可以使用默认 trait 方法实现来进行共享\n\n表现为子类型可以用于父类型被使用的地方。这也被称为 **多态**（*polymorphism*），这意味着如果多种对象共享特定的属性，则可以相互替代使用。\n\n### 13-2、trait\n\n#### 13-2-1、trait的实现\n\n我们通过指定某种指针来创建 trait 对象，例如 `&` 引用或 `Box<T>` 智能指针，还有 `dyn` keyword\n\n```rust\npub trait Draw {\n    fn draw(&self);\n}\npub struct Screen {\n    pub components: Vec<Box<dyn Draw>>,\n}\nimpl Screen {\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n//泛型类型参数一次只能替代一个具体类型，而 trait 对象则允许在运行时替代多种具体类型。\n//使用bound\n//我在库里调用他只会认出一种类型参数传进去 需要多种类型传入的情况无法使用\npub struct Screen<T: Draw> {\n    pub components: Vec<T>,\n}\n\nimpl<T> Screen<T>\n    where T: Draw {\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n```\n\n```rust\nuse gui::{Screen, Button};\n\nfn main() {\n    let screen = Screen {\n        components: vec![\n            Box::new(SelectBox {\n                width: 75,\n                height: 10,\n                options: vec![\n                    String::from(\"Yes\"),\n                    String::from(\"Maybe\"),\n                    String::from(\"No\")\n                ],\n            }),\n            Box::new(Button {\n                width: 50,\n                height: 10,\n                label: String::from(\"OK\"),\n            }),\n        ],\n    };\n\n    screen.run();\n}\n```\n\n#### 13-2-2、trait要求对象安全\n\n- 返回值类型不为 `Self`\n- 方法没有任何泛型类型参数\n\n```rust\npub struct Screen {\n    pub components: Vec<Box<dyn Clone>>,\n}\n```\n\n例如，如果尝试实现示例 17-4 中的 `Screen` 结构体来存放实现了 `Clone` trait 而不是 `Draw` trait 的类型\n\n```rust\nerror[E0038]: the trait `std::clone::Clone` cannot be made into an object\n --> src/lib.rs:2:5\n  |\n2 |     pub components: Vec<Box<dyn Clone>>,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone`\n  cannot be made into an object\n  |\n  = note: the trait cannot require that `Self : Sized`\n```\n\n## 14、模式和匹配\n\n### 14-1、模式\n\n#### 14-1-1、match\n\n`match` 表达式必须是 **穷尽**（*exhaustive*）的，意为 `match` 表达式所有可能的值都必须被考虑到。\n\n```rust\nmatch VALUE {\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n}\n```\n\n#### 14-1-2、if let条件表达式\n\n```rust\nfn main() {\n    let favorite_color: Option<&str> = None;\n    let is_tuesday = false;\n    let age: Result<u8, _> = \"34\".parse();\n\n    if let Some(color) = favorite_color {\n        println!(\"Using your favorite color, {}, as the background\", color);\n    } else if is_tuesday {\n        println!(\"Tuesday is green day!\");\n    } else if let Ok(age) = age {\n        if age > 30 {\n         // 打印此代码\n            println!(\"Using purple as the background color\");\n         \n        } else {\n            println!(\"Using orange as the background color\");\n            \n        }\n    } else {\n        println!(\"Using blue as the background color\");\n    }\n}\n```\n\n`if let` 表达式的缺点在于其穷尽性没有为编译器所检查，而 `match` 表达式则检查了。如果去掉最后的 `else` 块而遗漏处理一些情况，编译器也不会警告这类可能的逻辑错误。\n\n#### 14-1-3、while let 条件循环\n\n一个与 `if let` 结构类似的是 `while let` 条件循环，它允许只要模式匹配就一直进行 `while` 循环\n\n```rust\nlet mut stack = Vec::new();\n\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\nwhile let Some(top) = stack.pop() {\n    println!(\"{}\", top);\n}\n```\n\n这个例子会打印出 3、2 接着是 1。`pop` 方法取出 vector 的最后一个元素并返回 `Some(value)`。如果 vector 是空的，它返回 `None`。`while` 循环只要 `pop` 返回 `Some` 就会一直运行其块中的代码。一旦其返回 `None`，`while` 循环停止。我们可以使用 `while let` 来弹出栈中的每一个元素。\n\n#### 14-1-4、for循环\n\n```rust\nlet v = vec!['a', 'b', 'c'];\n\nfor (index, value) in v.iter().enumerate() {\n    println!(\"{} is at index {}\", value, index);\n}\n```\n\n这里使用 `enumerate` 方法适配一个迭代器来产生一个值和其在迭代器中的索引，他们位于一个元组中。第一个 `enumerate` 调用会产生元组 `(0, 'a')`。当这个值匹配模式 `(index, value)`，`index` 将会是 0 而 `value` 将会是 `'a'`，并打印出第一行输出。\n\n#### 14-1-5、let语句\n\n```rust\nlet PATTERN = EXPRESSION;\n```\n\nlet本身就是一种模式匹配,进行解构的同时更为明显\n\n```rust\nlet (x, y, z) = (1, 2, 3);\n```\n\n这里将一个元组与模式匹配。Rust 会比较值 `(1, 2, 3)` 与模式 `(x, y, z)` 并发现此值匹配这个模式。在这个例子中，将会把 `1` 绑定到 `x`，`2` 绑定到 `y` 并将 `3` 绑定到 `z`。你可以将这个元组模式看作是将三个独立的变量模式结合在一起。\n\n#### 14-1-6、函数参数\n\n函数参数也是一个模式匹配\n\n```rust\nfn print_coordinates(&(x, y): &(i32, i32)) {\n    println!(\"Current location: ({}, {})\", x, y);\n}\n\nfn main() {\n    let point = (3, 5);\n    print_coordinates(&point);\n}\n```\n\n这会打印出 `Current location: (3, 5)`。值 `&(3, 5)` 会匹配模式 `&(x, y)`，如此 `x` 得到了值 `3`，而 `y`得到了值 `5`。\n\n### 14-2、refutability可反驳性\n\nirrefutable（不可反驳的）:一个例子就是 `let x = 5;` 语句中的 `x`，因为 `x` 可以匹配任何值所以不可能会失败。\n\nrefutable（可反驳的）:能匹配任何传递的可能值的模式被称为是 **不可反驳的**（*irrefutable*）。一个这样的例子便是 `if let Some(x) = a_value` 表达式中的 `Some(x)`；如果变量 `a_value` 中的值是 `None` 而不是 `Some`，那么 `Some(x)` 模式不能匹配。\n\n函数参数、 `let` 语句和 `for` 循环只能接受不可反驳的模式，因为通过不匹配的值程序无法进行有意义的工作。`if let` 和 `while let` 表达式被限制为只能接受可反驳的模式，因为根据定义他们意在处理可能的失败：条件表达式的功能就是根据成功或失败执行不同的操作。\n\n```rust\nlet Some(x) = some_option_value;\n//修正\nif let Some(x) = some_option_value {\n    println!(\"{}\", x);\n}\n```\n\n若 `some_option_value` 的值是 `None`，则不会成功匹配模式 `Some(x)`，表明这个模式是可反驳的。然而 `let` 语句只能接受不可反驳模式，因为代码不能通过 `None` 值进行有效的操作。Rust 会在编译时抱怨我们尝试在要求不可反驳模式的地方使用可反驳模式：\n\n```rust\nerror[E0005]: refutable pattern in local binding: `None` not covered\n -->\n  |\n3 | let Some(x) = some_option_value;\n  |     ^^^^^^^ pattern `None` not covered\n```\n\n我们给了代码一个得以继续的出路！这段代码完全有效，尽管这意味着我们不能在避免产生警告的情况下使用无可辩驳的模式。如果为 `if let` 提供了一个总是会匹配的模式，比如示例 18-10 中的 `x`，编译器会给出一个警告。\n\n```rust\nif let x = 5 {\n    println!(\"{}\", x);\n};\nwarning: irrefutable if-let pattern\n --> <anon>:2:5\n  |\n2 | /     if let x = 5 {\n3 | |     println!(\"{}\", x);\n4 | | };\n  | |_^\n  |\n  = note: #[warn(irrefutable_let_patterns)] on by default\n```\n\n基于此，`match` 匹配分支必须使用可反驳模式，除了最后一个分支需要使用能匹配任何剩余值的不可反驳模式。Rust 允许我们在只有一个匹配分支的 `match` 中使用不可反驳模式，不过这么做不是特别有用，并可以被更简单的 `let` 语句替代。\n\n### 14-3、模式语法\n\n#### 14-3-1、匹配命名变量\n\n```rust\nfn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println!(\"Got 50\"),\n        Some(y) => println!(\"Matched, y = {:?}\", y),//5\n        _ => println!(\"Default case, x = {:?}\", x),\n    }\n\n    println!(\"at the end: x = {:?}, y = {:?}\", x, y);//Some(5),10\n}\n```\n\n让我们看看当 `match` 语句运行的时候发生了什么。第一个匹配分支的模式并不匹配 `x` 中定义的值，所以代码继续执行。\n\n第二个匹配分支中的模式引入了一个新变量 `y`，它会匹配任何 `Some` 中的值。因为我们在 `match` 表达式的新作用域中，这是一个新变量，而不是开头声明为值 10 的那个 `y`。这个新的 `y` 绑定会匹配任何 `Some` 中的值，在这里是 `x` 中的值。因此这个 `y` 绑定了 `x` 中 `Some` 内部的值。这个值是 5，所以这个分支的表达式将会执行并打印出 `Matched, y = 5`。\n\n如果 `x` 的值是 `None` 而不是 `Some(5)`，头两个分支的模式不会匹配，所以会匹配下划线。这个分支的模式中没有引入变量 `x`，所以此时表达式中的 `x` 会是外部没有被覆盖的 `x`。在这个假想的例子中，`match` 将会打印 `Default case, x = None`。\n\n一旦 `match` 表达式执行完毕，其作用域也就结束了，同理内部 `y` 的作用域也结束了。最后的 `println!` 会打印 `at the end: x = Some(5), y = 10`。\n\n#### 14-3-2、多个模式\n\n在 `match` 表达式中，可以使用 `|` 语法匹配多个模式，它代表 **或**（*or*）的意思。例如，如下代码将 `x` 的值与匹配分支相比较，第一个分支有 **或** 选项，意味着如果 `x` 的值匹配此分支的任一个值，它就会运行：\n\n```rust\n\nlet x = 1;\n\nmatch x {\n    1 | 2 => println!(\"one or two\"),\n    3 => println!(\"three\"),\n    _ => println!(\"anything\"),\n}\n```\n\n#### 14-3-3、通过..=匹配值的范围\n\n如果 `x` 是 1、2、3、4 或 5，第一个分支就会匹配。这相比使用 `|` 运算符表达相同的意思更为方便；相比 `1..=5`，使用 `|` 则不得不指定 `1 | 2 | 3 | 4 | 5`。相反指定范围就简短的多，特别是在希望匹配比如从 1 到 1000 的数字的时候！\n\n```rust\nlet x = 5;\n\nmatch x {\n    1..=5 => println!(\"one through five\"),\n    _ => println!(\"something else\"),\n}\n```\n\n如下是一个使用 `char` 类型值范围的例子：\n\n```\nlet x = 'c';\n\nmatch x {\n    'a'..='j' => println!(\"early ASCII letter\"),\n    'k'..='z' => println!(\"late ASCII letter\"),\n    _ => println!(\"something else\"),\n}\n```\n\n#### 14-3-4、解构并分解值\n\n也可以使用模式来解构结构体、枚举、元组和引用，以便使用这些值的不同部分。让我们来分别看一看。\n\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x: a, y: b } = p;\n    assert_eq!(0, a);\n    assert_eq!(7, b);\n}\n```\n\n这段代码创建了变量 `a` 和 `b` 来匹配结构体 `p` 中的 `x` 和 `y` 字段。\n\n```rust\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    match p {\n        Point { x, y: 0 } => println!(\"On the x axis at {}\", x),\n        Point { x: 0, y } => println!(\"On the y axis at {}\", y),\n        Point { x, y } => println!(\"On neither axis: ({}, {})\", x, y),\n    }\n}\n//实际上是模式进行匹配，匹配成功的才会拿到y,拿不到x，x他不是为止值解构\n```\n\n第一个分支通过指定字段 `y` 匹配字面量 `0` 来匹配任何位于 `x` 轴上的点。此模式仍然创建了变量 `x` 以便在分支的代码中使用。\n\n类似的，第二个分支通过指定字段 `x` 匹配字面量 `0` 来匹配任何位于 `y` 轴上的点，并为字段 `y` 创建了变量 `y`。第三个分支没有指定任何字面量，所以其会匹配任何其他的 `Point` 并为 `x` 和 `y` 两个字段创建变量。\n\n在这个例子中，值 `p` 因为其 `x` 包含 0 而匹配第二个分支，因此会打印出 `On the y axis at 7`。\n\n#### 14-3-5、解构枚举\n\n```rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\nfn main() {\n    let msg = Message::ChangeColor(0, 160, 255);\n\n    match msg {\n        Message::Quit => {\n            println!(\"The Quit variant has no data to destructure.\")\n        }\n        Message::Move { x, y } => {\n            println!(\n                \"Move in the x direction {} and in the y direction {}\",\n                x,\n                y\n            );\n        }\n        Message::Write(text) => println!(\"Text message: {}\", text),\n        Message::ChangeColor(r, g, b) => {\n            println!(\n                \"Change the color to red {}, green {}, and blue {}\",\n                r,\n                g,\n                b\n            )\n        }\n    }\n}\n```\n\n#### 14-3-6、解构嵌套的结构体和枚举\n\n```rust\nenum Color {\n   Rgb(i32, i32, i32),\n   Hsv(i32, i32, i32),\n}\n\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(Color),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));\n\n    match msg {\n        Message::ChangeColor(Color::Rgb(r, g, b)) => {\n            println!(\n                \"Change the color to red {}, green {}, and blue {}\",\n                r,\n                g,\n                b\n            )\n        }\n        Message::ChangeColor(Color::Hsv(h, s, v)) => {\n            println!(\n                \"Change the color to hue {}, saturation {}, and value {}\",\n                h,\n                s,\n                v\n            )\n        }\n        _ => ()\n    }\n}\n```\n\n#### 14-3-7、解构结构体和元组\n\n```rust\nlet ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });\n```\n\n#### 14-3-8、忽略\n\n有时忽略模式中的一些值是有用的，比如 `match` 中最后捕获全部情况的分支实际上没有做任何事，但是它确实对所有剩余情况负责。有一些简单的方法可以忽略模式中全部或部分值：使用 `_` 模式（我们已经见过了），在另一个模式中使用 `_` 模式，使用一个以下划线开始的名称，或者使用 `..` 忽略所剩部分的值。让我们来分别探索如何以及为什么要这么做。\n\n函数\n\n```rust\nfn foo(_: i32, y: i32) {\n    println!(\"This code only uses the y parameter: {}\", y);\n}\n\nfn main() {\n    foo(3, 4);\n}\n```\n\n嵌套\n\n```rust\nlet mut setting_value = Some(5);\nlet new_setting_value = Some(10);\n\nmatch (setting_value, new_setting_value) {\n    (Some(_), Some(_)) => {\n        println!(\"Can't overwrite an existing customized value\");\n    }\n    _ => {\n        setting_value = new_setting_value;\n    }\n}\n\nprintln!(\"setting is {:?}\", setting_value);\n```\n\n这段代码会打印出 `Can't overwrite an existing customized value` 接着是 `setting is Some(5)`\n\n测试 `setting_value` 和 `new_setting_value` 都为 `Some` 成员的情况,如果有值不为Some才会调用下面的赋值\n\n元组\n\n```rust\nlet numbers = (2, 4, 8, 16, 32);\n\nmatch numbers {\n    (first, _, third, _, fifth) => {\n        println!(\"Some numbers: {}, {}, {}\", first, third, fifth)\n    },\n}\n```\n\n忽略未使用变量\n\n```rust\nfn main() {\n    let _x = 5;\n    let y = 10;\n\n\nlet s = Some(String::from(\"Hello!\"));\n//if let Some(_s) = s 使用_s会报错\nif let Some(_) = s {\n    println!(\"found a string\");\n}\n\nprintln!(\"{:?}\", s);\n}\n```\n\n因为 `s` 的值仍然会移动进 `_s`，并阻止我们再次使用 `s`。然而只使用下划线本身，并不会绑定值。示例 18-22 能够无错编译，因为 `s` 没有被移动进 `_`\n\n用..忽略剩余值\n\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nlet origin = Point { x: 0, y: 0, z: 0 };\n\nmatch origin {\n    Point { x, .. } => println!(\"x is {}\", x),\n}\n```\n\n只操作 `x` 坐标并忽略 `y` 和 `z` 字段的值\n\n元组..忽略\n\n```rust\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, .., last) => {\n            println!(\"Some numbers: {}, {}\", first, last);\n        },\n    }\n}\n```\n\n `..` 必须是无歧义的。如果期望匹配和忽略的值是不明确的，Rust 会报错\n\n```rust\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (.., second, ..) => {\n            println!(\"Some numbers: {}\", second)\n        },\n    }\n}\n```\n\n#### 14-3-9、匹配守卫\n\n**匹配守卫**（*match guard*）是一个指定于 `match` 分支模式之后的额外 `if` 条件，它也必须被满足才能选择此分支。匹配守卫用于表达比单独的模式所能允许的更为复杂的情况。\n\n```rust\nlet num = Some(4);\n\nmatch num {\n    Some(x) if x < 5 => println!(\"less than five: {}\", x),\n    Some(x) => println!(\"{}\", x),\n    None => (),\n}\n```\n\n现在这会打印出 `Default case, x = Some(5)`。现在第二个匹配分支中的模式不会引入一个覆盖外部 `y` 的新变量 `y`，这意味着可以在匹配守卫中使用外部的 `y`。相比指定会覆盖外部 `y` 的模式 `Some(y)`，这里指定为 `Some(n)`。此新建的变量 `n` 并没有覆盖任何值，因为 `match` 外部没有变量 `n`。\n\n```rust\nfn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println!(\"Got 50\"),\n        Some(n) if n == y => println!(\"Matched, n = {}\", n),\n        _ => println!(\"Default case, x = {:?}\", x),\n    }\n\n    println!(\"at the end: x = {:?}, y = {}\", x, y);\n}\n```\n\n也可以在匹配守卫中使用 **或** 运算符 `|` 来指定多个模式，同时匹配守卫的条件会作用于所有的模式\n\n```rust\n\nlet x = 4;\nlet y = false;\n\nmatch x {\n    4 | 5 | 6 if y => println!(\"yes\"),\n    _ => println!(\"no\"),\n}\n//优先级\n(4 | 5 | 6) if y => ...\n```\n\n#### 14-3-10、@绑定\n\n*at* 运算符（`@`）允许我们在创建一个存放值的变量的同时测试其值是否匹配模式。\n\n```rust\nenum Message {\n    Hello { id: i32 },\n}\n\nlet msg = Message::Hello { id: 5 };\n\nmatch msg {\n    Message::Hello { id: id_variable @ 3..=7 } => {\n        println!(\"Found an id in range: {}\", id_variable)\n    },\n    Message::Hello { id: 10..=12 } => {\n        println!(\"Found an id in another range\")\n    },\n    Message::Hello { id } => {\n        println!(\"Found some other id: {}\", id)\n    },\n}\n```\n\n使用 `@` 可以在一个模式中同时测试和保存变量值。\n\n## 15、高级特征\n\n### 15-1、不安全的rust\n\nRust 还隐藏有第二种语言，它不会强制执行这类内存安全保证：这被称为 **不安全 Rust**（*unsafe Rust*）。它与常规 Rust 代码无异，但是会提供额外的超能力。\n\n#### 15-1-1、unsafe\n\n有五类可以在不安全 Rust 中进行而不能用于安全 Rust 的操作，它们称之为 “不安全的超能力。\n\n- 解引用裸指针\n- 调用不安全的函数或方法\n- 访问或修改可变静态变量\n- 实现不安全 trait\n- 访问 `union` 的字段\n\n这五类操作必须位于标记为 `unsafe` 的块中，就能够知道任何与内存安全相关的错误必定位于 `unsafe` 块内。保持 `unsafe` 块尽可能小\n\n#### 15-1-2、解引用指针\n\n裸指针与引用和智能指针的区别在于：\n\n- 允许忽略借用规则，可以同时拥有不可变和可变的指针，或多个指向相同位置的可变指针\n- 不保证指向有效的内存\n- 允许为空\n- 不能实现任何自动清理功能\n\n同时创建不可变和可变裸指针\n\n```rust\n\nlet mut num = 5;\n\nlet r1 = &num as *const i32;\nlet r2 = &mut num as *mut i32;\n```\n\n可以在安全代码中 **创建** 裸指针，只是不能在不安全块之外 **解引用** 裸指针\n\n创建一个指针不会造成任何危险；只有当访问其指向的值时才有可能遇到无效的值。需要在unsafe中调用\n\n```rust\n\nlet mut num = 5;\n\nlet r1 = &num as *const i32;\nlet r2 = &mut num as *mut i32;\n\nunsafe {\n    println!(\"r1 is: {}\", *r1);\n    println!(\"r2 is: {}\", *r2);\n}\n```\n\n#### 15-1-3、不安全函数或方法\n\n``split_at_mut``\n\n```rust\n\nlet mut v = vec![1, 2, 3, 4, 5, 6];\n\nlet r = &mut v[..];\n\nlet (a, b) = r.split_at_mut(3);\n\nassert_eq!(a, &mut [1, 2, 3]);\nassert_eq!(b, &mut [4, 5, 6]);\n```\n\nRust 的借用检查器不能理解我们要借用这个 slice 的两个不同部分：它只知道我们借用了同一个 slice 两次。本质上借用 slice 的不同部分是可以的，因为结果两个 slice 不会重叠，不过 Rust 还没有智能到能够理解这些。当我们知道某些事是可以的而 Rust 不知道的时候，就是触及不安全代码的时候了\n\n```rust\nuse std::slice;\n\nfn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {\n    let len = slice.len();\n    let ptr = slice.as_mut_ptr();\n\n    assert!(mid <= len);\n\n    unsafe {\n        (slice::from_raw_parts_mut(ptr, mid),\n         slice::from_raw_parts_mut(ptr.add(mid), len - mid))\n    }\n}\n```\n\n`slice::from_raw_parts_mut` 函数是不安全的因为它获取一个裸指针，并必须确信这个指针是有效的。裸指针上的 `add` 方法也是不安全的，因为其必须确信此地址偏移量也是有效的指针。因此必须将 `slice::from_raw_parts_mut` 和 `add` 放入 `unsafe` 块中以便能调用它们。通过观察代码，和增加 `mid` 必然小于等于 `len` 的断言\n\n#### 15-1-4、使用exterm调用外部代码\n\n有时你的 Rust 代码可能需要与其他语言编写的代码交互。为此 Rust 有一个关键字，`extern`，有助于创建和使用 **外部函数接口**（*Foreign Function Interface*， FFI）。外部函数接口是一个编程语言用以定义函数的方式，其允许不同（外部）编程语言调用这些函数\n\n```rust\nextern \"C\" {\n    fn abs(input: i32) -> i32;\n}\n\nfn main() {\n    unsafe {\n        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n    }\n}\n```\n\n在 `extern \"C\"` 块中，列出了我们希望能够调用的另一个语言中的外部函数的签名和名称。`\"C\"` 部分定义了外部函数所使用的 **应用二进制接口**（*application binary interface*，ABI） —— ABI 定义了如何在汇编语言层面调用此函数。`\"C\"` ABI 是最常见的，并遵循 C 编程语言的 ABI。\n\n使用 `extern` 来创建一个允许其他语言调用 Rust 函数的接口。不同于 `extern` 块，就在 `fn` 关键字之前增加 `extern` 关键字并指定所用到的 ABI。还需增加 `#[no_mangle]` 标注来告诉 Rust 编译器不要 mangle 此函数的名称。\n\n```rust\n\n#[no_mangle]\npub extern \"C\" fn call_from_c() {\n    println!(\"Just called a Rust function from C!\");\n}\n```\n\n#### 15-1-5、访问或修改可变静态变量\n\n```rust\nstatic HELLO_WORLD: &str = \"Hello, world!\";\n\nfn main() {\n    println!(\"name is: {}\", HELLO_WORLD);\n}\n```\n\n静态变量一般以大写形式书写；\n\n常量与不可变静态变量可能看起来很类似，不过一个微妙的区别是静态变量中的值有一个固定的内存地址。使用这个值总是会访问相同的地址。另一方面，常量则允许在任何被用到的时候复制其数据。\n\n常量与静态变量的另一个区别在于静态变量可以是可变的。访问和修改可变静态变量都是 **不安全** 的\n\n```rust\nstatic mut COUNTER: u32 = 0;\n\nfn add_to_count(inc: u32) {\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    add_to_count(3);\n\n    unsafe {\n        println!(\"COUNTER: {}\", COUNTER);\n    }\n}\n```\n\n#### 15-1-6、不安全trait\n\n`unsafe` 的另一个操作用例是实现不安全 trait。当 trait 中至少有一个方法中包含编译器无法验证的不变式（invariant）时 trait 是不安全的。可以在 `trait` 之前增加 `unsafe` 关键字将 trait 声明为 `unsafe`，同时 trait 的实现也必须标记为 `unsafe`，\n\n```\nunsafe trait Foo {\n    // methods go here\n}\n\nunsafe impl Foo for i32 {\n    // method implementations go here\n}\n```\n\nRust 不能验证我们的类型保证可以安全的跨线程发送或在多线程间访问，所以需要我们自己进行检查并通过 `unsafe` 表明。\n\n#### 15-1-7、访问联合体中的字段\n\n仅适用于 `unsafe` 的最后一个操作是访问 **联合体** 中的字段，`union` 和 `struct` 类似，但是在一个实例中同时只能使用一个声明的字段。联合体主要用于和 C 代码中的联合体交互\n\n### 15-2、高级trait\n\n#### 15-2-1、关联类型在trait定义中指定占位符类型\n\n**关联类型**（*associated types*）是一个将类型占位符与 trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型。\n\n```rust\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n}\n```\n\n和泛型的区别\n\n泛型需要在每个实现中标注类型；\n\n当 trait 有泛型参数时，可以多次实现这个 trait，每次需改变泛型参数的具体类型。接着当使用 `Counter` 的 `next` 方法时，必须提供类型标注来表明希望使用 `Iterator` 的哪一个实现。\n\n#### 15-2-2、运算符重载\n\n```rust\nuse std::ops::Add;\n\n#[derive(Debug, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -> Point {\n        //Point 结构体上实现 Add trait 来重载 + 运算符，这样就可以将两个 Point 实例相加了\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nfn main() {\n    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n               Point { x: 3, y: 3 });\n}\n```\n\n`Add` trait 有一个叫做 `Output` 的关联类型，它用来决定 `add` 方法的返回值类型\n\n```rust\n\ntrait Add<RHS=Self> {\n    type Output;\n\n    fn add(self, rhs: RHS) -> Self::Output;\n}\n```\n\n尖括号中的 `RHS=Self`：这个语法叫做 **默认类型参数**（*default type parameters*）。`RHS` 是一个泛型类型参数（“right hand side” 的缩写），它用于定义 `add` 方法中的 `rhs` 参数。如果实现 `Add` trait 时不指定 `RHS` 的具体类型，`RHS` 的类型将是默认的 `Self` 类型，也就是在其上实现 `Add` 的类型\n\n `Add` trait 时希望自定义 `RHS` 类型而不是使用默认类型的例子\n\n```rust\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add<Meters> for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -> Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n```\n\n为了使 `Millimeters` 和 `Meters` 能够相加，我们指定 `impl Add<Meters>` 来设定 `RHS` 类型参数的值而不是使用默认的 `Self`。\n\n默认参数类型主要用于如下两个方面：\n\n- 扩展类型而不破坏现有代码。\n- 在大部分用户都不需要的特定情况进行自定义。\n\n不能从外部读取类型，这不是动态语言，是静态语言\n\n\n\n#### 15-2-3、调用名字相同的方法\n\n```rust\ntrait Pilot {\n    fn fly(&self);\n}\n\ntrait Wizard {\n    fn fly(&self);\n}\n\nstruct Human;\n\nimpl Pilot for Human {\n    fn fly(&self) {\n        println!(\"This is your captain speaking.\");\n    }\n}\n\nimpl Wizard for Human {\n    fn fly(&self) {\n        println!(\"Up!\");\n    }\n}\n\nimpl Human {\n    fn fly(&self) {\n        println!(\"*waving arms furiously*\");\n    }\n}\n```\n\n当调用 `Human` 实例的 `fly` 时，编译器默认调用直接实现在类型上的方法，如示例 19-17 所示。\n\n```rust\nfn main() {\n    let person = Human;\n    person.fly();\n}\n```\n\n为了能够调用 `Pilot` trait 或 `Wizard` trait 的 `fly` 方法，我们需要使用更明显的语法以便能指定我们指的是哪个 `fly` 方法。这个语法展示在示例 19-18 中：\n\n```rust\nfn main() {\n    let person = Human;\n    Pilot::fly(&person);\n    Wizard::fly(&person);\n    person.fly();//也可以选择写成 Human::fly(&person)，这等同于示例 19-18 中的 person.fly()\n}\n```\n\n#### 15-2-4、完全限定语法\n\n关联函数是 trait 的一部分，但没有 `self` 参数。当同一作用域的两个类型实现了同一 trait，Rust 就不能计算出我们期望的是哪一个类型，除非使用 **完全限定语法**（*fully qualified syntax*）\n\n```rust\ntrait Animal {\n    fn baby_name() -> String;\n}\n\nstruct Dog;\n\nimpl Dog {\n    fn baby_name() -> String {\n        String::from(\"Spot\")\n    }\n}\n\nimpl Animal for Dog {\n    fn baby_name() -> String {\n        String::from(\"puppy\")\n    }\n}\n\nfn main() {\n    println!(\"A baby dog is called a {}\", Dog::baby_name());\n    println!(\"A baby dog is called a {}\", <Dog as Animal>::baby_name());\n}\n\n```\n\n`Animal` trait,它有关联函数 `baby_name`，结构体 `Dog` 实现了 `Animal`，同时有关联函数 `baby_name` 直接定义于 `Dog` 之上,如果要调用trait重新赋值在Dog上的方法，因为他不是实现对象，所以没有self\n\n通常，完全限定语法定义为：\n\n```rust\n<Type as Trait>::function(receiver_if_method, next_arg, ...);\n```\n\n#### 15-2-5、trait中实现另一个trait\n\n实质：在一个trait上添加另一个trait能使之默认实现,可以理解成继承，不过是添加在父trait上\n\n有时我们可能会需要某个 trait 使用另一个 trait 的功能。在这种情况下，需要能够依赖相关的 trait 也被实现。这个所需的 trait 是我们实现的 trait 的 **父（超） trait**（*supertrait*）。\n\n```rust\nuse std::fmt;\n\ntrait OutlinePrint: fmt::Display {\n    fn outline_print(&self) {\n        let output = self.to_string();\n        let len = output.len();\n        println!(\"{}\", \"*\".repeat(len + 4));\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"* {} *\", output);\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"{}\", \"*\".repeat(len + 4));\n    }\n}\n```\n\n因为指定了 `OutlinePrint` 需要 `Display` trait，则可以在 `outline_print` 中使用 `to_string`， 其会为任何实现 `Display` 的类型自动实现。如果我们尝试使用 `to_string` 而不添加冒号（`:`）并在 trait 名称后面指定 `Display` trait，则会得到一个错误说在当前作用域中没有找到用于 `&Self` 类型的方法 `to_string`。\n\n```rust\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl OutlinePrint for Point {}\nerror[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied\n  --> src/main.rs:20:6\n   |\n20 | impl OutlinePrint for Point {}\n   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter;\ntry using `:?` instead if you are using a format string\n   |\n   = help: the trait `std::fmt::Display` is not implemented for `Point`\n```\n\n\n\n```rust\nuse std::fmt;\n\nimpl fmt::Display for Point {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"({}, {})\", self.x, self.y)\n    }\n}\nfn main(){\n\tlet point = Point { x: 3, y: 4 };\n    point.outline_print();\n}\n//那么在 Point 上实现 OutlinePrint trait 将能成功编译，并可以在 Point 实例上调用 outline_print 来显示位于星号框中的点的值。\n```\n\n在 `Point` 上实现 `OutlinePrint` trait 将能成功编译，并可以在 `Point` 实例上调用 `outline_print` 来显示位于星号框中的点的值\n\n#### 15-2-6、newType\n\n*如何不用宏来实现打印\n\n孤儿规则（orphan rule），它说明只要 trait 或类型对于当前 crate 是本地的话就可以在此类型上实现该 trait。一个绕开这个限制的方法是使用 **newtype 模式**（*newtype pattern*）\n\n例如，如果想要在 `Vec<T>` 上实现 `Display`，而孤儿规则阻止我们直接这么做，因为 `Display` trait 和 `Vec<T>` 都定义于我们的 crate 之外。可以创建一个包含 `Vec<T>` 实例的 `Wrapper` 结构体，\n\n```rust\nuse std::fmt;\n//()元组 \nstruct Wrapper(Vec<String>);\n\nimpl fmt::Display for Wrapper {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"[{}]\", self.0.join(\", \"))\n    }\n}\n\nfn main() {\n    let w = Wrapper(vec![String::from(\"hello\"), String::from(\"world\")]);\n    println!(\"w = {}\", w);\n}\n```\n\n在 `Vec<T>` 上实现 `Display`，而孤儿规则阻止我们直接这么做，因为 `Display` trait 和 `Vec<T>` 都定义于我们的 crate 之外。可以创建一个包含 `Vec<T>` 实例的 `Wrapper` 结构体，接着可以如示例 19-31 那样在 `Wrapper` 上实现 `Display` 并使用 `Vec<T>` 的值：\n\n`Display` 的实现使用 `self.0` 来访问其内部的 `Vec<T>`，因为 `Wrapper` 是元组结构体而 `Vec<T>` 是结构体总位于索引 0 的项。接着就可以使用 `Wrapper` 中 `Display` 的功能了。\n\n### 15-3、高级类型\n\n#### 15-3-1、类型别名\n\nRust 还提供了声明 **类型别名**（*type alias*）的能力，使用 `type` 关键字来给予现有类型另一个名字\n\n```rust\n\ntype Kilometers = i32;\n\nlet x: i32 = 5;\nlet y: Kilometers = 5;\n\nprintln!(\"x + y = {}\", x + y);\n```\n\n\n\n类型别名的主要用途是减少重复。例如，可能会有这样很长的类型：\n\n```rust\n\ntype Thunk = Box<dyn Fn() + Send + 'static>;\n\nlet f: Thunk = Box::new(|| println!(\"hi\"));\n\nfn takes_long_type(f: Thunk) {\n    // --snip--\n}\n\nfn returns_long_type() -> Thunk {\n    // --snip--\n}\n```\n\n类型别名也经常与 `Result<T, E>` 结合使用来减少重复。考虑一下标准库中的 `std::io` 模块。\n\n```rust\n\ntype Result<T> = std::result::Result<T, std::io::Error>;\npub trait Write {\n    fn write(&mut self, buf: &[u8]) -> Result<usize>;\n    fn flush(&mut self) -> Result<()>;\n\n    fn write_all(&mut self, buf: &[u8]) -> Result<()>;\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;\n}\n```\n\n#### 15-3-2、never type\n\n1. 用于无返回值\n2. 用于修正match,用于panic!\n3. loop\n\nRust 有一个叫做 `!` 的特殊类型。在类型理论术语中，它被称为 *empty type*，因为它没有值。我们更倾向于称之为 *never type*。这个名字描述了它的作用：在函数从不返回的时候充当返回值。例如：\n\n```rust\nfn bar() -> ! {\n    // --snip--\n}\n```\n\nmatch\n\n忽略了代码中的一些细节,`match` 的分支必须返回相同的类型\n\n```rust\nlet guess: u32 = match guess.trim().parse() {\n    Ok(num) => num,\n    Err(_) => continue,\n};\n```\n\n他们需要同一个返回值，前者是 `u32` 值，而后者是 `!` 值。因为 `!` 并没有一个值，Rust 决定 `guess` 的类型是 `u32`。所以在 `Err` 的情况，事实上并未对 `guess` 赋值。\n\npanic\n\nnever type 的另一个用途是 `panic!`。还记得 `Option<T>` 上的 `unwrap` 函数吗？它产生一个值或 panic。这里是它的定义：\n\n```rust\nimpl<T> Option<T> {\n    pub fn unwrap(self) -> T {\n        match self {\n            Some(val) => val,\n            None => panic!(\"called `Option::unwrap()` on a `None` value\"),\n        }\n    }\n}\n```\n\nloop\n\n```rust\nprint!(\"forever \");\n\nloop {\n    print!(\"and ever \");\n}\n```\n\n#### 15-3-3、动态大小和size trait\n\n因为 Rust 需要知道例如应该为特定类型的值分配多少空间这样的信息其类型系统的一个特定的角落可能令人迷惑：这就是 **动态大小类型**（*dynamically sized types*）的概念。这有时被称为 “DST” 或 “unsized types”，这些类型允许我们处理只有在运行时才知道大小的类型。\n\n`str` 是一个 DST；直到运行时我们都不知道字符串有多长\n\nRust 需要知道应该为特定类型的值分配多少内存，同时所有同一类型的值必须使用相同数量的内存\n\n```rust\nlet s1: str = \"Hello there!\";\nlet s2: str = \"How's it going?\";\n//如果允许编写这样的代码，也就意味着这两个 str 需要占用完全相同大小的空间，不过它们有着不同的长度。这也就是为什么不可能创建一个存放动态大小类型的变量的原因。\ns1 和 s2 的类型是 &str 而不是 str所以就不会报错\n```\n\n所以虽然 `&T` 是一个储存了 `T` 所在的内存位置的单个值，`&str` 则是 **两个** 值：`str` 的地址和其长度。这样，`&str` 就有了一个在编译时可以知道的大小：它是 `usize` 长度的两倍。也就是说，我们总是知道 `&str` 的大小，\n\n动态大小类型的黄金规则：必须将动态大小类型的值置于某种指针之后。\n\n为了处理 DST，Rust 有一个特定的 trait 来确定一个类型的大小是否在编译时可知：这就是 `Sized` trait。这个 trait 自动为编译器在编译时就知道其大小的类型实现。另外，Rust 隐式的为每一个泛型函数增加了 `Sized` bound。也就是说，对于如下泛型函数定义：\n\n```rust\nfn generic<T>(t: T) {\n    // --snip--\n}\n```\n\n实际上被当作如下处理：\n\n```rust\nfn generic<T: Sized>(t: T) {\n    // --snip--\n}\n```\n\n以使用如下特殊语法来放宽这个限制：\n\n```rust\nfn generic<T: ?Sized>(t: &T) {\n    // --snip--\n}\n```\n\n### 15-4、高级函数和闭包\n\n#### 15-4-1、函数指针\n\n函数的类型是 `fn` （使用小写的 “f” ）以免与 `Fn` 闭包 trait 相混淆。`fn` 被称为 **函数指针**（*function pointer*）。指定参数为函数指针的语法类似于闭包\n\n```rust\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n\nfn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {\n    f(arg) + f(arg)\n}\n\nfn main() {\n    let answer = do_twice(add_one, 5);\n\n    println!(\"The answer is: {}\", answer);\n}\n```\n\n不同于闭包，`fn` 是一个类型而不是一个 trait，所以直接指定 `fn` 作为参数而不是声明一个带有 `Fn` 作为 trait bound 的泛型参数。\n\n可以使用内联定义的闭包又可以使用命名函数\n\n```rust\nlet list_of_numbers = vec![1, 2, 3];\nlet list_of_strings: Vec<String> = list_of_numbers\n    .iter()\n    .map(|i| i.to_string())//  .map(ToString::to_string)//\n    .collect();\n```\n\n元组结构体和元组结构体枚举成员的实现细节\n\n```rust\nenum Status {\n    Value(u32),\n    Stop,\n}\n\nlet list_of_statuses: Vec<Status> =\n    (0u32..20)\n    .map(Status::Value)\n    .collect();\n```\n\n#### 15-4-2、返回闭包\n\n```rust\nfn returns_closure() -> Fn(i32) -> i32 {\n    |x| x + 1\n}\n//报错\n不允许使用函数指针 fn 作为返回值类型。Rust 并不知道需要多少空间来储存闭包\n```\n\n我们可以使用trait对象\n\n```rust\nfn returns_closure() -> Box<dyn Fn(i32) -> i32> {\n    Box::new(|x| x + 1)\n}\n```\n\n### 15-5、宏\n\n从根本上来说，宏是一种为写其他代码而写代码的方式，即所谓的 **元编程**（*metaprogramming*）;\n\n宏可以在编译器翻译代码前展开，例如,宏可以在一个给定类型上实现 trait 。而函数则不行，因为函数是在运行时被调用，同时 trait 需要在编译时实现\n\n**宏**（*Macro*）指的是 Rust 中一系列的功能：使用 `macro_rules!` 的 **声明**（*Declarative*）宏，和三;种 **过程**（*Procedural*）宏：\n\n- 自定义 `#[derive]` 宏在结构体和枚举上指定通过 `derive` 属性添加的代码\n- 类属性（Attribute-like）宏定义可用于任意项的自定义属性\n- 类函数宏看起来像函数不过作用于作为参数传递的 token\n\n#### 15-5-1、macro_rules!的声明宏用于通用元编程\n\nRust 最常用的宏形式是 **声明宏**（*declarative macros*）。它们有时也被称为 “macros by example”、“`macro_rules!` 宏” 或者就是 “macros”。其核心概念是，声明宏允许我们编写一些类似 Rust `match` 表达式的代码;\n\n可以使用 macro_rules! 来定义宏。让我们通过查看 vec! 宏定义来探索如何使用 macro_rules! 结构。第 8 章讲述了如何使用 vec! 宏来生成一个给定值的 vector。例如，下面的宏用三个整数创建一个 vector：\n\n```rust\n\nlet v: Vec<u32> = vec![1, 2, 3];\n\n```\n\n无法使用函数做相同的事情，因为我们无法预先知道参数值的数量和类型\n\nvec!的简化定义\n\n```rust\n#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n```\n\n`#[macro_export]` 标注说明，只要将定义了宏的 crate 引入作用域，宏就应当是可用的。如果没有该标注，这个宏就不能被引入作用域。\n\n接着使用 `macro_rules!` 和宏名称开始宏定义，且所定义的宏并 **不带** 感叹号。名字后跟大括号表示宏定义体，在该例中宏名称是 `vec` 。\n\n`vec!` 宏的结构和 `match` 表达式的结构类似。此处有一个单边模式 `( $( $x:expr ),* )` ，后跟 `=>` 以及和模式相关的代码块。如果模式匹配，该相关代码块将被执行。假设这是这个宏中唯一的模式，则只有这一种有效匹配，其他任何匹配都是错误的。更复杂的宏会有多个单边模式。\n\n首先，一对括号包含了整个模式。接下来是美元符号（ `$` ），后跟一对括号，捕获了符合括号内模式的值以用于替换后的代码。`$()` 内则是 `$x:expr` ，其匹配 Rust 的任意表达式，并将该表达式记作 `$x`。\n\n`$()` 之后的逗号说明一个可有可无的逗号分隔符可以出现在 `$()` 所匹配的代码之后。紧随逗号之后的 `*` 说明该模式匹配零个或更多个 `*` 之前的任何模式。\n\n当以 `vec![1, 2, 3];` 调用宏时，`$x` 模式与三个表达式 `1`、`2` 和 `3` 进行了三次匹配。\n\n调用该宏时，替换该宏调用所生成的代码会是下面这样：\n\n```rust\nlet mut temp_vec = Vec::new();\ntemp_vec.push(1);\ntemp_vec.push(2);\ntemp_vec.push(3);\ntemp_vec\n```\n\n#### 15-5-2、从属性生产过程宏\n\n第二种形式的宏被称为 **过程宏**（*procedural macros*），因为它们更像函数（一种过程类型）。过程宏接收 Rust 代码作为输入，在这些代码上进行操作，然后产生另一些代码作为输出，而非像声明式宏那样匹配对应模式然后以另一部分代码替换当前代码。\n\n有三种类型的过程宏（自定义派生（derive），类属性和类函数），不过它们的工作方式都类似。\n\n创建过程宏时，其定义必须驻留在它们自己的具有特殊 crate 类型的 crate 中。这么做出于复杂的技术原因，将来我们希望能够消除这些限制。使用这些宏需采用类似示例 19-29 所示的代码形式，其中 `some_attribute` 是一个使用特定宏的占位符。\n\n```rust\nuse proc_macro;\n\n#[some_attribute]\npub fn some_name(input: TokenStream) -> TokenStream {\n}\n```\n\n定义过程宏的函数以一个 `TokenStream` 作为输入并产生一个 `TokenStream` 作为输出。该 `TokenStream` 类型由包含在 Rust 中的 `proc_macro` crate 定义，并表示令牌序列。这是宏的核心：宏操作的源代码构成了输入 `TokenStream`，宏产生的代码是输出 `TokenStream`。该函数还附加了一个属性，该属性指定我们正在创建过程宏的类型。我们可以在同一个 crate 中拥有多种过程宏。\n\n#### 15-5-3、编写自定义derive宏\n\n```rust\nuse hello_macro::HelloMacro;\nuse hello_macro_derive::HelloMacro;\n\n#[derive(HelloMacro)]\nstruct Pancakes;\n\nfn main() {\n    Pancakes::hello_macro();\n}\n```\n\n运行该代码将会打印 `Hello, Macro! My name is Pancakes!` 第一步是像下面这样新建一个库 crate：\n\n```rust\ncargo new hello_macro --lib\n```\n\n文件名: src/lib.rs\n\n```rust\n\npub trait HelloMacro {\n    fn hello_macro();\n}\n```\n\n下一步是定义过程式宏。在编写本部分时，过程式宏必须在其自己的 crate 内。该限制最终可能被取消。构造 crate 和其中宏的惯例如下：对于一个 `foo` 的包来说，一个自定义的派生过程宏的包被称为 `foo_derive` 。在 `hello_macro` 项目中新建名为 `hello_macro_derive` 的包。\n\n```rust\ncargo new hello_macro_derive --lib\n```\n\n由于两个 crate 紧密相关，因此在 `hello_macro` 包的目录下创建过程式宏的 crate。如果改变在 `hello_macro` 中定义的 trait ，同时也必须改变在 `hello_macro_derive` 中实现的过程式宏。这两个包需要分别发布，编程人员如果使用这些包，则需要同时添加这两个依赖并将其引入作用域。我们也可以只用 `hello_macro` 包而将 `hello_macro_derive` 作为一个依赖，并重新导出过程式宏的代码。但现在我们组织项目的方式使编程人员在无需 `derive` 功能时也能够单独使用 `hello_macro`。\n\n我们需要声明 `hello_macro_derive` crate 是过程宏(proc-macro) crate。正如稍后将看到的那样，我们还需要 `syn` 和 `quote` crate 中的功能，所以需要将其加到依赖中。将下面的代码加入到 `hello_macro_derive` 的 *Cargo.toml* 文件中。\n\n```rust\n[lib]\nproc-macro = true\n\n[dependencies]\nsyn = \"1.0\"\nquote = \"1.0\"\n```\n\n```rust\n hello_macro_derive/src/lib.rs\nextern crate proc_macro;\n\nuse crate::proc_macro::TokenStream;\nuse quote::quote;\nuse syn;\n\n#[proc_macro_derive(HelloMacro)]\npub fn hello_macro_derive(input: TokenStream) -> TokenStream {\n    // 将 Rust 代码解析为语法树以便进行操作\n    let ast = syn::parse(input).unwrap();\n\n    // 构建 trait 实现\n    impl_hello_macro(&ast)\n}\n```\n\n现在，我们已经引入了三个新的 crate：`proc_macro` 、 [`syn`](https://crates.io/crates/syn) 和 [`quote`](https://crates.io/crates/quote) 。Rust 自带 `proc_macro` crate，因此无需将其加到 *Cargo.toml* 文件的依赖中。`proc_macro` crate 是编译器用来读取和操作我们 Rust 代码的 API。\n\n`syn` crate 将字符串中的 Rust 代码解析成为一个可以操作的数据结构。`quote` 则将 `syn` 解析的数据结构转换回 Rust 代码。这些 crate 让解析任何我们所要处理的 Rust 代码变得更简单：为 Rust 编写整个的解析器并不是一件简单的工作。\n\n当用户在一个类型上指定 `#[derive(HelloMacro)]` 时，`hello_macro_derive` 函数将会被调用。原因在于我们已经使用 `proc_macro_derive` 及其指定名称对 `hello_macro_derive` 函数进行了标注：`HelloMacro`，其匹配到 trait 名，这是大多数过程宏遵循的习惯。\n\n`TokenStream` 的 `input` 转换为一个我们可以解释和操作的数据结构。这正是 `syn` 派上用场的地方。`syn` 中的 `parse_derive_input` 函数获取一个 `TokenStream` 并返回一个表示解析出 Rust 代码的 `DeriveInput` 结构体。示例 19-32 展示了从字符串 `struct Pancakes;` 中解析出来的 `DeriveInput` 结构体的相关部分：\n\n```rust\nDeriveInput {\n    // --snip--\n\n    ident: Ident {\n        ident: \"Pancakes\",\n        span: #0 bytes(95..103)\n    },\n    data: Struct(\n        DataStruct {\n            struct_token: Struct,\n            fields: Unit,\n            semi_token: Some(\n                Semi\n            )\n        }\n    )\n}\n```\n\n该结构体的字段展示了我们解析的 Rust 代码是一个类单元结构体，其 `ident`（ identifier，表示名字）为 `Pancakes`。\n\n此时，尚未定义 `impl_hello_macro` 函数，其用于构建所要包含在内的 Rust 新代码。但在此之前，注意其输出也是 `TokenStream`。所返回的 `TokenStream` 会被加到我们的 crate 用户所写的代码中，因此，当用户编译他们的 crate 时，他们会获取到我们所提供的额外功能。\n\n当调用 `syn::parse` 函数失败时，我们用 `unwrap` 来使 `hello_macro_derive` 函数 panic。在错误时 panic 对过程宏来说是必须的，因为 `proc_macro_derive` 函数必须返回 `TokenStream` 而不是 `Result`，以此来符合过程宏的 API。这里选择用 `unwrap` 来简化了这个例子；在生产代码中，则应该通过 `panic!` 或 `expect` 来提供关于发生何种错误的更加明确的错误信息。\n\n现在我们有了将标注的 Rust 代码从 `TokenStream` 转换为 `DeriveInput` 实例的代码，让我们来创建在注明类型上实现 `HelloMacro` trait 的代码，如示例 19-33 所示。\n\n```rust\n hello_macro_derive/src/lib.rs\nfn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {\n    let name = &ast.ident;\n    let gen = quote! {\n        impl HelloMacro for #name {\n            fn hello_macro() {\n                println!(\"Hello, Macro! My name is {}\", stringify!(#name));\n            }\n        }\n    };\n    gen.into()\n}\n```\n\n我们得到一个包含以 `ast.ident` 作为注明类型名字（标识符）的 `Ident` 结构体实例\n\n`quote!` 宏让我们可以编写希望返回的 Rust 代码。`quote!` 宏执行的直接结果并不是编译器所期望的并需要转换为 `TokenStream`。为此需要调用 `into` 方法，它会消费这个中间表示（intermediate representation，IR）并返回所需的 `TokenStream` 类型值。\n\n这个宏也提供了一些非常酷的模板机制；我们可以写 `#name` ，然后 `quote!` 会以名为 `name` 的变量值来替换它。你甚至可以做一些类似常用宏那样的重复代码的工作。查阅 [`quote` crate 的文档](https://docs.rs/quote) 来获取详尽的介绍。\n\n我们期望我们的过程式宏能够为通过 `#name` 获取到的用户注明类型生成 `HelloMacro` trait 的实现。该 trait 的实现有一个函数 `hello_macro` ，其函数体包括了我们期望提供的功能：打印 `Hello, Macro! My name is` 和标注的类型名。\n\n添加依赖\n\n```rust\n\n[dependencies]\nhello_macro = { path = \"../hello_macro\" }\nhello_macro_derive = { path = \"../hello_macro/hello_macro_derive\" }\n```\n\n#### 15-5-4、类属性宏\n\n类属性宏与自定义派生宏相似，不同于为 `derive` 属性生成代码，它们允许你创建新的属性。它们也更为灵活；`derive` 只能用于结构体和枚举；属性还可以用于其它的项，比如函数。作为一个使用类属性宏的例子，可以创建一个名为 `route` 的属性用于标注 web 应用程序框架（web application framework）的函数：\n\n```rust\n#[route(GET, \"/\")]\nfn index() {\n```\n\n`#[route]` 属性将由框架本身定义为一个过程宏。其宏定义的函数签名看起来像这样：\n\n```rust\n#[proc_macro_attribute]\npub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {\n```\n\n这里有两个 `TokenStream` 类型的参数；第一个用于属性内容本身，也就是 `GET, \"/\"` 部分。第二个是属性所标记的项：在本例中，是 `fn index() {}` 和剩下的函数体。\n\n除此之外，类属性宏与自定义派生宏工作方式一致：创建 `proc-macro` crate 类型的 crate 并实现希望生成代码的函数！\n\n#### 15-5-6、类函数宏\n\n类函数宏定义看起来像函数调用的宏。类似于 `macro_rules!`，它们比函数更灵活；例如，可以接受未知数量的参数。然而 `macro_rules!` 宏只能使用之前 [“使用 `macro_rules!` 的声明宏用于通用元编程”](https://rustwiki.org/zh-CN/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming) 介绍的类匹配的语法定义。类函数宏获取 `TokenStream` 参数，其定义使用 Rust 代码操纵 `TokenStream`，就像另两种过程宏一样。一个类函数宏例子是可以像这样被调用的 `sql!` 宏：\n\n```rust\nlet sql = sql!(SELECT * FROM posts WHERE id=1);\n```\n\n这个宏会解析其中的 SQL 语句并检查其是否是句法正确的，这是比 `macro_rules!` 可以做到的更为复杂的处理。`sql!` 宏应该被定义为如此：\n\n```rust\n#[proc_macro]\npub fn sql(input: TokenStream) -> TokenStream {\n```\n\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/rust/rust程序设计.md"}},{"pageContent":"### 1、mySQL基础\n\nmysql -h主机名  -u用户名 -**p**密码\n\n```js\nmysql --host=localhost --user=root --password=123456\nmysql -hlocalhost -uroot -p123456\nmysql -hlocalhost -uroot -p 推荐使用，不会报错，加密输入\n```\n\n```html\n退出语句\nquit\nexit\n\\q\n```\n\n你可以通过设置环境变量`USER`来添加一个默认用户名。\n\n| 参数名 |                             含义                             |\n| :----: | :----------------------------------------------------------: |\n|  `-h`  | 表示启动服务器程序的计算机的域名或者IP地址，如果服务器程序就运行在本机的话，可以省略这个参数，也可以填`localhost`或者`127.0.0.1`。也可以写作 `--host=主机`的形式。 |\n|  `-u`  | 表示用户名，我们刚刚安装完，作为超级管理员的我们的用户名是`root`。也可以写作 `--user=用户名`的形式。 |\n|   -p   |        表示密码。也可以写作 `--password=密码`的形式。        |\n\n书写注意点\n\n|        注意点        |                             含义                             |\n| :------------------: | :----------------------------------------------------------: |\n|     命令结束符号     | 在书写完一个命令之后需要以下边这几个符号之一结尾：1、； 2、\\g 3、\\G      *<br>*；和/g返回结果一致 \\G返回结果是行，更适合大量数据查看 |\n|   命令可以随意换行   | 按回车键的时候输入的语句里没有`;`、`\\g`或者`\\G`这些语句结束符号，该语句就算是没结束 |\n| 可以一次提交多个命令 |    **SELECT** NOW(); **SELECT** NOW(); **SELECT** NOW();     |\n| 使用`\\c`放弃本次操作 |                    mysql\\> SELECT NOW()\\c                    |\n|      大小写问题      | `MySQL`默认对命令的大小写并没有限制，也就是说我们这样查询当前时间也是可以的 \\*<br>\\*命令函数类一般大写，比如数据库名，表名、列名啥的都是要小写的 |\n|     字符串的表示     |                          使用''包裹                          |\n\n### 2、数据库基本操作\n\n|      操作      |                             语法                             |\n| :------------: | :----------------------------------------------------------: |\n| 启动选中数据库 |          mysql -h 主机名 -u 用户名 -p密码 数据库名           |\n|   创建数据库   |                CREATE DATABASE 数据库名\\*;\\*                 |\n|   查看数据库   |                      **SHOW** DATABASES                      |\n| 切换当前数据库 |                     USE 数据库名称\\*;\\*                      |\n|   删除数据库   | DROP DATABASE 数据库名\\*;<br>**DROP** DATABASE IF **EXISTS** 数据库名;\\* |\n\n### 3、表的基本操作\n\n|            操作            |                             语法                             |\n| :------------------------: | :----------------------------------------------------------: |\n|    展示当前数据库中的表    |                       SHOW TABLES\\*;\\*                       |\n|         创建表语法         | CREATE **TABLE** 表名（列名    数据类型    \\[列的属性]）COMMENT \"注释信息\"<br>**CREATE** **TABLE** IF **NOT** **EXISTS** 表名(    各个列的信息 ... ); |\n|           删除表           | **DROP** **TABLE** 表1, 表2, ..., 表n;<br>**DROP** **TABLE** IF **EXISTS** 表名; |\n|         查看表结构         | **DESCRIBE** 表名;**DESC** 表名;EXPLAIN 表名;**SHOW** COLUMNS **FROM** 表名;**SHOW** FIELDS **FROM** 表名;<br>**SHOW** **CREATE** **TABLE** 表名;不用表格形式<br>查看其它数据库结构 SHOW TABLES FROM 数据库名.表名 |\n|          修改表名          | ALTER **TABLE** 旧表名 RENAME **TO** 新表名;<br>RENAME **TABLE** 旧表名1 **TO** 新表名1, 旧表名2 **TO** 新表名2, ... 旧表名n **TO** 新表名n;<br>可以在不同的数据库中迁移RENAME **TABLE** 数据库.表 **TO**  数据库表; |\n|           增加列           | **ALTER** **TABLE** 表名 **ADD** **COLUMN** 列名 数据类型 \\[列的属性],**ADD** **COLUMN** 列名 数据类型 \\[列的属性]; |\n|      增加列到特定位置      | **ALTER** **TABLE** 表名 **ADD** **COLUMN** 列名 列的类型 \\[列的属性] **FIRST**;<br>**ALTER** **TABLE** 表名 **ADD** **COLUMN** 列名 列的类型 \\[列的属性] AFTER 指定列名; |\n|           删除列           |      **ALTER** **TABLE** 表名 **DROP** **COLUMN** 列名;      |\n|         修改列信息         | ALTER **TABLE** 表名 MODIFY 列名 新数据类型 \\[新属性];<br>ALTER **TABLE** 表名 CHANGE 旧列名 新列名 新数据类型 \\[新属性];<br>后面增加FIRST或者AFTER语句，可以实现位置的改变 |\n| 一条语句中包含多个修改操作 | **ALTER** **TABLE** 表名 操作1, 操作2, ..., 操作n;<br>逗号隔开可以实现多个操作 |\n\n### 4、列\n\n候选键：通过某个列或者某些列确定唯一的一条记录，我们就可以把这个列或者这些列称为`候选键`\n\n主键：选择一个候选键作为表的`主键`，一个表最多只能有一个主键，主键的值不能重复，通过主键可以找到唯一的一条记录。如果我们的表中有定义主键的需求可以选用下边这两种方式之一来指定主键\n\n注：主键是唯一识别，如果有唯一属性可以选择它当主键，如果没有，可以让多个候选键组合成为主键\n\n我们向一个包含唯一性约束的列插入或更新数据时，如果已存在相同的键值，MySQL 会抛出1062错误。\n\n主键列默认是有`NOT NULL`属性\n\n#### UNIQUE 和 PRIMARY KEY 的区别\n\n*   UNIQUE（唯一约束）和 PRIMARY KEY（主键）非常相似，但是 UNIQUE 允许字段中出现一次 NULL 值，而 PRIMARY KEY 不允许出现 NULL 值，因为可以认为：\n\n    PRIMARY KEY = UNIQUE + NOT NULL\n\n*   一张表可以包含多个 UNIQUE 字段，但是只能有一个主键。\n\n*   一个表中最多有一个具有AUTO\\_INCREMENT属性的列。\n\nAUTO\\_INCREMENT递增\n\n*   具有AUTO\\_INCREMENT属性的列必须建立索引。主键和具有`UNIQUE`属性的列会自动建立索引。不过至于什么是索引，在学习MySQL进阶的时候才会介绍。\n*   拥有AUTO\\_INCREMENT属性的列就不能再通过指定DEFAULT属性来指定默认值。\n*   一般拥有AUTO\\_INCREMENT属性的列都是作为主键的属性，来自动生成唯一标识一条记录的主键值。\n\n|            操作            |                             语法                             |\n| :------------------------: | :----------------------------------------------------------: |\n|       简单的查询语句       |                 **SELECT** \\* **FROM** 表名;                 |\n|        简单插入语句        | INSERT INTO 表名(列1, 列2, ...) VALUES(列1的值，列2的值, ...), (列1的值，列2的值, ...); |\n|           默认值           |            添加表或者新建表后面加 DEFAULT 默认值             |\n|        NOT NULL属性        |                    列名 列的类型 NOT NULL                    |\n|     设置主键（建表时）     | **列名 列的类型 PRIMARY** KEY<br>创建表的时候，可以在最后一行写入PRIMARY KEY(候选键1，候选键2)来对主键进行设置 |\n|     设置主键（建表后）     |         ALTER TABLE 表名 ADD PRIMARY KEY （字段名);          |\n|     UNIQUE属性(建表时)     | 不是主键，表明该列或者列组合的值是不允许重复的。<br> 字段 类型 **UNIQUE**,<br>UNIQUE KEY \\[约束名称] (列名1, 列名2, ...)最后一位 key可以省略 设置多个 |\n| UNIQUE属性(建website 表后) | **ALTER** **TABLE** 表名 **MODIFY** 字段名 类型   **NOT** **NULL** **UNIQUE**;<br>  **ALTER** **TABLE** 表明**ADD** CONSTRAINT 约束的名字**UNIQUE**(alexa, url); |\n|          设置外键          | CONSTRAINT \\[外键名称] FOREIGN KEY(列1, 列2, ...) REFERENCES 父表名(父列1, 父列2, ...); |\n|    AUTO\\_INCREMENT属性     |                列名 列的类型 AUTO\\_INCREMENT                 |\n|          列的注释          |      建表语句的末尾可以添加`COMMENT`语句来给表添加注释       |\n|           补充0            |        给该列加一个`ZEROFILL`属性，长度不足部分会补0         |\n\n### 5、简单查询\n\n|          操作          |                             语法                             |\n| :--------------------: | :----------------------------------------------------------: |\n|       查询单个列       |                **SELECT** 列名 **FROM** 表名;                |\n| 列的别名（仅当次查询） |      **SELECT** 列名 \\[**AS**] 列的别名 **FROM** 表名;       |\n|       查询多个列       |      **SELECT** 列名1, 列名2, ... 列名n **FROM** 表名;       |\n|       查询所有列       |                 **SELECT** \\* **FROM** 表名;                 |\n|   去除单列的重复结果   |         **SELECT** **DISTINCT** 列名 **FROM** 表名;          |\n|   去除多列的重复结果   | **SELECT** **DISTINCT** 列名1, 列名2, ... 列名n  **FROM** 表名; |\n\n### 6、带搜索条件的查询\n\n##### 比较操作符\n\n| 操作符        | 示例                    | 描述               |\n| ------------- | ----------------------- | ------------------ |\n| `=`           | `a = b`                 | a等于b             |\n| `<>`或者`!=`  | `a <> b`                | a不等于b           |\n| `<`           | `a < b`                 | a小于b             |\n| `<=`          | `a <= b`                | a小于或等于b       |\n| `>`           | `a > b`                 | a大于b             |\n| `>=`          | `a >= b`                | a大于或等于b       |\n| `BETWEEN`     | `a BETWEEN b AND c`     | 满足 b <= a <= c   |\n| `NOT BETWEEN` | `a NOT BETWEEN b AND c` | 不满足 b <= a <= c |\n\n##### SQL WHERE 语法\n\n     SELECT column_name,column_name\n     FROM table_name\n     WHERE column_name operator value;\n\n##### `IN`操作符\n\n| 操作符   | 示例                     | 描述                          |\n| -------- | ------------------------ | ----------------------------- |\n| `IN`     | `a IN (b1, b2, ...)`     | a是b1, b2, ... 中的某一个     |\n| `NOT IN` | `a NOT IN (b1, b2, ...)` | a不是b1, b2, ... 中的任意一个 |\n\n##### 匹配`NULL`值\n\n不能直接使用普通的操作符来与`NULL`值进行比较，必须使用`IS NULL`或者`IS NOT NULL`\n\n| 操作符        | 示例            | 描述            |\n| ------------- | --------------- | --------------- |\n| `IS NULL`     | `a IS NULL`     | a的值是`NULL`   |\n| `IS NOT NULL` | `a IS NOT NULL` | a的值不是`NULL` |\n\n##### AND操作符\n\n在给定多个搜索条件的时候，我们有时需要某条记录只在符合所有搜索条件的时候才将其加入结果集，这种情况我们可以使用`AND`操作符来连接多个搜索条件。\n\n##### OR操作符\n\n在给定多个搜索条件的时候，我们有时需要某条记录在符合某一个搜索条件的时候就将其加入结果集中，这种情况我们可以使用`OR`操作符来连接多个搜索条件。\n\n多个操作符进行联合查询时，遵循操作符权重规范\n\n##### 通配符\n\n| 操作符     | 示例           | 描述     |\n| ---------- | -------------- | -------- |\n| `LIKE`     | `a LIKE b`     | a匹配b   |\n| `NOT LIKE` | `a NOT LIKE b` | a不匹配b |\n\n通配符模板\n\n1.  `%`：代表任意一个字符串 复。\n2.  `_`：代表任意一个字符 单。\n\n转义\n\n*   `'\\%'`代表普通字符`'%'`\n*   `'\\_'`代表普通字符`'_'` 比方说这样：\n\n### 7 表达式\n\n`MySQL`中`操作数`可以是下边这几种类型：\n\n1.  常数\n\n    常数很好理解，我们平时用到的数字、字符串、时间值什么的都可以被称为常数，它是一个确定的值，比如数字`1`，字符串`'abc'`，时间值`2019-08-16 17:10:43`啥的。\n\n2.  列名\n\n    针对某个具体的表，它的列名可以被当作表达式的一部分，比如对于`student_info`表来说，`number`、`name`都可以作为`操作数`。\n\n3.  函数调用\n\n    `MySQL`中有`函数`的概念，比方说获取当前时间的函数`NOW`，而在函数后边加个小括号就算是一个`函数调用`，比如`NOW()`。\n\n4.  标量子查询或者行子查询\n\n5.  其他表达式\n\n    一个表达式也可以作为一个操作数与另一个操作数来形成一个更复杂的表达式，比方说（假设`col`是一个列名）：\n\n    *   (col - 5) / 3\n    *   (1 + 1) \\* 2 + col \\* 3\n\n##### 算术操作符\n\n| 操作符 | 示例      | 描述                 |\n| ------ | --------- | -------------------- |\n| `+`    | `a + b`   | 加法                 |\n| `-`    | `a - b`   | 减法                 |\n| `*`    | `a * b`   | 乘法                 |\n| `/`    | `a / b`   | 除法                 |\n| `DIV`  | `a DIV b` | 除法，取商的整数部分 |\n| `%`    | `a % b`   | 取余                 |\n| `-`    | `-a`      | 负号                 |\n\n##### 比较操作符\n\n| 操作符        | 示例                     | 描述                          |\n| ------------- | ------------------------ | ----------------------------- |\n| `=`           | `a = b`                  | a等于b                        |\n| `<>`或者`!=`  | `a <> b`                 | a不等于b                      |\n| `<`           | `a < b`                  | a小于b                        |\n| `<=`          | `a <= b`                 | a小于或等于b                  |\n| `>`           | `a > b`                  | a大于b                        |\n| `>=`          | `a >= b`                 | a大于或等于b                  |\n| `BETWEEN`     | `a BETWEEN b AND c`      | 满足 b <= a <= c              |\n| `NOT BETWEEN` | `a NOT BETWEEN b AND c`  | 不满足 b <= a <= c            |\n| `IN`          | `a IN (b1, b2, ...)`     | a是b1, b2, ... 中的某一个     |\n| `NOT IN`      | `a NOT IN (b1, b2, ...)` | a不是b1, b2, ... 中的任意一个 |\n| `IS NULL`     | `a IS NULL`              | a的值是`NULL`                 |\n| `IS NOT NULL` | `a IS NOT NULL`          | a的值不是`NULL`               |\n| `LIKE`        | `a LIKE b`               | a匹配b                        |\n| `NOT LIKE`    | `a NOT LIKE b`           | a不匹配b                      |\n\n##### 逻辑操作符\n\n逻辑操作符是用来将多个`布尔表达式`连接起来，我们需要了解这几个`逻辑操作符`：\n\n| 操作符 | 示例      | 描述                                 |\n| ------ | --------- | ------------------------------------ |\n| `AND`  | `a AND b` | 只有a和b同时为真，表达式才为真       |\n| `OR`   | `a OR b`  | 只要a或b有任意一个为真，表达式就为真 |\n| `XOR`  | `a XOR b` | a和b有且只有一个为真，表达式为真     |\n\n### 8函数\n\n##### 文本处理函数\n\n| 名称        | 调用示例                      | 示例结果    | 描述                                   |\n| ----------- | ----------------------------- | ----------- | -------------------------------------- |\n| `LEFT`      | `LEFT('abc123', 3)`           | `abc`       | 给定字符串从左边取指定长度的子串       |\n| `RIGHT`     | `RIGHT('abc123', 3)`          | `123`       | 给定字符串从右边取指定长度的子串       |\n| `LENGTH`    | `LENGTH('abc')`               | `3`         | 给定字符串的长度                       |\n| `LOWER`     | `LOWER('ABC')`                | `abc`       | 给定字符串的小写格式                   |\n| `UPPER`     | `UPPER('abc')`                | `ABC`       | 给定字符串的大写格式                   |\n| `LTRIM`     | `LTRIM(' abc')`               | `abc`       | 给定字符串左边空格去除后的格式         |\n| `RTRIM`     | `RTRIM('abc ')`               | `abc`       | 给定字符串右边空格去除后的格式         |\n| `SUBSTRING` | `SUBSTRING('abc123', 2, 3)`   | `bc1`       | 给定字符串从指定位置截取指定长度的子串 |\n| `CONCAT`    | `CONCAT('abc', '123', 'xyz')` | `abc123xyz` | 将给定的各个字符串拼接成一个新字符串   |\n\n##### 日期和时间处理函数\n\n| 名称          | 调用示例                                          | 示例结果              | 描述                                                         |\n| ------------- | ------------------------------------------------- | --------------------- | ------------------------------------------------------------ |\n| `NOW`         | `NOW()`                                           | `2019-08-16 17:10:43` | 返回当前日期和时间                                           |\n| `CURDATE`     | `CURDATE()`                                       | `2019-08-16`          | 返回当前日期                                                 |\n| `CURTIME`     | `CURTIME()`                                       | `17:10:43`            | 返回当前时间                                                 |\n| `DATE`        | `DATE('2019-08-16 17:10:43')`                     | `2019-08-16`          | 将给定日期和时间值的日期提取出来                             |\n| `DATE_ADD`    | `DATE_ADD('2019-08-16 17:10:43', INTERVAL 2 DAY)` | `2019-08-18 17:10:43` | 将给定的日期和时间值添加指定的时间间隔                       |\n| `DATE_SUB`    | `DATE_SUB('2019-08-16 17:10:43', INTERVAL 2 DAY)` | `2019-08-14 17:10:43` | 将给定的日期和时间值减去指定的时间间隔                       |\n| `DATEDIFF`    | `DATEDIFF('2019-08-16', '2019-08-17');`           | `-1`                  | 返回两个日期之间的天数（负数代表前一个参数代表的日期比较小） |\n| `DATE_FORMAT` | `DATE_FORMAT(NOW(),'%m-%d-%Y')`                   | `08-16-2019`          | 用给定的格式显示日期和时间                                   |\n\n##### 时间单位：\n\n| 时间单位      | 描述 |\n| ------------- | ---- |\n| `MICROSECOND` | 毫秒 |\n| `SECOND`      | 秒   |\n| `MINUTE`      | 分钟 |\n| `HOUR`        | 小时 |\n| `DAY`         | 天   |\n| `WEEK`        | 星期 |\n| `MONTH`       | 月   |\n| `QUARTER`     | 季度 |\n| `YEAR`        | 年   |\n\n##### DATE\\_FORMAT**格式符**\n\n| 格式符 | 描述                                                    |\n| ------ | ------------------------------------------------------- |\n| `%b`   | 简写的月份名称（Jan、Feb、...、Dec)                     |\n| `%D`   | 带有英文后缀的月份中的日期（0th、1st、2nd、...、31st)） |\n| `%d`   | 数字格式的月份中的日期(00、01、02、...、31)             |\n| `%f`   | 微秒（000000-999999）                                   |\n| `%H`   | 二十四小时制的小时 (00-23)                              |\n| `%h`   | 十二小时制的小时 (01-12)                                |\n| `%i`   | 数值格式的分钟(00-59)                                   |\n| `%M`   | 月份名（January、February、...、December）              |\n| `%m`   | 数值形式的月份(00-12)                                   |\n| `%p`   | 上午或下午（AM代表上午、PM代表下午）                    |\n| `%S`   | 秒(00-59)                                               |\n| `%s`   | 秒(00-59)                                               |\n| `%W`   | 星期名（Sunday、Monday、...、Saturday）                 |\n| `%w`   | 周内第几天 （0=星期日、1=星期一、 6=星期六）            |\n| `%Y`   | 4位数字形式的年（例如2019）                             |\n| `%y`   | 2位数字形式的年（例如19）                               |\n\n### 数值处理函数\n\n| 名称   | 调用示例      | 示例结果             | 描述               |\n| ------ | ------------- | -------------------- | ------------------ |\n| `ABS`  | `ABS(-1)`     | `1`                  | 取绝对值           |\n| `Pi`   | `PI()`        | `3.141593`           | 返回圆周率         |\n| `COS`  | `COS(PI())`   | `-1`                 | 返回一个角度的余弦 |\n| `EXP`  | `EXP(1)`      | `2.718281828459045`  | 返回e的指定次方    |\n| `MOD`  | `MOD(5,2)`    | `1`                  | 返回除法的余数     |\n| `RAND` | `RAND()`      | `0.7537623539136372` | 返回一个随机数     |\n| `SIN`  | `SIN(PI()/2)` | `1`                  | 返回一个角度的正弦 |\n| `SQRT` | `SQRT(9)`     | `3`                  | 返回一个数的平方根 |\n| `TAN`  | `TAN(0)`      | `0`                  | 返回一个角度的正切 |\n\n##### 聚集函数\n\n| 函数名  | 描述             |\n| ------- | ---------------- |\n| `COUNT` | 返回某列的行数   |\n| `MAX`   | 返回某列的最大值 |\n| `MIN`   | 返回某列的最小值 |\n| `SUM`   | 返回某列值之和   |\n| `AVG`   | 返回某列的平均值 |\n\n`COUNT`函数使用来统计行数的，它有下边两种使用方式：\n\n1.  `COUNT(*)`：对表中行的数目进行计数，不管列的值是不是`NULL`。\n2.  `COUNT(列名)`：对特定的列进行计数，会忽略掉该列为`NULL`的行。\n\n##### 支持隐式类型转换\n\n### 9、查询\n\n`GROUP BY`分组字句\n\n```sq\nmysql> SELECT subject, AVG(score) FROM student_score GROUP BY subject;\n```\n\n`HAVING`条件子句\n\n语句中可以书写条件表达式\n\n`ORDER BY 条件 排序方式\t `\n\n### 10、使用分组注意事项\n\n使用分组来统计数据给我们带来了非常大的便利，但是要随时提防有坑的地方：\n\n1.  如果分组列中含有`NULL`值，那么`NULL`也会作为一个独立的分组存在。\n\n2.  如果存在多个分组列，也就是`嵌套分组`，聚集函数将作用在最后的那个分组列上。\n\n3.  如果查询语句中存在`WHERE`子句和`ORDER BY`子句，那么`GROUP BY`子句必须出现在`WHERE`子句之后，`ORDER BY`子句之前。\n\n4.  `非分组列`不能单独出现在检索列表中(可以被放到聚集函数中)。\n\n5.  `GROUP BY`子句后也可以跟随`表达式`(但不能是聚集函数)。\n\n    上边介绍的`GROUP BY`后跟随的都是表中的某个列或者某些列，其实一个表达式也可以，比如这样：\n\n    ```sql\n    sql复制代码mysql> SELECT concat('专业：', major), COUNT(*) FROM student_info GROUP BY concat('专业：', major);\n    +-----------------------------------+----------+\n    | concat('专业：', major)           | COUNT(*) |\n    +-----------------------------------+----------+\n    | 专业：电子信息                    |        1 |\n    | 专业：计算机科学与工程            |        2 |\n    | 专业：软件工程                    |        2 |\n    | 专业：飞行器设计                  |        1 |\n    +-----------------------------------+----------+\n    4 rows in set (0.00 sec)\n\n    mysql>\n    ```\n\n    `MySQL`会根据这个表达式的值来对记录进行分组，使用表达式进行分组的时候需要特别注意，查询列表中的表达式和`GROUP BY`子句中的表达式必须完全一样。不过一般情况下我们也不会用表达式进行分组，所以目前基本没啥用～\n\n6.  `WHERE`子句和`HAVING`子句的区别。\n\n    `WHERE`子句在分组前进行过滤，作用于每一条记录，`WHERE`子句过滤掉的记录将不包括在分组中。而`HAVING`子句在数据分组后进行过滤，作用于整个分组。\n\n子句的顺序\n\n1.  **SELECT** \\[**DISTINCT**] 查询列表\n2.  \\[**FROM** 表名]\n3.  \\[**WHERE** 布尔表达式]\n4.  \\[**GROUP** **BY** 分组列表 ]\n5.  \\[HAVING 分组过滤条件]\n6.  \\[**ORDER** **BY** 排序列表]\n7.  \\[LIMIT 开始行, 限制条数]\n\n### 11、子查询\n\n|             个数             |                           查询语句                           |\n| :--------------------------: | :----------------------------------------------------------: |\n| `标量子查询`单纯的代表一个值 | **SELECT** \\* **FROM** 表 **WHERE** 列\\> (**SELECT** 列**FROM** 表2 **WHERE** 列=值);查询的单个值使用括号括起来 |\n|           列子查询           | **SELECT** \\* **FROM** 表 **WHERE** 列**IN** (**SELECT** number **FROM** 表2 WHERE\\*\\*  查询的多个值); |\n|           行子查询           |                多个列返回一个值 使用limit限制                |\n|           表子查询           |                           多行多列                           |\n|         检测是否存在         |                    EXISTS and NOT EXISTS                     |\n|          相关子查询          |                         值引用多个表                         |\n|      对同一个表的子查询      |          聚集函数（avg,min,max）不能放到WHERE子句中          |\n\n### 12、链接查询\n\n同时查询会链接两张表，生成笛卡尔积  num\\*num 的表，我们可以使用where限制范围，来减少查询结果，优化性能\n\n`ON子句` WHERE子句和ON子句是等价的。`ON`子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的\n\n**SELECT** \\* **FROM** t1 **LEFT** \\[**OUTER**] **JOIN** t2 **ON** 连接条件 \\[**WHERE** 普通过滤条件];\n\n内连接\n\n*   SELECT \\* FROM t1 JOIN t2;\n*   SELECT \\* FROM t1 INNER JOIN t2;\n*   SELECT \\* FROM t1 CROSS JOIN t2;\n*   内连接中 WHERE 和 ON 等价\n\n外连接\n\n**SELECT** \\* **FROM** t1 **LEFT** \\[**OUTER**] **JOIN** t2 **ON** 连接条件 \\[**WHERE** 普通过滤条件];\n\n**SELECT** \\* **FROM** t1 **RIGHT** \\[**OUTER**] **JOIN** t2 **ON** 连接条件 \\[**WHERE** 普通过滤条件];\n\n```js\nfor each row in t1 {\n\n    for each row in t2 which satisfies t1.m1 = t2.m2 {\n        \n        for each row in t3 which satisfies t1.m1 = t3.m3 {\n            send to client;\n        }\n    }\n}\n查询过程 \n```\n\n自连接\n\n可以使用AS别名 将一张表变为两张 再进行链接\n\n| 关键字                                                       |                                                              |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| SELECT *column\\_name(s)*<br/> FROM *table1*<br/>`INNER JOIN`*table2*<br/> ON *table1.column\\_name*=*table2.column\\_name*; | ![5615cbfc703fa.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1ac8fb03acc4c4aaa8c4b3a674d2983~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=200\\&h=145\\&s=6871\\&e=gif\\&b=85b859) |\n| SELECT *column\\_name(s)*<br/> FROM *table1*<br/> LEFT JOIN *table2*<br/> ON *table1.column\\_name*=*table2.column\\_name*; | ![5615cc03dc434.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95fa3adde3c64073bae208a929850d59~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=200&h=145&s=7286&e=gif&b=85b859) |\n| SELECT *column\\_name(s)*<br/> FROM *table1*<br/> RIGHT JOIN *table2*<br/> ON *table1.column\\_name*=*table2.column\\_name*; | ![5615cc0991a29.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eff46028bc69482bbf6ac5a44584a61e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=200&h=145&s=7477&e=gif&b=85b859) |\n| SELECT *column\\_name(s)*<br/> FROM *table1*<br/> FULL OUTER JOIN *table2*<br/> ON *table1.column\\_name*=*table2.column\\_name*; | ![5615cc0fd9031.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6826e2bc103f485ea9982ca724625012~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=200&h=145&s=8135&e=gif&b=85b859) |\n\n\n\n\n### 13、UNION联合查询\n\n因为使用`UNION`来合并多个查询的记录会默认过滤掉重复的记录\n\n如果我们想要保留重复记录，可以使用`UNION ALL`来连接多个查询\n\n末尾加上`ORDER BY`和`LIMIT`子句\n\n### 14、数据\n\n**ALTER** **TABLE** first\\_table MODIFY **COLUMN** first\\_column **INT** **UNIQUE**; 添加唯一约束\n\n进行约束后 不覆盖原来的值 INSERT IGNORE INTO\n\n进行约束后 覆盖原来的值 INSERT VALUE(作为后续修改值读取的VALUE) ON DUPLICATE KEY UPDATE 修改值\n\n删除数据\n\n```sql\nDELETE FROM 表名 [WHERE 表达式];\n```\n\n更新数据\n\n```sql\nUPDATE 表名 SET 列1=值1, 列2=值2, ...,  列n=值n [WHERE 布尔表达式];\n```\n\n`LIMIT`子句来限制想要更新的记录数量，使用`ORDER BY`子句来指定符合条件的记录的更新顺序\n\n### 15、视图\n\n`视图`也可以被称为`虚拟表`，因为我们可以对`视图`进行一些类似表的增删改查操作，只不过我们对视图的相关操作都会被映射到那个又臭又长的查询语句对应的底层的表上。那一串又臭又长的查询语句的查询列表可以被当作`视图`的虚拟列\n\n| 视图                                     | 语句                                                         |\n| ---------------------------------------- | ------------------------------------------------------------ |\n| 创建视图                                 | **CREATE** **VIEW** 视图名（自定义列名） **AS** 查询语句     |\n| 查看视图的定义                           | **SHOW** **CREATE** **VIEW** 视图名;                         |\n| 可更新的视图（由原数据进行计算不能更新） | UPDATE *table\\_name*<br/> SET *column1*=*value1*,*column2*=*value2*,...<br/> WHERE *some\\_column*=*some\\_value*; |\n| 删除视图                                 | **DROP** **VIEW** 视图名                                     |\n\n### 16、自定义变量和语句结束\n\n`SET`语句来自定义一些我们自己的变量，自定义变量前边必须加一个`@`符号\n\n后面接sql语句时记得添加();\n\n可以使用 INTO 在查询结束时赋值\n\n`delimiter ` \\$ 修改返回符号为; 默认结束为; 我们进行多行操作时可以进行修改 修改为其他符号，确保不冲突\n\n### 17、函数\n\n```sql\n1418 - This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)\n```\n\n解决报错set global log\\_bin\\_trust\\_function\\_creators=TRUE;\n\nset global log\\_bin\\_trust\\_function\\_creators=1;\n\n```sql\nCREATE FUNCTION 存储函数名称([参数列表])\nRETURNS 返回值类型\nBEGIN\n    函数体内容\nEND\n```\n\n**SHOW** **CREATE** **FUNCTION** 函数名 查看某个函数的具体是怎么定义\n\n**DROP** **FUNCTION** 函数名 删除某个存储函数\n\n`SET`语句来自定义变量的方式，可以不用声明就为变量赋值。而在存储函数的函数体中使用变量前必须先声明这个变量\n\nDECLARE 变量名1, 变量名2, ... 数据类型 **\\[DEFAULT 默认值]***;*\n\nDECLARE后 再使用set 设置值\n\n##### 判断语句的编写\n\n```sql\nIF 表达式 THEN\n    处理语句列表\n[ELSEIF 表达式 THEN\n    处理语句列表]\n... # 这里可以有多个ELSEIF语句\n[ELSE\n    处理语句列表]\nEND IF;\n```\n\n##### 循环语句的编写\n\n```sql\nWHILE 表达式 DO\n    处理语句列表\nEND WHILE;\n```\n\n```sql\nREPEAT\n    处理语句列表\nUNTIL 表达式 END REPEAT;\n```\n\n```sql\nLOOP\n    处理语句列表\nEND LOOP;\n循环终止的条件写到处理语句列表中然后使用RETURN语句直接让函数结束就可以达到停止循环的效果\n可以使用LEAVE语句。不过使用LEAVE时需要在LOOP语句前边放置一个所谓的标记\n  flag:LOOP\n        IF i > n THEN\n            LEAVE flag;\n        END IF;\n        SET result = result + i;\n        SET i = i + 1;\n    END LOOP flag;\n    没分号跑不了\n```\n\n`存储函数`和`存储过程`都属于`存储例程`，都是对某些语句的一个封装。`存储函数`侧重于执行这些语句并返回一个值，而`存储过程`更侧重于单纯的去执行这些语句。先看一下`存储过程`的定义\n\n### 18、过程\n\n`存储函数`和`存储过程`都属于`存储例程`，都是对某些语句的一个封装。`存储函数`侧重于执行这些语句并返回一个值，而`存储过程`更侧重于单纯的去执行这些语句。\n\n```sql\nCREATE PROCEDURE 存储过程名称([参数列表])\nBEGIN\n    需要执行的语句\nEND\n```\n\n与`存储函数`最直观的不同点就是，`存储过程`的定义不需要声明`返回值类型`\n\n存储过程的调用\n\n```sql\nCALL 存储过程([参数列表]);\nIN arg INT\nOUT arg INT\nINOUT arg INT\n\nSHOW PROCEDURE STATUS [LIKE 需要匹配的存储过程名称] \nSHOW CREATE PROCEDURE 存储过程名称\nDROP PROCEDURE 存储过程名称\n```\n\n| 前缀    | 实际参数是否必须是变量 | 描述                                                         |\n| ------- | ---------------------- | ------------------------------------------------------------ |\n| `IN`    | 否                     | 用于调用者向存储过程传递数据，如果IN参数在过程中被修改，调用者不可见。(局部变量)默认就是`IN`参数 |\n| `OUT`   | 是                     | 用于把存储过程运行过程中产生的数据赋值给OUT参数，存储过程执行结束后，调用者可以访问到OUT参数。 |\n| `INOUT` | 是                     | 综合`IN`和`OUT`的特点，既可以用于调用者向存储过程传递数据，也可以用于存放存储过程中产生的数据以供调用者使用。 |\n\n`存储过程`和`存储函数`非常类似，我们列举几个它们的不同点以加深大家的对这两者区别的印象：\n\n*   存储函数在定义时需要显式用`RETURNS`语句标明返回的数据类型，而且在函数体中必须使用`RETURN`语句来显式指定返回的值，存储过程不需要。\n*   存储函数只支持`IN`参数，而存储过程支持`IN`参数、`OUT`参数、和`INOUT`参数。\n*   存储函数只能返回一个值，而存储过程可以通过设置多个`OUT`参数或者`INOUT`参数来返回多个结果。\n*   存储函数执行过程中产生的结果集并不会被显示到客户端，而存储过程执行过程中产生的结果集会被显示到客户端。\n*   存储函数直接在表达式中调用，而存储过程只能通过`CALL`语句来显式调用。\n\n### 19、游标\n\n#### 创建游标\n\n```sql\nDECLARE 游标名称 CURSOR FOR 查询语句;\n```\n\n#### 使用游标获取记录\n\n```sql\nFETCH 游标名 INTO 变量1, 变量2, ... 变量n\n```\n\nfetch获取不到时触发的时间\n\n**DECLARE** **CONTINUE** HANDLER **FOR** NOT FOUND 处理语句;\n\n**DECLARE** CONTINUE HANDLER **FOR** **NOT** FOUND **SET** not\\_done = 0;\n\n每调用一次 FETCH 语句，游标就移动到下一条记录的位置\n\n### 20、触发器和事件\n\n触发器\n\n```SQL\nCREATE TRIGGER 触发器名\n{BEFORE|AFTER}\n{INSERT|DELETE|UPDATE}\nON 表名\nFOR EACH ROW\nBEGIN\n    触发器内容\nEND\n```\n\n**SHOW** **CREATE** **TRIGGER** 触发器名;\n\n**DROP** **TRIGGER** 触发器名;\n\n触发器内容中不能有输出结果集的语句。\n\n触发器内容中NEW代表记录的列的值可以被更改，OLD代表记录的列的值无法更改。\n\n在BEFORE触发器中，我们可以使用`SET NEW.列名 = 某个值`的形式来更改待插入记录或者待更新记录的某个列的值，但是这种操作不能在AFTER触发器中使用，因为在执行AFTER触发器的内容时记录已经被插入完成或者更新完成了。\n\n如果我们的`BEFORE`触发器内容执行过程中遇到了错误，那这个触发器对应的具体语句将无法执行；如果具体的操作语句执行过程中遇到了错误，那与它对应的`AFTER`触发器的内容将无法执行。\n\n#### 事件\n\n有时候我们想让`MySQL`服务器在某个时间点或者每隔一段时间自动地执行一些语句，这时候就需要去创建一个`事件`。\n\n```SQL\nCREATE EVENT 事件名\nON SCHEDULE\n{\n    AT 某个确定的时间点 AT DATE_ADD(NOW(), INTERVAL 2 DAY)表达式| \n    EVERY 期望的时间间隔 [STARTS datetime][END datetime]\n}\nDO\nBEGIN\n    具体的语句\nEND\n```\n\n##### 查看和删除事件\n\n```SQL\nSHOW EVENTS;\nSHOW CREATE EVENT 事件名;\nDROP EVENT 事件名;\n默认情况下，MySQL服务器并不会帮助我们执行事件，除非我们使用下边的语句手动开启\nSET GLOBAL event_scheduler = ON;\n```\n### 21、索引\n\n**CREATE INDEX** 的语法：\n\n```\nCREATE INDEX index_name\nON table_name (column1 [ASC|DESC], column2 [ASC|DESC], ...);\n```\n\n-   `CREATE INDEX`: 用于创建普通索引的关键字。\n-   `index_name`: 指定要创建的索引的名称。索引名称在表中必须是唯一的。\n-   `table_name`: 指定要在哪个表上创建索引。\n-   `(column1, column2, ...)`: 指定要索引的表列名。你可以指定一个或多个列作为索引的组合。这些列的数据类型通常是数值、文本或日期。\n-   `ASC`和`DESC`（可选）: 用于指定索引的排序顺序。默认情况下，索引以升序（ASC）排序。\n\n##### 修改表结构(添加索引)\n\n```\nALTER TABLE table_name\nADD INDEX index_name (column1 [ASC|DESC], column2 [ASC|DESC], ...);\n```\n\n-   `ALTER TABLE`: 用于修改表结构的关键字。\n-   `table_name`: 指定要修改的表的名称。\n-   `ADD INDEX`: 添加索引的子句。`ADD INDEX`用于创建普通索引。\n-   `index_name`: 指定要创建的索引的名称。索引名称在表中必须是唯一的。\n-   `(column1, column2, ...)`: 指定要索引的表列名。你可以指定一个或多个列作为索引的组合。这些列的数据类型通常是数值、文本或日期。\n-   `ASC`和`DESC`（可选）: 用于指定索引的排序顺序。默认情况下，索引以升序（ASC）排序。\n\n##### 创建表的时候直接指定\n\n```\nCREATE TABLE table_name (\n  column1 data_type,\n  column2 data_type,\n  ...,\n  INDEX index_name (column1 [ASC|DESC], column2 [ASC|DESC], ...)\n);\n```\n\n##### 删除索引的语法\n\n```\nDROP INDEX index_name ON table_name;\nALTER TABLE employees\nDROP INDEX idx_age;\n```\n\n##### 使用ALTER 命令添加和删除索引\n\n-   ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):\n\n    该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。\n\n-   **ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):** 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。\n\n-   **ALTER TABLE tbl_name ADD INDEX index_name (column_list):** 添加普通索引，索引值可出现多次。\n\n-   **ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):** 该语句指定了索引为 FULLTEXT ，用于全文索引。\n\n```\nmysql> ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;\nmysql> ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);\nmysql> ALTER TABLE testalter_tbl DROP PRIMARY KEY;\n```\n\n##### 显示索引信息\n\n```\nmysql> SHOW INDEX FROM table_name\\G\n①Table：当前索引属于那张表。\n②Non_unique：目前索引是否属于唯一索引，0代表是的，1代表不是。\n③Key_name：当前索引的名字。\n④Seq_in_index：如果当前是联合索引，目前字段在联合索引中排第几个。\n⑤Column_name：当前索引是位于哪个字段上建立的。\n⑥Collation：字段值以什么方式存储在索引中，A表示有序存储，NULL表无序。\n⑦Cardinality：当前索引的散列程度，也就是索引中存储了多少个不同的值。\n⑧Sub_part：当前索引使用了字段值的多少个字符建立，NULL表示全部。\n⑨Packed：表示索引在存储字段值时，以什么方式压缩，NULL表示未压缩，\n⑩Null：当前作为索引字段的值中，是否存在NULL值，YES表示存在。\n⑪Index_type：当前索引的结构（BTREE, FULLTEXT, HASH, RTREE）。\n⑫Comment：创建索引时，是否对索引有备注信息。\n\n```\n\n唯一索引在创建时，需要通过`UNIQUE`关键字创建\n\n唯一索引数据不能重复\n\n主键索引其实是一种特殊的唯一索引，但主键索引却并不是通过`UNIQUE`关键字创建的，而是通过`PRIMARY`关键字创建\n\n```\nALTER TABLE tableName ADD PRIMARY KEY indexName(columnName);\n\n-- 方式②\nCREATE TABLE tableName(  \n  columnName1 INT(8) NOT NULL,   \n  columnName2 ....,\n  .....,\n  PRIMARY KEY [indexName] (columnName(length))  \n);\n\n```\n\n全文索引\n\n```\n-- 方式①\nALTER TABLE tableName ADD FULLTEXT INDEX indexName(columnName);\n\n-- 方式②\nCREATE FULLTEXT INDEX indexName ON tableName(columnName);\n用来查询最小搜索长度和最大搜索长度\nshow variables like '%ft%';\nft_min_word_len：使用MyISAM引擎的表中，全文索引最小搜索长度。\nft_max_word_len：使用MyISAM引擎的表中，全文索引最大搜索长度。\nft_query_expansion_limit：MyISAM中使用with query expansion搜索的最大匹配数。\ninnodb_ft_min_token_size：InnoDB引擎的表中，全文索引最小搜索长度。\ninnodb_ft_max_token_size：InnoDB引擎的表中，全文索引最大搜索长度。\n```\n\n-   `5.6`版本的`MySQL`中，存储引擎必须为`MyISAM`才能创建。\n-   创建全文索引的字段，其类型必须要为`CHAR、VARCHAR、TEXT`等文本类型。\n-   如果想要创建出的全文索引支持中文，需要在最后指定解析器：`with parser ngram`。","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/serve/sql/sql.md"}},{"pageContent":"import Chart2d from \"./css/chart/2dChart\";\nimport Pie from \"./css/chart/pie\";\nimport PointChart from \"./css/chart/dataPoint\";\nimport ThreeDChart from \"./css/chart/threeDChart\";\n\n# css图表\n\nCSS 实现柱状图\n\n<Chart2d />\n\n# css饼图\n\n<Pie />\n\n# pointChart\n\n<PointChart />\n\n# 折线图\n\n点与点的连接，实际上是斜边，我们使用三角函数进行处理\n\n`sin（x）= 对边 / 斜边`\n\n`var angle = Math.acos(对边 / 斜边) * (180 / Math.PI);`\n\n# 3d柱状图\n\n<ThreeDChart />\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/vr/chart.mdx"}},{"pageContent":"\nimport Css3d from \"./css/css3d/matrix3d\";\nimport Animation from \"./css/css3d/animation\";\nimport Animation3d from \"./css/css3d/3dAnimation\";\nimport Gradient from \"./css/css3d/Gradient\"\n\n\n# css的高级技巧\n\n## Transform 字体模糊问题\ntransform2D 我们一般用于 2D 场景的变换，transform3D 用于 3D 场景的变换，但是在一些特殊场景 transform2D 会字体模糊问题，比如使用transform: translate(-50%, -50%)。\n\n导致字体模糊的原因是：这个变换会触发浏览器对元素进行硬件加速。在某些浏览器中，硬件加速可能会导致更简化的文本渲染方法，从而出现字体模糊的情况。\n\n解决这个问题的方法之一是使用 transform: translate3d(-50%, -50%, 0)，将元素的变换转换为 3D 变换。这样可以强制浏览器使用更高质量的文本渲染，从而避免字体模糊的问题。\n\n另外，还可以尝试使用 backface-visibility: hidden 属性，将元素的背面隐藏起来，这有助于提高字体的清晰度。\n\n## matrix3d\n可以发现，matrix3d() API 中，有16个参数，但是他的参数的顺序和我们上面给出的顺序并不相同，上面给出的是数学中的矩阵的正常格式：\n\n行（row）是横向的，列（column）是纵先的。但是Web当中矩阵是刚好相反，即列是横向的，行是纵向的。类似下面这样：\n\n      <img\n        src=\"https://i-blog.csdnimg.cn/blog_migrate/81f887f9443d7a238c906238650545d9.png#pic_center\"\n        alt=\"在这里插入图片描述\"\n        referrerPolicy=\"no-referrer\"\n      />\n\n\n所以大家应该注意，前文所有的推导结果，放到matrix3d中，顺序应该是下面这样：\nmatrix3d(a00,a10,a20,a30,a01,a11,a21,a31,a02,a12,a22,a32,a03,a13,a23,a33)。\n\n\n\n\n      <img\n        src=\"https://i-blog.csdnimg.cn/blog_migrate/f0ac87c4896267ff2fa0e004bd62b15b.png#pic_centernpm install antd --save\"\n        alt=\"在这里插入图片描述\"\n        referrerPolicy=\"no-referrer\"\n      />\n\n<a href=\"https://blog.csdn.net/qq_35543489/article/details/113694496\" target=\"_blank\">矩阵详解</a>\n<Css3d />\n\n## Animation 动画\n\n\n<Animation />\n\n```tsx\nimport styles, { keyframes, css } from \"styled-components\";\nexport default () => {\n  let a1 = (props: { i: number }) => {\n    let { i } = props;\n    return keyframes`0% {\n    transform: translate(${30 * (i - 1)}px, 0);\n  }\n\n  30% {\n    transform: translate(10px, ${10 * i}px) rotate(60deg) scale(${i * 0.009});\n  }\n\n  60% {\n    transform: translate(${10 * i}px, 10px) rotate(120deg) scale(${i * 0.009});\n  }\n\n  80% {\n    transform: translate(0,${30 * (i - 1)}px) scale(${i * 0.009});\n  }\n\n  100% {\n    transform: translate(${30 * (i - 1)}px, 0);\n  }`;\n  };\n\n  // animation: ${a1} 4s infinite;\n  let BoxItem = styles.div<{ i: number; intI: number }>`width: 60px;\n  height: 60px;\n  border-radius: 12px;\n  position: absolute;\n \n  ${props => css`\n    &:nth-child(${props.i}) {\n      background-color: hsl(${40 + 3 * props.i}, 55%, 50%);\n      transform: translate(${30 * (props.i - 1)}px, 0);\n\n      animation: ${a1(props)} 4s infinite;\n      animation-delay: ${props.i * 0.02}s;\n    }\n  `}\n  `;\n  return (\n    <div className=\"mt-10 h-[400px] scale-[20%]  hover:scale-100\">\n      {Array.from({ length: 4 }).map((_, intI) => {\n        return (\n          <div key={intI} style={{ transform: `rotate(${intI * 90}deg)` }}>\n            {Array.from({ length: 40 }, (_, index) => (\n              <BoxItem key={index} i={index + 1} intI={intI + 1}></BoxItem>\n            ))}\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n\n```\n\n## 3d动画\n\n<Animation3d />\n\n我画了一个简单的流程图讲述其核心概念\n<img src='https://ik.imagekit.io/Manshawar/ferris_8PiNzixa3' />\n\n这里是代码:\n```tsx\n\nimport styles, { keyframes, css } from \"styled-components\";\nlet colorList = [\"#222\", \"#401a2a\", \"#741a38\", \"#9b123c\", \"#c10a40\"].reverse();\nexport default () => {\n  let Container = styles.div`overflow: hidden;height:700px; perspective: 1000px; position: relative;transform-style: preserve-3d;`;\n  let Assembly = styles.div` transform-style: preserve-3d; transform:rotateX(-35deg) rotateY(-45deg);padding-top: 20px;`;\n  let Cube = styles.div<{ color: string; index: number; rect: number }>`\n  width: ${props => props.rect}px;\n  height: ${props => props.rect}px;\n  background:${props => props.color};\n  position: relative;\n  transform-style: preserve-3d; \n &:before,\n&:after {\n  width: inherit;\n  height: inherit;\n  content:\"\";\n    background:${props => props.color};\n    width: ${props => props.rect}px;\n  height: ${props => props.rect}px;\n    position: absolute;\n    left:0;\n    top:0; \n    display:block;\n    filter: brightness(1.15);\n}\n&:after{\ntransform:rotateX(-90deg);\ntransform-origin: center top;\n}\n&:before{\ntransform:rotateY(-90deg);\ntransform-origin: center right\n\n}\n  `;\n  let t = 2;\n  let T3d = styles.div`transform-style: preserve-3d;`;\n  let move = keyframes`from{\ntransform:translate(0em) scale3d(1, 1, 1);\n  }\n  to{\ntransform:translate(7em) scale3d(0, 0, 0);\n  }\n  `;\n  let switchAnimation = keyframes`\n    to {\n    transform: rotateY(1turn); // 在最后一帧的时候将做360旋转\n  }\n  `;\n  let Switch_in = styles(T3d)`\n  animation: ${switchAnimation} ${4 * t}s steps(4) infinite;\n  `;\n  let Move = styles(T3d)`\n animation: ${move} ${t}s ease-in-out infinite;;\n  `;\n  let Move_out = styles(Switch_in)`\n   animation-direction: reverse;\n   animation-timing-function: steps(4, start);\n  `;\n  return (\n    <Container>\n      <Assembly className=\"flex flex-col justify-start w-full h-full items-center gap-10 absolute top-0 left-0\">\n        {colorList.map((item, index) => {\n          return <Cube color={item} index={index} rect={30}></Cube>;\n        })}\n      </Assembly>\n      <Assembly className=\"flex flex-col justify-start w-full h-full items-center gap-10 absolute top-0 left-0\">\n        {colorList.map((item, index) => {\n          return (\n            <Move_out>\n              <Move>\n                <Switch_in>\n                  <Cube color={item} index={index} rect={30}></Cube>\n                </Switch_in>\n              </Move>\n            </Move_out>\n          );\n        })}\n      </Assembly>\n    </Container>\n  );\n};\n\n```\n\n## 渐变\n<Gradient />\n\n\n## 伪类 :is 和 :where的逻辑函数和条件函数\n:is() 和 :where() 是 CSS 中的伪类选择器，它们允许我们以一种高效的方式对一系列选择器进行分组和定位。\n\n我们看下下面代码演示，仔细体会简化代码：\n\n```css\nbutton.foces, button:focus {  } \n->\nbutton:is(.focus, :focus) {}\n\ncontent > h1, content > h2, content > h3, content > h4 {}\n->\ncontent > :is(h1, h2, h3, h4)\n\n```\n两者唯一区别在于权重，:where 的权重为 0，:is 作为伪类选择器的权重为 10。","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/vr/css.mdx"}},{"pageContent":"import Btn from \"./css/instance/btn\";\n\n# 可视化实例\n\n1. stroke-dasharray 表现属性定义了用于绘制形状轮廓的虚线段和间隙的排列形式。\n\n2. stroke-dashoffset 表现属性定义了虚线段和间隙的偏移量。\n\n3. dasharray以逗号或空格分隔的 length 和 percentage 列表，用于定义交替的虚线段和间隙的长度。如果提供了奇数个值，则重复该列表以产生偶数个值，因此 5,3,2 等价于 5,3,2,5,3,2。\n\n4. stroke-dashoffset 是一种表现属性，它定义了虚线与路径起点之间的偏移量。\n\n5. 对于形状元素和文本，fill 属性是外观属性，用来定义给定图形元素内部的颜色。哪一块算是“内部”取决于形状本身以及fill-rule 属性的值。作为一个外观属性，它可以直接用作 CSS 样式表内部的属性。\n\n- 使用`stroke-dashoffset:125.66`作为初始偏移量\n- 使用`stroke-dasharray: 125.66 125.66`,做一组偏移虚线\n<Btn />\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/vr/instance.mdx"}},{"pageContent":"### 路由组件\n\n1. pages下的为动态路由路径\n2. 动态路由[id]\n3. 嵌套路由\n4. `<NuxtPage></NuxtPage>` 类比为routerView\n\n```js\n    pages/\n    --- detail/\n    ------[id].vue\n    --- detail.vue\n    --- index.vue\n===   \n      {\n      path: '/detail',\n      component: '~/pages/detail.vue',\n      children: [\n        {\n          path: '/:id',\n          component: '~/pages/detail/[id].vue'\n        }\n      ]\n    }\n```\n\n### 资源目录\n\n- public：会被作为应用程序根目录提供给用户，打包工具不会处理，访问时添加 `/`即可，例如：`/logo.png`\n- assets：打包工具会处理，访问时以 `~`开头，例如：`~/assets/logo.png`。\n\n### 全局样式\n\n```js\nexport default defineNuxtConfig({\n  css: [\n    'assets/global.css'\n  ]\n})\n```\n\n```js\n变量文件\n// https://nuxt.com/docs/api/configuration/nuxt-config\nexport default defineNuxtConfig({\n  css: [\"assets/global.scss\"],\n  vite: {\n    css: {\n      preprocessorOptions: {\n        scss: {\n          additionalData: '@import \"~/assets/_variables.scss\";',\n        },\n      },\n    },\n  },\n});\n```\n\n### 公共组件\n\n- Nuxt 中约定把组件放在 `components/`目录中，这些组件只要被用在页面或其他组件中，就会自动导入并注册。\n- ```js\n  驼峰命名\n  | components/\n  --| base/\n  ----| foo/\n  ------| Button.vue\n  <BaseFooButton />\n  ```\n- \n\n### 服务端api\n\n```javasc\nserver/api/hello.ts \nexport default defineEventHandler((event) => {\n  return {\n    message: 'hello，nuxt3！'\n  }\n})\n```\n\n### gray-matter\n\n```javascript\nconst fs = require('fs');\nconst matter = require('gray-matter');\nconst str = fs.readFileSync('example.html', 'utf8');\nconsole.log(matter(str));\n作用 读取数据形成对象\n---\ntitle: Hello\nslug: home\n---\n<h1>Hello world!</h1>\n\n{\n  content: '<h1>Hello world!</h1>',\n  data: {\n    title: 'Hello',\n    slug: 'home'\n  }\n}\n\n可以转化为html\n    import { remark } from \"remark\";\n    import html from \"remark-html\";\n```\n\n### 请求\n\n|            路由参数            |                                 请求体                                 | 查询参数                          |\n| :-----------------------------: | :--------------------------------------------------------------------: | --------------------------------- |\n| `getRouterParam(event, 'id')` | $fetch('/api/create-post', { method: 'post', body: { id: 'new id' } }) | `/api/query?param1=a&param2=b ` |\n|     /api/hello/[name].ts；     |                   const body = await readBody(event)                   | const query = getQuery(event)     |\n|                                |                                                                        |                                   |\n\n### 数据获取\n\n| 钩子                                                                                                                               | 函数                                                                                                     |\n| ---------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |\n| `useFetch`是对 `useAsyncData`和 `$fetch`的封装，只需传入请求的 URL                                                           | const { data: posts, pending, error } = await useFetch('/api/posts')                                     |\n| 该方法等效于 `useFetch`设置了 `lazy`选项为 true，不同之处在于它 **不会阻塞路由导航** ，这意味着我们需要处理 data 为 null | const { data: posts, pending, error } = await useLazyFetch('/api/posts')                                 |\n| 该方法和 `useFetch` 相比功能上是相同的，但是更底层                                                                               | const fetchPost = () =>$fetch(`url`);``const { data, pending } = await useAsyncData(fetchPost); |\n| useLazyAsyncData                                                                                                                   | 该方法等效于 `useAsyncData`，仅仅设置了 `lazy`选项为true，也就是它不会阻塞路由导航                   |\n\n### 刷新数据和缓存\n\n传入返回值可以刷新\n\n1. const { data, refresh } = useFetch('/api/somedata') api有缓存不会刷新\n2. const { data, refresh } = useFetch(() => `/api/somedata?page=${page}`)无缓存，会刷新\n\n### 状态管理\n\n#### useState 服务端共享状态\n\n```typescript\nuseState<T>(init?: () => T | Ref<T>): Ref<T>\nuseState<T>(key: string, init?: () => T | Ref<T>): Ref<T>\n```\n\n* useState(key, init) 是有缓存性的，如果 key 不变，init 只做初始化，则多次调用同一个 useState，结果是一样的；\n* 服务端友好性，得益于缓存性，即便 init 返回值是不稳定的，也能保证前端注水时前后端状态的一致性。\n* composables/state.ts：export const useCounter = () => useState('data', () => 1) 可以在多个组件中共享这一个数据\n\n可以使用pinia，具体见https://nuxt.com.cn/modules/pinia\n\n### 错误处理\n\n    throw createError({\n      statusCode: 404,\n      statusMessage: \"文章不存在\"\n    });\n\n### SEO\n\n#### 1、全局配置页头信息\n\n```javascript\nexport default defineNuxtConfig({\n  app: {\n    head: {\n      charset: 'utf-8', // 快捷方式\n      viewport: 'width=device-width, initial-scale=1', // 快捷方式\n      title: 'My App',\n      meta: [\n        { name: 'description', content: 'My amazing site.' },\n        { name: 'charset', content: 'utf-8' },\n      ],\n      \"link\": [],\n      \"style\": [],\n      \"script\": []\n    }\n  }\n})\n```\n\n#### 2、设置各子页面标题\n\n```js\n首页\nuseHead({\n  title: '文章列表'\n})\n子页面\nuseHead({\n  titleTemplate: (s) => {\n    return s ? `${s} - 附属文本1` : \"附属文本2\";\n  },\n});\n```\n\n#### 3内置组件修改\n\nNuxt 还提供了多种组件可以在模板中设置具体页面页头信息：`<Title>`, `<Base>`, `<NoScript>`, `<Style>`,\n`<Meta>`, `<Link>`, `<Body>`, `<Html>` , `<Head>`，像下面这样使用：\n\n### 中间件\n\n| 匿名中间件                                                                                                             | 具名中间件                                                        | 全局中间件                              |\n| ---------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- | --------------------------------------- |\n| 只影响一个页面，不可复用                                                                                               | 指定若干影响页面，可复用、组合                                    | 影响所有页面，文件名需要加后缀 global。 |\n| definePageMeta({``      middleware(to,from) {``        console.log('匿名中间件，具体页面执行');      }}) | definePageMeta({``      middleware: ['amid', 'bmid']    }) | 中间件.global.ts：                      |\n\n### 插件\n\n```js\nexport default defineNuxtPlugin(nuxtApp => {\n  // Doing something with nuxtApp\n  console.log(nuxtApp)\n})\n```\n\n- 实际上只注册 plugins 目录下根文件和子目录下的 index 文件。\n- 插件的执行顺序可以用数字来控制，因为插件之间可能有依赖关系。\n- 可在文件名上使用 `.server` 或 `.client` 后缀使插件仅作用于服务端或者客户端。\n  * plugins/\n    | - server-plugin.server.ts\n    | - client-plugin.client.ts\n\nnuxtApp\n\n* `provide (name, value)`：定义全局变量和方法；\n* `hook(name, cb)`：定义 nuxt 钩子函数；\n* `vueApp`：获取 vue 实例；\n* `ssrContext`：服务端渲染时的上下文；\n* `payload`：从服务端到客户端传递的数据和状态；\n* `isHydrating`：用于检测是否正在客户端注水过程中。\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/vue/nuxt/nuxt.md"}},{"pageContent":"### vue回车换行自定义指令\n\n有客户提出需求，希望在输入框输入后能使用回车换行，因为项目表单很多，我想到使用自定义指令来实现这个功能，我书写了两个版本，vue2和vue3\n\n我会先贴出完整的代码片段和注释，后面再对书写的内容进行详解 ，大家有需要可以直接去使用，第一次写文章，如果有不妥，大家请见谅。如果代码内容有问题，请帮忙提出一下修改意见，谢谢。\n\n### 1、Vue2速通版\n\n```js\n//  ./module/iptLine.js文件\nlet nodes;//以数组形式存放node节点\nlet callBackHandler;//暂存bind值，方便在事件中回调\nexport default {\n  bind: function (el, bind) {\n    nodes = getNode(el, []); //在当前绑定的元素下，获取非disabled的node节点\n    callBackHandler = bind;\n    el.addEventListener(\"keyup\", nextHandler);//绑定keyup事件\n  },\n  unbind: function (el) {\n### //移除副作用\n    el.removeEventListener(\"keyup\", nextHandler);//移除keyup事件\n    nodes = undefined;//\n    callBackHandler = undefined;\n  },\n};\nfunction nextHandler(e) {\n\n  e.preventDefault();//阻止原生事件\n  if (e.key !== \"Enter\") return;//如果不是回车键，则不触发\n  nodes.forEach((item, index) => {//对于nodes节点进行循环，进行事件委托\n    if (e.target === item) {//寻找当前触发的这个事件的node节点\n      if (index === nodes.length - 1)//如果node节点是最后一位，则触发传入回调\n        return callBackHandler.value && callBackHandler.value();//当传入回调存在时则进行触发\n      nodes[index + 1].focus();//将焦点移动至下一个node\n    }\n  });\n}\n/**\n * \n * @param {HTMLElement} el 传入dom实例，获取该实例下的所有input的node节点\n * @param {[]} arr 方便递归时存储已筛选出的node节点，请固定传入[]\n * @returns \n */\nfunction getNode(el, arr) {\n  el.childNodes.forEach((item, index) => {//对于当前元素的子节点进行循环\n    if (item.tagName === \"INPUT\" && item.disabled !== true) {\n      //如果当前的node节点是input,且为可用状态，则添加的数组中\n      arr.push(item);\n    } else {\n      if (item.childNodes === undefined) return;//如果没有子节点则终止该函数\n      getNode(item, arr);//如果有子节点则进行递归\n    }\n  });\n  return arr;\n}\n\n```\n\n```js\n//vue事件注册\nimport iptLine from './module/iptLine'\nVue.directive(\"iptLine\", iptLine);\n//iptLine是自定义的名字，大家可以根据习惯定义\n```\n\n总体思路：获取当前绑定自定义指令的元素，递归这个元素中的input标签形成数组，通过事件委托，找到当前元素再数组中的位置，将焦点通过focus移动到下一个元素，接受一个回调函数\n\n回调函数是在移动到最后一位时触发，如果要传入参数，请以闭包的形式传入  。ps:v-iptLine='()=>callback(\"hello world\")',一般情况下如果不需要传入参数v-iptLine='callback'即可\n\n\n\n### 2、Vue3速通版\n\nvue3的只需要修改生命周期即可bind和unbind，修改为created和beforeUnmount\n\n```js\nlet nodes;\nlet callBackHandler;\nexport default {\n  created: function (el, bind) {\n    nodes = getNode(el, []);\n    callBackHandler = bind;\n    el.addEventListener('keyup', nextHandler);\n  },\n  beforeUnmount: function (el) {\n    el.removeEventListener('keyup', nextHandler);\n    nodes = undefined;\n    callBackHandler = undefined;\n  }\n};\nfunction nextHandler(e) {\n  e.preventDefault();\n  if (e.key !== 'Enter') return;\n  nodes.forEach((item, index) => {\n    if (e.target === item) {\n      if (index === nodes.length - 1)\n        return callBackHandler.value && callBackHandler.value()\n      nodes[index + 1].focus();\n    }\n  });\n}\nfunction getNode(el, arr) {\n  el.childNodes.forEach((item, index) => {\n    if (item.tagName === 'INPUT' && item.disabled !== true) {\n      arr.push(item);\n    } else {\n      if (item.childNodes === undefined) return;\n      getNode(item, arr);\n    }\n  });\n  return arr;\n}\n\n```\n\nvue3的使用方法和vue2基本一致，不多赘述了。（偷懒，嘿嘿）\n\n如果不想看具体的想法，已经结束了啦\n\n### 3、具体实现\n\n如何实现回车跳转呢？我的设想是获取我们需要跳转元素的input元素，按回车跳转到下一个元素，那就通过两步走来实现\n\n1. 获取当前元素下所有的input元素\n2. 按回车跳转到下一个元素\n\n### 3.1、基本知识\n\n一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\n\n- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n- `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n- `update`：所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。\n\n- `componentUpdated`：指令所在组件的 VNode **及其子 VNode** 全部更新后调用。\n\n- `unbind`：只调用一次，指令与元素解绑时调用。\n\n  \n\n  指令钩子函数会被传入以下参数：\n\n  - el：指令所绑定的元素，可以用来直接操作 DOM。\n\n  - binding\n\n    ：一个对象，包含以下 property：\n\n    - `name`：指令名，不包括 `v-` 前缀。\n    - `value`：指令的绑定值，例如：`v-my-directive=\"1 + 1\"` 中，绑定值为 `2`。\n    - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。\n    - `expression`：字符串形式的指令表达式。例如 `v-my-directive=\"1 + 1\"` 中，表达式为 `\"1 + 1\"`。\n    - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `\"foo\"`。\n    - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`。\n\n  - `vnode`：Vue 编译生成的虚拟节点。移步 [VNode API](https://v2.cn.vuejs.org/v2/api/#VNode-接口) 来了解更多详情。\n  - `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。\n\n  官网链接\n\n[]: https://v2.cn.vuejs.org/v2/guide/custom-directive.html\n\n### 3.2、获取元素\n\n我们可以在自定义指令的钩子函数中，直接获取当前的dom实例，我书写了一个函数，通过递归，可以找到所有的input子节点\n\n```js\n/**\n * \n * @param {HTMLElement} el 传入dom实例，获取该实例下的所有input的node节点\n * @param {[]} arr 方便递归时存储已筛选出的node节点，请固定传入[]\n * @returns \n */\nfunction getNode(el, arr) {\n  el.childNodes.forEach((item, index) => {//对于当前元素的子节点进行循环\n    if (item.tagName === \"INPUT\" && item.disabled !== true) {\n      //如果当前的node节点是input,且为可用状态，则添加的数组中\n      arr.push(item);\n    } else {\n      if (item.childNodes === undefined) return;//如果没有子节点则终止该函数\n      getNode(item, arr);//如果有子节点则进行递归\n    }\n  });\n  return arr;\n}\n```\n\n这个函数传入两个参数，第一个是dom实例，第二个是一个空数组，\n\n1. dom实例的作用是获取实例身上的childNodes，它会返回子节点的集合，我们对它进行循环\n2. 空数组则是帮助我们再递归的过程中，保留我们需要的数据，通过闭包的形式返回出来\n\n如果当前的node节点是input，并且它的diabled属性不会true，就会添加到我们的数组集合中。如果当前层级的input节点查询完毕，我们需要判断他是否有子节点，如果有子节点则进行递归操作，如果没有子节点则终止当前条件\n\n### 3.3、绑定事件\n\n我们将事件绑定到当前的dom上去，通过事件委托的机制来对我们需要实现的功能进行下发。\n\n```js\nnodes = getNode(el, []); //在当前绑定的元素下，获取非disabled的node节点\ncallBackHandler = bind;\nel.addEventListener(\"keyup\", nextHandler);//绑定keyup事件\n```\n\n#### 3.3.1绑定事件函数\n\n```js\nfunction nextHandler(e) {\n  e.preventDefault();//阻止原生事件\n  if (e.key !== \"Enter\") return;//如果不是回车键，则不触发\n  nodes.forEach((item, index) => {//对于nodes节点进行循环，进行事件委托\n    if (e.target === item) {//寻找当前触发的这个事件的node节点\n      if (index === nodes.length - 1)//如果node节点是最后一位，则触发传入回调\n        return callBackHandler.value && callBackHandler.value();//当传入回调存在时则进行触发\n      nodes[index + 1].focus();//将焦点移动至下一个node\n    }\n  });\n}\n```\n\n首先先阻止该函数的原生事件，当按键不会'Enter'时，则不进行触发，我们对收集到的node节点进行循环，找到当前触发事件的dom元素，接下来使用focus函数将焦点移动到下一个node节点，如果当前的节点是最后一个，则判断是否存在传入的回调函数，如果存在则调用，上文的if(条件)return这是一种简写方法\n\n#### 3.3.2为什么要进行事件委托？\n\n其实在开始的一版，是直接使用el.querySelectorAll(\"input\");获取所有的input标签，然后直接进行绑定的，真的很好用，直接写个函数就干完了，但是它是真的很耗性能，所有的input标签都会绑定这个事件，如果你后续需要对input标签绑定事件，就该掉头发了，我们通过事件委托，就可以只绑定在父元素上，而且就一个，对于后期的副作用也好处理哦\n\n![图片转存失败，建议将图片保存下来直接上传](https://img0.baidu.com/it/u=1954292512,992155393&fm=253&fmt=auto&app=138&f=JPEG?w=400&h=450)\n\n### 3.3.3为什么绑定keyup事件？\n\n主要是因为大多键盘的默认事件都是在keydown上，而且大多数的ui框架也都是绑定一些事件在keydown上，主要就是为了不影响大家的习惯，后续拓展其他事件也方便\n\n### 3.3.4为什么使用变量提前进行申明？\n\n使用变量申明主要是方便在addEventListener绑定事件的函数中进行操作，addEventListener是无法传参进去的，如果你书写成（参数a）=>function（e）{}这种形式想要去获取如el或者bind这些我们需要在函数中使用的一些参数，我们会面临一个问题，在后续的removeEventListener中，我们将无法移除这个事件，道理和vue的data为什么是return一样，它每次都会生成一个具有新地址的函数，我没没法去移除它\n\n感谢阅读。看到这里帮忙点个攒吧！Thanks♪(･ω･)ﾉ","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/vue/other/vue回车换行自定义指令.md"}},{"pageContent":"## 1、项目\n\n### 1.1 参数回调\n\nemits('事件名'，参数)\n\n```js\nconst switchHandler=(val:number)=>{\n  isSwitch.value=val;\n  emits('switchHandlerEmit',val)\n}\n```\n\n### 1.2 dataset参数\n\n```html\n      <view\n        class=\"scroll-view-item\"\n        v-for=\"(item, index) in navList\"\n        :key=\"item.id\"\n        :class=\"{ active: index == sliderData.sliderIndex }\"\n        :data-index=\"index\"\n      >\n        {{ item.name }}\n      </view>\n\n```\n\n可以在e.target中的dataset属性中获取设置的属性值\n\n### 1.3 下拉刷新 mescroll插件（使用插件流程）\n\nhttps://www.mescroll.com/demo.html，\n\n- 组件区分大小写，注意不能用驼峰代替-\n- 新建uni_modules，右键去市场引入包\n- @ts-ignore，取消ts的报错\n- 需要刷新的由mescroll-body包裹\n- 小程序的easycom规范，自动注册组件\n\n### 1.4 easycom规范\n\n传统vue组件，需要安装、引用、注册，三个步骤后才能使用组件。`easycom`将其精简为一步。\n\n只要组件路径符合规范\n\n`路径规范`指：\n\n1. 安装在项目根目录的components目录下，并符合 `components/组件名称/组件名称.vue`\n2. 安装在uni_modules下，路径为 `uni_modules/插件ID/components/组件名称/组件名称.vue`\n\n### 1.5 小程序的各个平台\n\n- 以 `#ifdef` 或 `#ifndef` 加 `%PLATFORM%` 开头，以 `#endif` （一定存在）结尾。\n- `#ifdef`：if defined 仅在某平台存在\n- `#ifndef`：if not defined 除了某平台均存在\n- `%PLATFORM%`：平台名称\n\n  常见平台\n\n  VUE3、VUE2、APP、APP-PLUS （uni-app js引擎版编译为App时）、APP-PLUS-NVUE或APP-NVUE、APP-ANDROID、APP-IOS、H5、WEB、MP-WEIXIN\n\n### 1.6常用组件\n\nscroll-view\n\n```html\n\t<view class=\"navbar\">\n\t\t<!-- 这里是标题栏 -->\n\t</view>\n\t<scroll-view scroll-y=\"true\" class=\"page-content\">\n\t\t这里是内容区\n\t</scroll-view>\n.navbar{\n\tposition: fixed;\n\ttop:0;\n\twidth:100%;\n\theight:44px;\n}\n.page-content {\n\tposition: fixed;\n\ttop: 44px;   // 距离标题栏高度\n\tleft: 0;\n\tright: 0;\n\tbottom: 0px;\n}\n注释：父元素设置子元素不换行 white-space: nowrap;，设置最小宽度，可以实现滑动栏的效果\n负责用户上下浏览设置 `scroll-y`，而导航栏负责左右浏览设置 `scroll-x`\n```\n\n NavBar 导航栏 支持左右插槽 （下载 非内置组件）\n\n```html\n\t<uni-nav-bar fixed :status-bar=\"true\" title=\"我的音乐\" @clickLeft=\"goCloud\" @clickRight=\"goCloud\">\n\t\t<block slot=\"left\"><image class=\"top-img left\" src=\"/static/image/mine/l.png\"></image></block>\n\t\t<!-- #ifdef APP-PLUS -->\n\t\t<block slot=\"right\"><image class=\"top-img\" src=\"/static/image/mine/r.png\"></image></block>\n\t\t<!-- #endif -->\n\t</uni-nav-bar>\n```\n\n- vue3中，有时会出现bug，需从文件中引入，\n\n使用uniapp组件库，不走弯路了\n\nimage的图片可以使用 mode=\"widthFix\"实现自适应高度\n\n    `<image :src=\"item.image\" mode=\"widthFix\" style=\"width: 100%\"></image>`\n\n### 1.7pinia\n\n```ts\nimport { createPinia } from \"pinia\";\nimport { createPersistedState } from \"pinia-plugin-persistedstate\";\n\nconst store = createPinia();\n// 状态持久化\nstore.use(\n    createPersistedState({\n        storage: {\n            getItem: (key: string) => uni.getStorageSync(key),\n            setItem: (key: string, value: string) => uni.setStorageSync(key, value)\n        }\n    })\n);\n\nexport default store;\n\n```\n\n小程序中，使用插件实现数据持久化\n\n```js\n  persist: {\n        key: \"模块名\",\n        paths: ['state中需要存储的值']\n    }\n```\n\nPinia在ts中使用，需要注入store\n\n```js\nimport store from \"@/store/index\"\nimport {setBarStore} from \"@/store/setTabBar\"\n//设置标签\nconst useSetBar = setBarStore(store);\n```\n\n### 1.8app扫码api\n\n```html\n<!-- components/scan/scan.vue -->\n<template>\n    <view></view>\n</template>\n\n<script>\n    export default {\n        data() {\n            return {\n                typeList: [ // 码类型 参考地址 https://www.dcloud.io/docs/api/zh_cn/barcode.html\n                    plus.barcode.QR,\n                    // plus.barcode.EAN13,\n                    // plus.barcode.EAN8,\n                    // plus.barcode.UPCA,\n                    // plus.barcode.UPCE,\n                    // plus.barcode.CODABAR,\n                    // plus.barcode.CODE39,\n                    // plus.barcode.CODE93,\n                    // plus.barcode.CODE128,\n                    // plus.barcode.ITF,\n                ],\n            };\n        },\n        methods: {\n            open() {\n                // 创建上层webview\n                let pages = getCurrentPages();\n                let currentWebview = pages[pages.length - 1].$getAppWebview();\n                // 创建一个扫码框\n                this.barcode = plus.barcode.create('barcode', this.typeList, {\n                    position: 'fixed',  // fixed 固定在页面\n                    top: '64px',\n                    left: '0px',\n                    width: '100%',\n                    height: '100%',\n                });\n                // 扫码成功回调\n                this.barcode.onmarked = this.onmarked;\n                // 添加到当前 Webview\n                currentWebview.append(this.barcode);\n                // 打开扫码\n                this.barcode.start();\n            },\n            // 关闭扫码\n            close () {\n                this.barcode.close();\n            },\n            // 扫码成功\n            onmarked (type, result) {\n                this.openStartRecognize(result)\n                this.$emit('success', result);\n                this.close()\n            }\n        }\n    }\n</script>\n<style lang=\"scss\"></style>\n```\n\n### 1.9字体px\n\n一般设计稿750px，手机像素点缩放2rpx=1px,如果遇到0.5px无法渲染，可以使用伪元素配合scale属性进行缩放\n\n```css\n transform: scale(0.84);\n```\n\n### 2.0使用vue3ref组件\n\n```js\ndefineExpose({ openSearch, closeSearch })\n```\n\n需要使用defineExpose函数对实例的值进行暴露\n\n### 2.1storage\n\n```js\nuni.setStorageSync() ，uni.getStorageSync() 同步\n```\n\n### uni.setStorageSync(KEY,DATA)\n\n将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。\n\n**参数说明**\n\n| 参数 | 类型   | 必填 | 说明                                                         |\n| :--- | :----- | :--- | :----------------------------------------------------------- |\n| key  | String | 是   | 本地缓存中的指定的 key                                       |\n| data | Any    | 是   | 需要存储的内容，只支持原生类型、及能够通过 JSON.stringify 序列化的对象 |\n\n### uni.getStorageSync(KEY)\n\n从本地缓存中同步获取指定 key 对应的内容。\n\n**参数说明**\n\n| 参数 | 类型   | 必填 | 说明                   |\n| :--- | :----- | :--- | :--------------------- |\n| key  | String | 是   | 本地缓存中的指定的 key |\n\n### 2.2防抖\n\n```html\nfunction debounce(fn, wait = 300) {  \n    var timeout = null;  \n    return function() {    \n        if(timeout !== null) clearTimeout(timeout);    \n        timeout = setTimeout(fn, wait);  \n    }\n}\n```\n\n### 2.3分包\n\n```html\n// pages.json\n\"pages\": [],\n\"subPackages\": [\n\t{\n\t\t\"root\": \"pages/subpages\",   // 分包根目录\n\t\t\"pages\": [{\n\t\t\t\"path\": \"album\",              // 配置页面路径，此为subpages下的路径\n\t\t\t\"style\": {\n\t\t\t\t\"navigationBarTitleText\": \"歌单\",\n\t\t\t\t\"app-plus\": {\n\t\t\t\t\t\"titleNView\": false\n\t\t\t\t}\n\t\t\t}\n\t\t}]\n\t}\n],\n```\n\n每次打开小程序会发现有的小程序打开的很快，有些很慢，甚至白屏时间很长。原因是包代码量大小的问题。第一次进入小程序的时候，小程序会下载主包代码，如果我们的主包业务代码越多，那么白屏的时间也会越长。理解成懒加载就好\n\n### 2.4 transform\n\n```css\ntransform:translateX(-50%)不会生效\ntransform:translate(-50%,-50%)生效\n```\n\n### 2.5跳转\n\nswitchTab才能跳转到tab页面\n\n### 2.6固定定位产生的布局问题\n\n因为fixed元素脱离了正常文档流，所以relative元素的原本位置向上提了，产生了覆盖的行为。\n\n需要添加 `margin`or `padding`属性到下层内容组件上，使其发生向下偏移，不再被覆盖。\n\n- 给内容设置margin-top，**同时设置header中的top:0和z-index**，否则引起margin-top失效\n- 用空div占位，同时设置body margin=0，使div的位置相对于视窗口无边距，变得可计算\n\n### 2.7scroll-view事件问题\n\n```html\n   <scroll-view scroll-y=\"true\" class=\"detailBody\" style=\"height: 100%\" @scroll=\"scrollHandler\">\n       <view>高度要高于scroll-view高度</view>\n      </scroll-view>\n```\n\n需要内部高度超出整个scroll-view高度 ，关于scroll事件是否生效\n\n### 2.8uView组件\n\n这次使用的uView-plus组件，组件内部设置border是!important，得将border关闭后再设置border,它的u-input自带flex:1 flex 1 1 0%  flex-grow，flex-shrink，flex-basis 得将grow设置为0 并且flex-basis设置为auto 既代表项目原来大小\n\n### 2.9登陆获取头像问题\n\n- **自生效期起，小程序 wx.getUserProfile 接口将被收回**：生效期后发布的小程序新版本，通过 wx.getUserProfile 接口获取用户头像将统一返回默认[灰色头像](https://mmbiz.qpic.cn/mmbiz/icTdbqWNOwNRna42FI242Lcia07jQodd2FJGIYQfG0LAJGFxM4FbnQP6yfMxBgJ0F3YRqJCJ1aPAK2dQagdusBZg/0)，昵称将统一返回 “微信用户”。生效期前发布的小程序版本不受影响，但如果要进行版本更新则需要进行适配。\n- **自生效期起，插件通过 wx.getUserInfo 接口获取用户昵称头像将被收回**：生效期后发布的插件新版本，通过 wx.getUserInfo 接口获取用户头像将统一返回默认[灰色头像](https://mmbiz.qpic.cn/mmbiz/icTdbqWNOwNRna42FI242Lcia07jQodd2FJGIYQfG0LAJGFxM4FbnQP6yfMxBgJ0F3YRqJCJ1aPAK2dQagdusBZg/0)，昵称将统一返回 “微信用户”。生效期前发布的插件版本不受影响，但如果要进行版本更新则需要进行适配。通过 wx.login 与 wx.getUserInfo 接口获取 openId、unionId 能力不受影响。\n- **「头像昵称填写能力」支持获取用户头像昵称**：如业务需获取用户头像昵称，可以使用「[头像昵称填写能力](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/userProfile.html)」（基础库 2.21.2 版本开始支持，覆盖iOS与安卓微信 8.0.16 以上版本），具体实践可见下方《最佳实践》。\n- **小程序 wx.getUserProfile 与插件 wx.getUserInfo 接口兼容基础库 2.27.1 以下版本的头像昵称获取需求**：对于来自低版本的基础库与微信客户端的访问，小程序通过 wx.getUserProfile 接口将正常返回用户头像昵称，插件通过 wx.getUserInfo 接口将正常返回用户头像昵称，开发者可继续使用以上能力做向下兼容。\n\n简而言之，就是getUserProfile和getUserInfo 都无法获取头像了，最开始从getUserInfo 改到getUserProfile，现在都不能用了，只能通过button组件来实现\n\n```html\n头像选择\n需要将 button 组件 open-type 的值设置为 chooseAvatar，当用户选择需要使用的头像之后，可以通过 bindchooseavatar 事件回调获取到头像信息的临时路径。\n\n从基础库2.24.4版本起，若用户上传的图片未通过安全监测，不触发bindchooseavatar 事件。\n```\n\n```html\n昵称填写\n需要将 input 组件 type 的值设置为 nickname，当用户在此input进行输入时，键盘上方会展示微信昵称。\n\n从基础库2.24.4版本起，在onBlur 事件触发时，微信将异步对用户输入的内容进行安全监测，若未通过安全监测，微信将清空用户输入的内容，建议开发者通过 form 中form-type 为submit 的button 组件收集用户输入的内容。\n```\n\n### 3.0登录需要注意的问题\n\n- js的对象类型比较是比较引用地址，而不是比较值，需要换成字符串进行比较;\n\n- 登录需要使用Uni.reLaunch,用来重新刷新页面\n\n  \n\n### 3.1音频接口\n\n```js\nconst changePlayTime = (e: any) => {\n \n  playState.value.current = e.detail.value;\n bgAudioManager.seek(e.detail.value);\n};\n```\n\nseek方法不能使用响应式数据","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/vue/uniapp/uniapp.md"}},{"pageContent":"# 这里是vue\n\n<v-app ></v-app>","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/webComponents/Vue.mdx"}},{"pageContent":"| 板u 7500f pxx套件        | 2000       |\n| ------------------------ | ---------- |\n| 7900xtx                  | 7500       |\n| 硬盘ssd 长城2t           | 700        |\n| 内存 6400 16*2           | 669        |\n| 先马黑钻石 1000w         | 500        |\n| cpu散热九州风神玄冰400V5 | 80         |\n| 机箱                     | ？？？     |\n|                          | ~ 11500 +? |\n\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/日常笔记/台式配置单.md"}},{"pageContent":"\n\n# js\n\n## 闭包\nECMAScript中，闭包指的是：\n\n1. 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。\n2. 从实践角度：以下函数才算是闭包：\n   1. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）\n   2. 在代码中引用了自由变量\n\n```js\nvar data = [];\n\nfor (var i = 0; i < 3; i++) {\n  data[i] = function () {\n    console.log(i);\n  };\n}\n\ndata[0]();//3\ndata[1]();//3\ndata[2]();//3\n```\njs是词名作用域，最后寻找也只会往最近的词法作用域寻找，所以i的值是3\n```js\nvar data = [];\n\nfor (var i = 0; i < 3; i++) {\n  data[i] = (function (i) {\n        return function(){\n            console.log(i);\n        }\n  })(i);\n}\n\ndata[0]();\ndata[1]();\ndata[2]();\n```\n\n\n\n## 变量\n\n当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。\n\n对于每个执行上下文，都有三个重要属性：\n\n* 变量对象(Variable object，VO)\n* 作用域链(Scope chain)\n* this\n\n> 全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。\n\n> 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。\n\n> 例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。\n\n### 函数上下文\n在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。\n\n活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。\n\n活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。\n\n### 执行上下文\n执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：\n\n1. 进入执行上下文\n2. 代码执行\n\n### 进入执行上下文\n当进入执行上下文时，这时候还没有执行代码，\n\n变量对象会包括：\n\n1. 函数的所有形参 (如果是函数上下文)\n\n   * 由名称和对应值组成的一个变量对象的属性被创建\n   * 没有实参，属性值设为 undefined\n2. 函数声明\n\n   * 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建\n   * 如果变量对象已经存在相同名称的属性，则完全替换这个属性\n3. 变量声明\n\n   * 由名称和对应值（undefined）组成一个变量对象的属性被创建；\n   * 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性\n ###  代码执行\n 在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值\n\n\n* 全局上下文的变量对象初始化是全局对象\n* 函数上下文的变量对象初始化只包括 Arguments 对象\n* 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值\n* 在代码执行阶段，会再次修改变量对象的属性值\n\n## 创建对象\n\n1. 工厂模式\n\n```js\nfunction createPerson(name) {\n    var o = new Object();\n    o.name = name;\n    o.getName = function () {\n        console.log(this.name);\n    };\n\n    return o;\n}\n\nvar person1 = createPerson('kevin');\n\n```\n缺点：对象无法识别，因为所有的实例都指向一个原型\n\n2. 构造函数模式\n\n```js\nfunction Person(name) {\n    this.name = name;\n    this.getName = function () {\n        console.log(this.name);\n    };\n}\n\nvar person1 = new Person('kevin');\n```\n优点：实例可以识别为一个特定的类型\n\n缺点：每次创建实例时，每个方法都要被创建一次\n\n3. 原型模式\n\n```js\nfunction Person(name) {\n\n}\n\nPerson.prototype = {\n    constructor: Person,\n    name: 'kevin',\n    getName: function () {\n        console.log(this.name);\n    }\n};\n\nvar person1 = new Person();\n```\n优点：实例可以通过constructor属性找到所属构造函数\n\n缺点：原型模式该有的缺点还是有\n\n4. 组合模式\n\n```js\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype = {\n    constructor: Person,\n    getName: function () {\n        console.log(this.name);\n    }\n};\n\nvar person1 = new Person();\n```\n优点：该共享的共享，该私有的私有，使用最广泛的方式\n\n缺点：有的人就是希望全部都写在一起，即更好的封装性\n\n5.  *动态原型模式*\n\n```js\nfunction Person(name) {\n    this.name = name;\n    if (typeof this.getName != \"function\") {\n        Person.prototype.getName = function () {\n            console.log(this.name);\n        }\n    }\n}\n\nvar person1 = new Person();\n```\n\n当第一个实例化的时候 他没有getName方法，所以会去原型上找，然后添加到原型上，当第二个实例化的时候，他有getName方法，所以不会去原型上找，直接使用自己的方法\n\n```js\nvar person1 = new Person('kevin');\nvar person2 = new Person('daisy');\n\n// 报错 并没有该方法\nperson1.getName();\n\n// 注释掉上面的代码，这句是可以执行的。\nperson2.getName();\n```\n第一个正是因为找不到才进入if进行创建 我们的this也是第一个this，这正是问题的由来\n\n*new的实现步骤*\n* 首先新建一个对象\n* 然后将对象的原型指向 Person.prototype\n* 然后 Person.apply(obj)\n* 返回这个对象\n\n如何解决？\n```js\nfunction Person(name) {\n    this.name = name;\n    if (typeof this.getName != \"function\") {\n        Person.prototype = {\n            constructor: Person,\n            getName: function () {\n                console.log(this.name);\n            }\n        }\n\n        return new Person(name);\n    }\n}\n\n```\n我们返回一个新对象，这个新对象的constructor是Person，然后我们再调用Person的构造函数，这样我们就可以避免重复创建方法\n\n### 稳妥构造函数模式\n```js\nfunction person(name){\n    var o = new Object();\n    o.sayName = function(){\n        console.log(name);\n    };\n    return o;\n}\n\nvar person1 = person('kevin');\n\nperson1.sayName(); // kevin\n\nperson1.name = \"daisy\";\n\nperson1.sayName(); // kevin\n\nconsole.log(person1.name); // daisy\n```\n所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。\n\n与寄生构造函数模式有两点不同：\n\n1. 新创建的实例方法不引用 this\n2. 不使用 new 操作符调用构造函数\n\n## JavaScript深入之词法作用域和动态作用域\n\n## 作用域\n\n作用域是指程序源代码中定义变量的区域。\n\n作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。\n\nJavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。\n\n## 静态作用域与动态作用域\n因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。\n\n而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。\n\n让我们认真看个例子就能明白之间的区别：\n\n```js\nvar value = 1;\n\nfunction foo() {\n    console.log(value);//1\n}\n\nfunction bar() {\n    var value = 2;\n    foo();\n}\n\nbar();\n\n```\n\n\n#### 思考\n有何异同\n\n```js\n\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f();\n}\ncheckscope();//\"local scope\"\n\n\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f;\n}\ncheckscope()();//\"local scope\"\n```\n\n## 执行上下文\n\n函数的变量提升\n```js\nfunction foo() {\n\n    console.log('foo1');\n\n}\n\nfoo();  // foo2\n\nfunction foo() {\n\n    console.log('foo2');\n\n}\n\nfoo(); // foo2\n```\n\n## 可执行代码\n可执行代码(executable code)的类型\n\n    1. 全局代码\n    2. 函数代码\n    3. eval代码\n### 执行上下文栈\n\nJavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文\n模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：\n```js\nvar ECStack = [];\n```\n\n试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以 ECStack 最底部永远有个 globalContext：\n\n```js\n\nECStack = [\n    globalContext\n];\n```\n\n```js\nfunction fun3() {\n    console.log('fun3')\n}\n\nfunction fun2() {\n    fun3();\n}\n\nfunction fun1() {\n    fun2();\n}\n\nfun1();\n```\n我们来看看是如何压进栈里的\n\n```js\n// 伪代码\n\n// fun1()\nECStack.push(<fun1> functionContext);\n\n// fun1中竟然调用了fun2，还要创建fun2的执行上下文\nECStack.push(<fun2> functionContext);\n\n// 擦，fun2还调用了fun3！\nECStack.push(<fun3> functionContext);\n\n// fun3执行完毕\nECStack.pop();\n\n// fun2执行完毕\nECStack.pop();\n\n// fun1执行完毕\nECStack.pop();\n\n// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext\n```\n\n#### 思考结果\n\n实际上是执行栈的不同\n\n```js\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f();\n}\ncheckscope();\n\n//模拟执行栈\nECStack.push(<checkscope> functionContext);\nECStack.push(<f> functionContext);\nECStack.pop();\nECStack.pop();\n\n```\n\n```js\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f;\n}\ncheckscope()();\n\n//模拟执行栈\nECStack.push(<checkscope> functionContext);\nECStack.pop();\nECStack.push(<f> functionContext);\nECStack.pop();\n\n```\n\n## 作用域链\n\n当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。\n\n### 函数创建\n函数的作用域在函数定义的时候就决定了。\n\n这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！\n\n```js\n\n \nfunction foo() {\n    function bar() {\n        ...\n    }\n}\n\n\nfoo.[[scope]] = [\n  globalContext.VO\n];\n\nbar.[[scope]] = [\n    fooContext.AO,\n    globalContext.VO\n];\n\n```\n\n函数的执行上下文就是如此生成的\n\n### 函数激活\n\n当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。\n\n我们命名为 Scope\n\n```js\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope2 = 'local scope';\n    return scope2;\n}\ncheckscope();\n```\n我们来分析流程\n\n1. checkscope 函数被创建，保存作用域链到 内部属性[[scope]]\n```js\n\ncheckscope.[[scope]] = [\n    globalContext.VO\n];\n\n```\n\n2. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈\n\n```js\nECStack = [\n    checkscopeContext,\n    globalContext\n];\n```\n3. checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链\n\n```js\ncheckscopeContext = {\n    Scope: checkscope.[[scope]],\n}\n```\n4. 第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明\n\n```js\ncheckscopeContext = {\n    AO: {\n        arguments: {\n            length: 0\n        },\n        scope2: undefined\n    }\n}\n```\n\n5.  第三步：将活动对象压入 checkscope 作用域链顶端\n```js\ncheckscopeContext = {\n    AO: {\n        arguments: {\n            length: 0\n        },\n        scope2: undefined\n    },\n    Scope: [AO, [[Scope]]]\n}\n```\n6. 准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值\n```js\ncheckscopeContext = {\n    AO: {\n        arguments: {\n            length: 0\n        },\n        scope2: 'local scope'\n    },\n    Scope: [AO, [[Scope]]]\n}\n```\n7. 查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出\n\n```js\nECStack = [\n    globalContext\n];\n```\n\n1. 创建函数,保存作用域链到内部属性[[scope]]\n\n2. 执行函数 创建执行上下文 压入上下文栈\n\n3. 复制函数[[scope]]属性创建作用域链\n\n4. 用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明\n\n5. 将活动对象压入 checkscope 作用域链顶端\n\n6. 准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值\n\n7. 查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出\n\n\n## 从ECMAScript规范解读this\n\n```js\nvar foo = 1;\n\n// 对应的Reference是：\nvar fooReference = {\n    base: EnvironmentRecord,\n    name: 'foo',\n    strict: false\n};\n```","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/朝花夕拾/js.mdx"}},{"pageContent":"import EventLoop from \"./js/eventloop\";\nimport AsyncPromise from \"./js/asyncPromise\";\n\n\n# 事件循环\n\n感谢阮一峰老师的教程 写的非常精髓 这里仅仅只做一个记录\n我会把我的理解用代码实现 \n我们先来看看这个例子 \n## Promise实现异步代码的同步执行\n<EventLoop />\n\n\n# 概念区域\n## 任务队列\n具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）\n\n（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\n\n（2）主线程之外，还存在一个\"任务队列\"（task queue）。只要异步任务有了运行结果，就在\"任务队列\"之中放置一个事件。\n\n（3）一旦\"执行栈\"中的所有同步任务执行完毕，系统就会读取\"任务队列\"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n\n（4）主线程不断重复上面的第三步。\n\n<img src=\"https://www.ruanyifeng.com/blogimg/asset/2014/bg2014100801.jpg\" />\n\n## 事件和回调函数\n\"任务队列\"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在\"任务队列\"中添加一个事件，表示相关的异步任务可以进入\"执行栈\"了。主线程读取\"任务队列\"，就是读取里面有哪些事件。\n\n\"任务队列\"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入\"任务队列\"，等待主线程读取。\n\n所谓\"回调函数\"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。\n\n\"任务队列\"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，\"任务队列\"上第一位的事件就自动进入主线程。但是，由于存在后文提到的\"定时器\"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。\n\n## Event Loop\n主线程从\"任务队列\"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。\n\n为了更好地理解Event Loop，请看下图（转引自Philip Roberts的演讲《Help, I'm stuck in an event-loop》）。\n\n<img src=\"https://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png\" />\n上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在\"任务队列\"中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取\"任务队列\"，依次执行那些事件所对应的回调函数。\n\n执行栈中的代码（同步任务），总是在读取\"任务队列\"（异步任务）之前执行。请看下面这个例子。\n```js\n   var req = new XMLHttpRequest();\n    req.open('GET', url);    \n    req.onload = function (){};    \n    req.onerror = function (){};    \n    req.send();\n```\n上面代码中的req.send方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取\"任务队列\"。所以，它与下面的写法等价。\n```js\n    var req = new XMLHttpRequest();\n    req.open('GET', url);\n    req.send();g\n    req.onload = function (){};    \n    req.onerror = function (){};   \n```\n也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取\"任务队列\"。\n\n## 定时器\n除了放置异步任务的事件，\"任务队列\"还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做\"定时器\"（timer）功能，也就是定时执行的代码。\n\n定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论setTimeout()。\n\nsetTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。\n```js\nconsole.log(1);\nsetTimeout(function(){console.log(2);},1000);\nconsole.log(3);\n```\n上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。\n\n如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。\n\n```js\nsetTimeout(function(){console.log(1);}, 0);\nconsole.log(2);\n```\n\n上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行\"任务队列\"中的回调函数。\n\n总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在\"任务队列\"的尾部添加一个事件，因此要等到同步任务和\"任务队列\"现有的事件都处理完，才会得到执行。\n\nHTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。\n\n需要注意的是，setTimeout()只是将事件插入了\"任务队列\"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/朝花夕拾/事件循环.mdx"}},{"pageContent":"test\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/课件/guid/html/test.md"}},{"pageContent":"这部分内容参考于 \n <a href=\"https://web.qianguyihao.com/#%E5%89%8D%E8%A8%80\">千古前端图文教程</a>\n\n <a href=\"https://github.com/qianguyihao/Web\">大家可以去给大佬点个start</a>\n\n其余的部分均为收集资料书写，参考资料比较多，就没有单独列出了\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/课件/guid/index.mdx"}},{"pageContent":"# VS Code\n\nVS Code 软件实在是太酷、太好用了，越来越多的新生代互联网民工正在使用它。\n\n前端男神**尤雨溪**大大这样评价 VS Code：\n\n![](http://img.smyhvae.com/20200619_0133.png)\n\n有一点你可能会感到惊讶：VS Code 这款软件本身，是用 JavaScript 语言编写的（具体请自行查阅基于 JS 的 PC 客户端开发框架 `Electron`）。Jeff Atwood 在 2007 年提出了著名的 Atwood 定律：\n\n> **任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现**。\n\nJeff Atwood 这个人是谁不重要（他是 Stack Overflow 网站的联合创始人），重要的是这条定律。\n\n前端目前是处在春秋战国时代，各路英雄豪杰成为后浪，各种框架工具层出不穷，VS Code 软件无疑是大前端时代最骄傲的工具。\n\n如果你是做前端开发（JavaScript 编程语言为主），则完全可以将 VS Code 作为「**主力开发工具**」。这款软件是为前端同学量身定制的，开箱即用。\n\n如果你是做其他语言方向的开发，并且不需要太复杂的集成开发环境，那么，你可以把 VS Code 作为「**代码编辑器**」来使用，纵享丝滑。\n\n甚至是一些写文档、写作的同学，也经常把 VS Code 作为 markdown **写作工具**，毫无违和感。\n\n退而求其次，即便你不属于以上任何范畴，你还可以把 VS Code 当作最简单的**文本编辑器**来使用，完胜 Windows 系统自带的记事本。\n\n写下这篇文章，是顺势而为。\n\n## 一、惊艳登场：VS Code 的介绍\n\nVS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做得很不错。\n\n微软有两种软件：一种是 VS Code，一种是其他软件。\n\n在2015年4月29日的微软Build开发者大会上，微软宣布推出 VS Code之后，这个轻量级的编辑器成为全球无数开发者们最喜爱的开发工具。VS Code基于开源且跨平台的理念，每月都会进行迭代，并提供每天发布的 insider 版本（insider是微软的一种公测计划，类似于国内软件所说的内测版）。它拥有至少几万个插件，生态极为活跃和丰富。\n\n### IDE 与 编辑器的对比\n\nIDE 和编辑器是有区别的：\n\n- **IDE**（Integrated Development Environment，集成开发环境）：对代码有较好的智能提示和相互跳转，同时侧重于工程项目，对项目的开发、调试工作有较好的图像化界面的支持，因此比较笨重。比如 Eclipse 的定位就是 IDE。\n- **编辑器**：要相对轻量许多，侧重于文本的编辑。比如 Sublime Text 的定位就是编辑器。再比如 Windows 系统自带的「记事本」就是最简单的编辑器。\n\n需要注意的是，VS Code 的定位是**编辑器**，而非 IDE ，但 VS Code 又比一般的编辑器的功能要丰富许多。可以这样理解：VS Code 的体量是介于编辑器和 IDE 之间。VS Code 的使命，是让开发者在编辑器里拥有 IDE 那样的开发体验。\n\nVS Code流行起来之后，使用 Sublime Text、Atom 这类编辑器软件的人，自然就越来越少了。\n\n### VS Code 的特点\n\n- 跨平台：支持 MacOS、Windows 和 Linux 等多个平台。在这多种平台下，拥有一致的用户界面和开发体验。\n- 开源：VS Code 的源代码以 MIT 协议开源。不仅代码开源，而且整个产品的开发计划和发布管理也都是开源的。VS Code团队每年都会在 GitHub 的Wiki上发布 [Roadmap](https://github.com/microsoft/vscode/wiki/Roadmap)，列出一整年的规划图。VS Code 软件的官方文档也托管在了 [GitHub](https://github.com/Microsoft/vscode-docs) 上。\n- 自带终端、图形化的调试工具、Git 版本控制。\n- 插件扩展：支持第三方插件，功能强大。既有中心化的插件市场，也可以直接在 VS Code里搜索你想要的插件。\n- 生态：社区生态活跃且丰富，社区氛围浓厚。\n- 自带 emmet：支持代码自动补全，快速生成简单的语法结构。要知道，这个功能在 Sublime Text中，得先安装插件才行。\n- 语法支持：VS Code 自带了 JavaScript、TypeScript 和 Node.js 的**语法支持**，包括：**语法高亮、代码智能提示和补全、括号匹配、颜色区分、代码片段提示**等。也就是说，你在书写 JS 和 TS 时，这些语法支持都是自带的。其他的一些语言，你需要先安装相应的**扩展包**插件，就出现语法支持。\n- 在修改配置方面，既有图形化的配置界面，也有 基于 JSON 文件的配置方式，满足不同人群的使用习惯。\n\n### 前端利器之争： VS Code 与 WebStorm\n\n前端小白最喜欢问的一个问题是：哪个编辑器/IDE 好用？是 VS Code 还是 WebStorm （WebStorm 其实是 IntelliJ IDEA 的定制版）？我来做个对比：\n\n- **哪个更酷**：显然 VS Code 更酷。\n- **内存占用情况**：根据我的观察，VS Code 是很占内存的（尤其是当你打开多个窗口的时候），但如果你的内存条够用，使用起来是不会有任何卡顿的感觉的。相比之下，IntelliJ IDEA 不仅非常占内存，而且还非常卡顿。如果你想换个既轻量级、又不占内存的编辑器，最好还是使用「Sublime Text」编辑器。\n- **使用比例**：当然是 VS Code 更胜一筹。先不说别的，我就拿数据说话，我目前所在的研发团队有 200 人左右（120个后台、80个前端），他们绝大部分人都在用 VS Code 编码，妥妥的。\n\n所以，如果你以后还问这个问题，那就真有些掉底了。\n\n### VS Code 的技术栈、核心组件\n\n了解 VS Code的技术栈和核心组件，可以让我们对 VS Code 有更深入的认识。此小段，了解即可。\n\n- 开发框架：Electron。Electron可以使用 Node.js + JS这样的技术栈开发桌面GUI应用程序。\n- 编辑器：Monaco Editor。Monaco Editor 是一款开源的在线代码编辑器，是 **VS Code 浏览器版本**的最核心组件。[#](https://zhuanlan.zhihu.com/p/88828576)\n- 编程语言：TypeScript。TypeScript 是 JavaScript的严格超集。TS 在JS的基础上添加了许多功能，引入了声明文件，而且支持类型扩展。TS 适合长期的、多人开发的大型项目开发。\n- 让编辑器支持语言功能：Language Server Protocol （LSP） 语言服务协议。LSP是编辑器/IDE 与语言服务器之间的一种协议，通过 JSON-PRC 传输消息，可以让编辑器嵌入并支持各种编程语言。开发者可以在编辑器中使用各种语言来编写程序。\n- 让编辑器支持调试功能：Debug Adapter Protocol（DAP）。DAP 是基于 JSON的协议，它抽象了开发工具与调试工具质检的通信。\n- 集成终端：Xterm.js。VS Code的集成终端是基于开源项目 [Xterm.js](https://github.com/xtermjs/xterm.js/) 进行开发的。Xterm.js 是一个使用 TS 开发的终端组件。另外，Xterm.js 并不是直接下来下来就能用的终端应用，它只是一个前端组件，可以与 bash这样的进程进行连接，然后让用户通过 Xterm.js 进行交互。\n\n### VS Code 的安装\n\n- VS Code 官网：[https://code.visualstudio.com](https://code.visualstudio.com)\n\nVS Code 的安装很简单，直接去官网下载安装包，然后双击安装即可。\n\n![](http://img.smyhvae.com/20190313_1750_3.png)\n\n上图中，直接点击 download，一键下载安装即可。\n\nVS Code支持以下平台：\n\n![](https://img.smyhvae.com/20210930_1930.png)\n\n安装完成后的界面如下：\n\n![](https://img.smyhvae.com/20211011_1703.png)\n\nVS Code被分为以下五个区域：\n\n- 编辑器\n- 侧边栏\n- 状态栏\n- 活动栏\n- 面板\n\nVS Code在功能上非常克制，只包含了大多数开发流程中所需要的基础模块，包括：编辑器、文件管理、窗口管理、首选项设置、终端等。\n\n你需要根据具体需要安装额外的组件或者插件。比如说，如果开发TS项目，则需要安装 TS编译器，以及ESLint、TSLint等语法规则&代码风格的检查工具。如果开发C语言项目，则需要安装gcc、Clang等编译工具。\n\n## 二、崭露锋芒：VS Code 快捷键\n\nVS Code 用得熟不熟，首先就看你是否会用快捷键。以下列出的内容，都是常用快捷键，而加粗部分的快捷键，使用频率则非常高。\n\n任何工具，掌握 20%的技能，足矣应对 80% 的工作。既然如此，你可能会问：那就只保留 20% 的特性，不久可以满足 80%的用户了吗？\n\n但我想说的是：**那从来都不是同样的 20%**，每个人都会用到不同的功能。\n\n掌握下面这些高频核心快捷键，你和你的工具，足矣露出锋芒。\n\n### 1、工作区快捷键\n\n| Mac 快捷键           | Win 快捷键               | 作用                                          | 备注                 |\n| :------------------- | :----------------------- | :-------------------------------------------- | :------------------- |\n| **Cmd + Shift + P**  | **Ctrl + Shift + P**，F1 | 显示命令面板                                  |                      |\n| **Cmd + B**          | **Ctrl + B**             | 显示/隐藏侧边栏                               | 很实用               |\n| `Cmd + \\`            | `Ctrl + \\`               | **拆分为多个编辑器**                          | 【重要】抄代码利器   |\n| **Cmd + 1、2**       | **Ctrl + 1、2**          | 聚焦到第 1、第 2 个编辑器                     | 同上重要             |\n| **Cmd + +、Cmd + -** | **ctrl + +、ctrl + -**   | 将工作区放大/缩小（包括代码字体、左侧导航栏） | 在投影仪场景经常用到 |\n| Cmd + J              | Ctrl + J                 | 显示/隐藏控制台                               |                      |\n| **Cmd + Shift + N**  | **Ctrl + Shift + N**     | 重新开一个软件的窗口                          | 很常用               |\n| Cmd + Shift + W      | Ctrl + Shift + W         | 关闭软件的当前窗口                            |                      |\n| Cmd + N              | Ctrl + N                 | 新建文件                                      |                      |\n| Cmd + W              | Ctrl + W                 | 关闭当前文件                                  |                      |\n\n### 2、跳转操作\n\n| Mac 快捷键                    | Win 快捷键             | 作用                                                   | 备注               |\n| :---------------------------- | :--------------------- | :----------------------------------------------------- | :----------------- |\n| Cmd + `                       | 没有                   | 在同一个软件的**多个工作区**之间切换                   | 使用很频繁         |\n| **Cmd + Option + 左右方向键** | Ctrl + Pagedown/Pageup | 在已经打开的**多个文件**之间进行切换                   | 非常实用           |\n| Ctrl + Tab                    | Ctrl + Tab             | 在已经打开的多个文件之间进行跳转                       | 不如上面的快捷键快 |\n| Cmd + Shift + O               | Ctrl + shift + O       | 在当前文件的各种**方法之间**（符号：Symbol）进行跳转   |                    |\n| Cmd + T                       | Ctrl + T               | 在当前**工作区**的各种方法之间（符号：Symbol）进行跳转 |                    |\n| Ctrl + G                      | Ctrl + G               | 跳转到指定行                                           |                    |\n| `Cmd+Shift+\\`                 | `Ctrl+Shift+\\`         | 跳转到匹配的括号                                       |                    |\n\n### 3、移动光标\n\n| Mac 快捷键                    | Win 快捷键                                 | 作用                                                         | 备注           |\n| :---------------------------- | :----------------------------------------- | :----------------------------------------------------------- | :------------- |\n| 方向键                        | 方向键                                     | 在**单个字符**之间移动光标                                   | 大家都知道     |\n| **option + 左右方向键**       | **Ctrl + 左右方向键**                      | 在**单词**之间移动光标                                       | 很常用         |\n| **Cmd + 左右方向键**          | **Fn + 左右方向键**（或 Win + 左右方向键） | 将光标定位到当前行的最左侧、最右侧（在**整行**之间移动光标） | 很常用         |\n| **Option + Alt + 左右方向键** | **Alt + Shift + 左右方向键**               | 左右扩大/缩小选中的范围                                      | 很酷，极为高效 |\n| Cmd + ↑                       | Ctrl + Home                                | 将光标定位到文件的第一行                                     |                |\n| Cmd + ↓                       | Ctrl + End                                 | 将光标定位到文件的最后一行                                   |                |\n| Cmd + Shift + \\               |                                            | 在**代码块**之间移动光标                                     |                |\n\n### 4、编辑操作\n\n| Mac 快捷键             | Win 快捷键          | 作用                                 | 备注                                   |\n| :--------------------- | :------------------ | :----------------------------------- | :------------------------------------- |\n| Cmd + C                | Ctrl + C            | 复制                                 |                                        |\n| Cmd + X                | Ctrl + X            | 剪切                                 |                                        |\n| Cmd + V                | Ctrl + V            | 粘贴                                 |                                        |\n| **Cmd + Enter**        | **Ctrl + Enter**    | 在当前行的下方新增一行，然后跳至该行 | 即使光标不在行尾，也能快速向下插入一行 |\n| Cmd+Shift+Enter        | Ctrl+Shift+Enter    | 在当前行的上方新增一行，然后跳至该行 | 即使光标不在行尾，也能快速向上插入一行 |\n| **Option + ↑**         | **Alt + ↑**         | 将代码向上移动                       | 很常用                                 |\n| **Option + ↓**         | **Alt + ↓**         | 将代码向下移动                       | 很常用                                 |\n| Option + Shift + ↑     | Alt + Shift + ↑     | 将代码向上复制一行                   |                                        |\n| **Option + Shift + ↓** | **Alt + Shift + ↓** | 将代码向下复制一行                   | 写重复代码的利器                       |\n\n另外再补充一点：将光标点击到某一行的任意位置时，默认就已经是**选中全行**了，此时可以直接**复制**或**剪切**，无需点击鼠标。这个非常实用，是所有的编辑操作中，使用得最频繁的。它可以有以下使用场景：\n\n- 场景1：假设光标现在处于第5行的**任意位置**，那么，直接依次按下 `Cmd + C` 和 `Cmd + V`，就会把这行代码复制到第6行。继续按 `Cmd + C` 和 `Cmd + V`，就会把这行代码复制到第7行。copy代码so easy。\n- 场景2：假设光标现在处于第5行，那么，先按下 `Cmd + C`，然后按两下 `↑` 方向键，此时光标处于第3行；紧接着，继续按下 `Cmd + V`，就会把刚刚那行代码复制到第3行，原本处于第3行的代码会整体**下移**。\n\n你看到了没？上面的两个场景，我全程没有使用鼠标，只通过简单的复制粘贴和方向键，就做到了如此迅速的copy代码。你说是不是很高效？\n\n### 5、删除操作\n\n| Mac 快捷键             | Win 快捷键           | 作用                   | 备注                                      |\n| :--------------------- | :------------------- | :--------------------- | :---------------------------------------- |\n| Cmd + shift + K        | Ctrl + Shift + K     | 删除整行               | 「Cmd + X」的作用是剪切，但也可以删除整行 |\n| **option + Backspace** | **Ctrl + Backspace** | 删除光标之前的一个单词 | 英文有效，很常用                          |\n| option + delete        | Ctrl + delete        | 删除光标之后的一个单词 |                                           |\n| **Cmd + Backspace**    |                      | 删除光标之前的整行内容 | 很常用                                    |\n| Cmd + delete           |                      | 删除光标之后的整行内容 |                                           |\n\n备注：上面所讲到的移动光标、编辑操作、删除操作的快捷键，在其他编辑器里，大部分都适用。\n\n### 6、多光标选择/多光标编辑\n\n多光标选择在编程的**提效**方面可谓立下了汗马功劳。因为比较难记住，所以你要时不时回来复习这一段。\n\n| Mac 快捷键                        | Win 快捷键                     | 作用                                                                                                                | 备注                                     |\n| --------------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------- | ---------------------------------------- |\n| **Option + 鼠标连续点击任意位置** | **Alt + 鼠标连续点击任意位置** | 在任意位置，同时出现多个光标                                                                                        | 很容易记住                               |\n| Cmd + D                           | Ctrl + D                       | 将光标放在某个单词的位置（或者先选中某个单词），然后反复按下「**Cmd + D** 」键， 即可将下一个相同的词逐一加入选择。 | 较常用                                   |\n| **Cmd + Shift + L**               | **Ctrl + Shift + L**           | 将光标放在某个单词的位置（或者先选中某个单词），然后按下快捷键，则所有的相同内容处，都会出现光标。                  | 很常用。比如变量重命名的时候，就经常用到 |\n\n### 7、多列选择/多列编辑\n\n多列选择是更高效的多光标选择，所以单独列成一小段。\n\n| Mac 快捷键                | Win 快捷键             | 作用                                                                                   | 备注                 |\n| ------------------------- | ---------------------- | -------------------------------------------------------------------------------------- | -------------------- |\n| Cmd + Option + 上下键     | Ctrl + Alt + 上下键    | 在连续的多列上，同时出现多个光标                                                       | 较常用               |\n| Option + Shift + 鼠标拖动 | Alt + Shift + 鼠标拖动 | 按住快捷键，然后把鼠标从区域的左上角拖至右下角，即可在选中区域的每一行末尾，出现光标。 | 很神奇的操作，较常用 |\n| **Option + Shift + i**    | **Alt + Shift + I**    | 选中一堆文本后，按下快捷键，既可在**每一行的末尾**都出现一个光标。                     | 很常用               |\n\n### 8、编程语言相关\n\n| Mac 快捷键             | Win 快捷键      | 作用                         | 备注                             |\n| :--------------------- | :-------------- | :--------------------------- | :------------------------------- |\n| Cmd + /                | Ctrl + /        | 添加单行注释                 | 很常用                           |\n| **Option + Shift + F** | Alt + shift + F | 代码格式化                   | 很常用                           |\n| F2                     | F2              | 以重构的方式进行**重命名**   | 改代码备                         |\n| Ctrl + J               |                 | 将多行代码合并为一行         | Win 用户可在命令面板搜索”合并行“ |\n| Cmd +                  |                 |                              |                                  |\n| Cmd + U                | Ctrl + U        | 将光标的移动回退到上一个位置 | 撤销光标的移动和选择             |\n\n### 9、搜索相关\n\n| Mac 快捷键          | Win 快捷键          | 作用                                       | 备注   |\n| :------------------ | :------------------ | :----------------------------------------- | :----- |\n| **Cmd + Shift + F** | **Ctrl + Shift +F** | 全局搜索代码                               | 很常用 |\n| **Cmd + P**         | **Ctrl + P**        | 在当前的项目工程里，**全局**搜索文件名     |        |\n| Cmd + F             | Ctrl + F            | 在当前文件中搜索代码，光标在搜索框里       |        |\n| **Cmd + G**         | **F3**              | 在当前文件中搜索代码，光标仍停留在编辑器里 | 很巧妙 |\n\n### 10、自定义快捷键\n\n按住快捷键「Cmd + Shift + P」，弹出命令面板，在命令面板中输入“快捷键”，可以进入快捷键的设置。\n\n当然，你也可以选择菜单栏「偏好设置 --> 键盘快捷方式」，进入快捷键的设置：\n\n![](http://img.smyhvae.com/20190329_2120.png)\n\n此外，如果你输入这个快捷键后没起作用，那有可能是与其他软件（比如 PicGo 软件）的快捷键冲突了，请检查一下。\n\n### 11、快捷键列表\n\n你可以点击 VS Code 左下角的齿轮按钮，效果如下：\n\n![](http://img.smyhvae.com/20190418_1738.png)\n\n上图中，在展开的菜单中选择「键盘快捷方式」，就可以查看和修改所有的快捷键列表了：\n\n![](http://img.smyhvae.com/20190418_1739_2.png)\n\n### 快捷键参考表（官方）\n\nVS Code官网提供了 PDF版本的键盘快捷键参考表，转需：\n\n- Windows版本：https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf\n- Mac 版本：https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf\n- Linux版本：https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf\n\n我们在 VS Code软件里通过菜单栏「帮助-->键盘快捷方式参考」也可以打开相应平台的快捷键大全（PDF版本）。\n\n## 三、高端访问：命令面板的使用\n\nMac 用户按住快捷键 `Cmd+Shift+P` （Windows 用户按住快捷键 `Ctrl+Shift+P`），可以打开快速命令面板。效果如下：\n\n![](http://img.smyhvae.com/20190329_1750_2.png)\n\n命令面板的作用是**希望解放开发者的鼠标，让一些操作和配置可以直接通过键盘进行**。如果让开发者记住所有的配置项在菜单的哪个位置是不现实的，而且有些命令并不在菜单中。\n\n有了命令面板之后，如果你需要修改一些设置项，或者进行一些快捷操作，则可以通过「命令面板」来操作，效率会更高。接下来列举一些。\n\n### 1、VS Code 设置为中文语言\n\nMac 用户按住快捷键 `Cmd+Shift+P` （Windows 用户按住快捷键 `Ctrl+Shift+P`），打开命令面板。\n\n在命令面板中，输入 `Configure Display Language`，选择 `Install additional languages`，然后安装插件 `Chinese (Simplified) Language Pack for Visual Studio Code`即可。\n\n或者，我们可以直接安装插件 `Chinese (Simplified) Language Pack for Visual Studio Code`，是一样的。\n\n安装完成后，重启 VS Code。\n\n### 2、设置字体大小\n\n在命令面板输入“字体”，可以进行字体的设置，效果如下：\n\n![](http://img.smyhvae.com/20190329_2110.png)\n\n当然，你也可以在菜单栏，选择「首选项-设置-常用设置」，在这个设置项里修改字体大小。\n\n### 3、快捷键设置\n\n在命令面板输入“快捷键”，就可以进入快捷键的设置。\n\n### 4、大小写转换\n\n选中文本后，在命令面板中输入 `transfrom`，就可以修改文本的大小写了。\n\n![](http://img.smyhvae.com/20190414_1751.png)\n\n### 5、使用命令行启动 VS Code\n\n（1）输入快捷键「Cmd + Shift + P 」，选择 `install code command`：\n\n![](http://img.smyhvae.com/20191103_1327.png)\n\n（2）使用命令行：\n\n- `code`命令：启动 VS Code 软件\n- `code pathName/fileName`命令：通过 VS Code 软件打开指定目录/指定文件。\n\n备注：这种方法快捷简单，但是在电脑重启之后就失效了。稍后在第五段，我会介绍更常见的方法。\n\n### 6、修改特定编程语言的设置项\n\n输入快捷键「Cmd + Shift + P 」打开命令面板，然后输入并执行 `Configure Language Specific Settings`即可。\n\n![](https://img.smyhvae.com/20211012_1039.png)\n\n## 四、私人订制：VS Code 的常见配置\n\n### 0、设置项介绍\n\n在修改 VS Code配置之前，我们需要知道，在哪里可以找到设置项的入口。\n\n**方式1**：Mac用户选择菜单栏「Code--> 首选项-->设置」，即可打开配置项：\n\n![](http://img.smyhvae.com/20210930_2009.png)\n\n**方式2**：点击软件右下角的设置图标：\n\n![](http://img.smyhvae.com/20210930_2016.png)\n\n![](https://img.smyhvae.com/20211012_1017.png)\n\n如上图所示，VS Code提供两种不同范围的设置：\n\n- **用户**设置：全局生效。\n- **工作区**设置：只针对当前项目生效。工作区设置会覆盖用户设置。适用于团队协作场景。工作区的设置文件是保存在当前项目根目录的 `.vscode/settings.json`中，可以被提交到Git仓库，方便共享给项目组的其他成员。\n\n操作技巧：\n\n（1）我们可以在设置面板的顶部搜索框，输入关键词，就能迅速定位到你想要的设置项。\n\n（2）上图中，点击右上角的icon，可以通过 json文件的形式修改设置项。\n\n### 1、修改主题\n\n1）修改颜色主题：\n\n选择菜单栏「Code --> 首选项 --> 颜色主题」：\n\n![](http://img.smyhvae.com/20210930_2017.png)\n\n在弹出的对话框中，挑选你一个你喜欢的的颜色主题吧，或者安装其他颜色的主题：\n\n![20211013_1018](http://img.smyhvae.com/20211013_1018.png)\n\n或者在设置项里搜索 `Workbench: Color Theme`，进行修改。\n\n2）修改文件图标的主题：\n\n选择菜单栏「Code --> 首选项 --> 文件图标主题」：\n\n![20211013_1015](http://img.smyhvae.com/20211013_1015.png)\n\n在弹出的对话框中，挑选你一个你喜欢的的主题吧，或者安装其他的主题：\n\n![20211013_1019](http://img.smyhvae.com/20211013_1019.png)\n\n或者在设置项里搜索 `Workbench: Icon Theme`，进行修改。\n\n### 2、面包屑（Breadcrumb）导航\n\n打开 VS Code 的设置项，选择「用户设置 -> 工作台 -> 导航路径」，如下图所示：\n\n![](http://img.smyhvae.com/20191108_1550.png)\n\n上图中，将红框部分打钩即可。\n\n设置成功后，我们就可以查看到当前文件的「层级结构」，非常方便。如下图所示：\n\n![](http://img.smyhvae.com/20190415_2009.png)\n\n有了这个面包屑导航，我们可以点击它，在任意目录、任意文件之间随意跳转。使用频繁非常高。\n\n### 3、是否显示代码的行号\n\nVS Code 默认显示代码的行号。你可以在设置项里搜索 `editor.lineNumbers`修改设置，配置项如下：\n\n![](http://img.smyhvae.com/20190417_2140.png)\n\n我建议保留这个设置项，无需修改。\n\n### 4、右侧是否显示代码的缩略图\n\n如果某个文件的代码量很大，缩略图就很有用了，可以预览全局，并在当前文件中快速跳转。\n\nVS Code 会在代码的右侧，默认显示缩略图。你可以在设置项里搜索 `editor.minimap` 进行设置，配置项如下：\n\n![](http://img.smyhvae.com/20211012_1507.png)\n\n上面这张图，你仔细琢磨下会发现，中文翻译十分精准。\n\n### 5、将当前行代码高亮显示（更改光标所在行的背景色）\n\n当我们把光标放在某一行时，这一行的背景色并没有发生变化。如果想**高亮显示**当前行的代码，需要设置两步：\n\n（1）在设置项里搜索 `editor.renderLineHighlight`，将选项值设置为 `all`或者 `line`。\n\n（2）在设置项里增加如下内容：\n\n```json\n\"workbench.colorCustomizations\": {\n    \"editor.lineHighlightBackground\": \"#00000090\",\n    \"editor.lineHighlightBorder\": \"#ffffff30\"\n}\n```\n\n上方代码，第一行代码的意思是：修改光标所在行的背景色（背景色设置为全黑，不透明度 90%）；第二行代码的意思是：修改光标所在行的边框色。\n\n### 6、改完代码后立即自动保存\n\n**方式一**：\n\n改完代码后，默认不会自动保存。你可以在设置项里搜索 `files.autoSave`，修改参数值为 `afterDelay` ，即可自动保存。如下：\n\n![](https://img.smyhvae.com/20211012_2000.png)\n\nfiles.autoSave的参数值有以下几种：\n\n- off（默认值）：不自动保存。\n- afterDelay（建议配置）：文件修改超过一定时间（默认1秒）后，就自动保存。\n- onFocusChange：当前编辑器失去焦点时，则自动保存。如果我们将配置项修改为 `onFocusChange`之后，那么，当光标离开该文件后，这个文件就会自动保存了。\n- onWindowChange：VS Code软件失去焦点时，则自动保存。\n\n**方式二**：\n\n当然，你也可以直接在菜单栏选择「文件-自动保存」。勾选后，当你写完代码后，文件会立即实时保存。\n\n### 7、热退出\n\n当VS Code退出后，它可以记住未保存的文件。如果你希望达到这种效果，那么，你需要先将设置项 `files.hotExit`的值改为 `onExitAndWindowClose`。这个配置项要不要改，看你个人需要。比如我自己平时设置的值是 `onExit`。\n\n![20211012_2014](http://img.smyhvae.com/20211012_2014.png)\n\n### 8、保存代码后，是否立即格式化\n\n保存代码后，默认**不会立即**进行代码的格式化。你可以在设置项里搜索 `editor.formatOnSave`查看该配置项：\n\n![](http://img.smyhvae.com/20190417_2213.png)\n\n我觉得这个配置项保持默认就好，不用打钩。\n\n### 9、自动格式化粘贴的内容\n\n在设置项里搜索 `editor.formatOnPaste`，将设置项改为 `true`：\n\n![20211012_1049](https://img.smyhvae.com/20211012_1049.png)\n\n### 10、设置字体大小\n\n在设置项里搜索 `fontSize`，然后根据需要设置各种模块的字体大小：\n\n![20211012_1053](http://img.smyhvae.com/20211012_1053.png)\n\n### 11、空格 or 制表符\n\nVS Code 会根据你所打开的文件来决定该使用空格还是制表。也就是说，如果你的项目中使用的都是制表符，那么，当你在写新的代码时，按下 tab 键后，编辑器就会识别成制表符。\n\n（1）建议的设置项如下：\n\n- **editor.detectIndentation**：自动检测（默认开启）。建议把这个配置项修改为 false，截图如下：\n\n![20211012_1139](https://img.smyhvae.com/20211012_1139.png)\n\n这样做，是为了取消系统的自动缩进，建议自己手动格式化比较好。 参考链接：https://www.yisu.com/zixun/327399.html\n\n- **editor.insertSpaces**：按 Tab 键时插入空格（默认值为true）。截图如下：\n\n![](http://img.smyhvae.com/20190417_2207.png)\n\n- **editor.tabSize**：一个制表符默认等于四个空格。截图如下：\n\n![](http://img.smyhvae.com/20190417_2209.png)\n\n（2）状态栏也会显示当前的缩进值。点击状态栏，可以直接修改 tabSize 缩进值：\n\n![](http://img.smyhvae.com/20211009_1610.png)\n\n（3）另外，我们还可以安装 prettier 插件，设置代码在格式化时默认缩进值。prettier 是做代码格式化的最常见工具。\n\n![](https://img.smyhvae.com/20211009_1637.png)\n\n（4）去掉每一行末尾的空格。在设置项里搜索 `空格`或者 `\"files.trimTrailingWhitespace\"`，将值设置为 true：\n\n![20211012_1231](http://img.smyhvae.com/20211012_1231.png)\n\n一般来说，每一行代码末尾的空格是多余的，所以建议去掉。\n\n### 12、直观地显示代码里的空格和缩进 ✨\n\n代码里如果有缩进或者空格，肉眼是看不出来的，但是我们可以修改配置项，把它揪出来。\n\n在配置项里搜索 `editor.renderWhitespace`，修改为 `all`：\n\n![20211012_1150](http://img.smyhvae.com/20211012_1150.png)\n\n修改之后，代码里的空格、缩进的展示效果如下：\n\n![20211012_1258](http://img.smyhvae.com/20211012_1258.png)\n\n看到了没？哪里有空格、哪里是缩进，全都一目了然。\n\n### 13、新建文件后的默认文件类型\n\n当我们按下快捷键「Cmd + N」新建文件时，VS Code 默认无法识别这个文件到底是什么类型的，因此也就无法识别相应的语法高亮。\n\n如果你想修改默认的文件类型，可以在设置项里搜索 `files.defaultLanguage`，设置项如下：\n\n![](http://img.smyhvae.com/20190417_2221.png)\n\n上图中的红框部分，填入你期望的默认文件类型。我填的是 `html`类型，你也可以填写成 `javascript` 或者 `markdown`，或者其他的语言类型。\n\n### 14、删除文件时，是否弹出确认框\n\n当我们在 VS Code 中删除文件时，默认会弹出确认框。如果你想修改设置，可以在设置项里搜索 `xplorer.confirmDelete`。截图如下：\n\n![](http://img.smyhvae.com/20190418_1758.png)\n\n我建议这个设置项保持默认的打钩就好，不用修改。删除文件前的弹窗提示，也是为了安全考虑，万一手贱不小心删了呢？\n\n### 15、在新窗口打开文件/文件夹\n\n通过 `window.openFoldersInNewWindow`（默认值为off）和 `window.openFilesInNewWindow`（默认值为default），可以配置在打开文件夹、打开文件时，是否开启一个新的窗口。我个人建议，把这两个配置项都设置为 on，避免旧的窗口被覆盖：\n\n![](http://img.smyhvae.com/20211012_1700.png)\n\n补充知识—— `window.restoreWindows`可以用来配置 如何恢复之前的会话窗口。涉及到的场景是：你把 VS Code 关闭了，然后又打开了，是否要展示之前打开过的文件、文件夹？参数值有以下几种：\n\n- one（默认配置）：只会重新打开上一次回话中最后操作的那一个窗口。\n- none：打开一个空的窗口，不包含任何文件、文件夹。\n- all（建议配置）：恢复上一次会话中的所有窗口。\n- folders：恢复上一次会话中包含文件夹的窗口。\n\n![20211012_1704](http://img.smyhvae.com/20211012_1704.png)\n\n### 16、自动删除行尾的空格\n\n打开设置项，搜索 `files.trimTrailingWhitespace`，将选项勾选，即可在保存文件时自动删除行尾的空格。\n\n### 17、突出显示成对的括号\n\n我们可以用不同颜色显示代码中成对的括号，并用连线标注括号范围。简称**彩虹括号**。\n\n最早是通过 `Bracket Pair Colorizer 2`插件支持的，但是这个插件已经被废弃了，因为 VS Code 已经内置了该功能。我们可以通过 VS Code的如下配置项，达到效果：\n\n```json\n{\n  \"editor.bracketPairColorization.enabled\": true,\n  \"editor.guides.bracketPairs\": \"active\"\n}\n```\n\n### 18、自动换行\n\n自动换行：意味着当文本到达屏幕或页面的右边缘时，自动换行会将文本移到下一行，以便继续输入或显示。\n\n打开设置项，搜索 `Editor:Word Wrap`，将选项值设置为 on。\n\n此外，你还可以选择菜单栏 `查看-->自动换行`，即可将当前文件设置为自动换行。\n\n> 接下来，我们来讲一些更高级的操作。\n\n## 五、纵享丝滑：常见操作和使用技巧\n\n### 1、快速生成HTML骨架\n\n先新建一个空的html文件，然后通过以下方式，可以快速生成html骨架。\n\n**方式1**：输入 `!`，然后按下 `enter`键，即可生成html骨架。如下图：\n\n![](https://img.smyhvae.com/20210623-2115.gif)\n\n**方式2**：输入 `html:5`，然后按住 `Tab`键，即可生成html骨架。\n\n生成的骨架，内容如下：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n```\n\n有了上面的html骨架之后，我们就可以快乐地在里面插入CSS 代码和 JS 代码。\n\n### 2、并排编辑：左右（上下）显示多个编辑器窗口（copy代码利器）\n\n> 并排编辑是所有的编辑操作中最常用的一个技巧，十分有用。比如我们在开发一个项目时，可能需要同时打开 HTML 文件和 CSS 文件，很常见。\n\nMac 用户按住快捷键 `Cmd + \\`， Windows 用户按住快捷键 `Ctrl + \\`，即可同时打开多个编辑器窗口，进行并排编辑。效果如下：\n\n![](http://img.smyhvae.com/20200619_0030.gif)\n\n按快捷键「Cmd + 1 」切换到左边的窗口，按快捷键「Cmd + 2 」切换到右边的窗口，以此类推。随时随地，想切就切。\n\n学会了这一招，以后 copy 代码的时候，leader 再也不用担心我抄得慢了，一天工资到手。\n\n---\n\n当然，使用快捷键 `Cmd + \\`只是其中一种方式，我们还有很多种方式打开并行编辑。我们来做一个汇总。\n\n如果你已经打开了一个编辑器，那么可以通过以下几种方式在另一侧打开另一个编辑器：（按照使用频率，从高到低排序）\n\n- 使用快捷键 `Cmd + \\`将编辑器一分为二。\n- 使用快捷键 `Cmd + P`调出文件列表，选择要打开的文件，然后按下 `Cmd + Enter`快捷键。【重要】\n- 按住 Option 键的同时，单击资源管理器的文件（Windows 用户是按 Alt 键）。\n- 点击编辑器右上角的 `Split Editor`按钮。\n- 选择菜单栏「查看--> 编辑器布局」，然后选择你具体想要的布局，如下图所示：\n\n![20211012_1451](http://img.smyhvae.com/20211012_1451.png)\n\n- 通过拖拽，把当前文件移动到任意一侧。\n\n补充知识：通过配置项 `worbench.editor.OpenSideBySideDirection`可以控制编辑器在并排打开时出现的默认位置（默认值为right，你也可以根据需要改为 down）。如下图所示：\n\n![20211012_1455](http://img.smyhvae.com/20211012_1455.png)\n\n### 3、从终端 code 命令启动 VS Code（Mac电脑）\n\n在终端输入 `code`或者输入 `code + 指定项目的目录`，就可以启动 VS Code，十分便捷。即：\n\n- `code` 命令：启动 VS Code 软件。\n- `code pathName/fileName` 命令：通过 VS Code 软件打开指定目录/指定文件。\n\n为了达到目的，我们需要先将 VS Code的软件安装路径添加到环境变量，一劳永逸。具体操作如下：\n\n（1）打开 `bash_profile`文件：\n\n```bash\ncd ~\nvim ./bash_profile\n```\n\n（2）在 bash_profile 中添加如下内容：\n\n```bash\n# 从终端启动VS Code，并设置vscode启动的命令别名\nalias code=\"/Applications/Visual\\ Studio\\ Code.app/Contents/Resources/app/bin/code\"\n```\n\n注意，由于 `Visual Studio Code.app`这个路径里有空格，所以需要在空格前面加上反斜杠 `\\`。\n\n（3）重启环境变量的配置：\n\n```\n# 重启\nsource ~/.bash_profile\n```\n\n大功告成。\n\n改完之后，如果没生效，那你把 `bash_profile`文件 换成 `zshrc`文件试试。\n\n参考链接：\n\n- [mac通过终端code 命令打开vscode](https://blog.csdn.net/logan_LG/article/details/106800904)\n\n当然，还可以通过命令面板，一键设置环境变量。具体做法是：输入快捷键「Cmd + shift + P」打开命令面板，然后选择 `shell 命令：从 PATH 中卸载 “code”命令`：\n\n![](https://img.smyhvae.com/202310201605408.png)\n\n完成后就可以在终端输入命令+文件路径来启动 VS Code 了。\n\n### 3、从终端 code 命令启动 VS Code（Windows电脑）\n\n在终端输入 `code`或者输入 `code + 指定项目的目录`，就可以启动 VS Code，十分便捷。即：\n\n- `code` 命令：启动 VS Code 软件。\n- `code pathName/fileName` 命令：通过 VS Code 软件打开指定目录/指定文件。\n\n为了达到目的，我们需要先将 VS Code的软件安装路径添加到环境变量，一劳永逸。具体操作如下：\n\n（1）打开 VS Code 的安装位置，进入bin文件夹，复制路径。比如：`D:\\Microsoft VS Code\\bin`。\n\n（2）回到桌面，右键我的电脑-->高级系统设置-->环境变量-->编辑path值，在原来的path后面，追加内容 `;D:\\Microsoft VS Code\\bin`（即英文的分号+VS Code 的 bin 路径)\n\n（3）重启电脑，大功告成。\n\n改完之后，如果没生效，那八成是因为你填的 path 值有问题。\n\n参考链接：\n\n- [windows使用 code . 命令打开vscode](https://www.cnblogs.com/zyl-Tara/p/10642704.html)\n\n### 4、在当前文件中搜索\n\n在上面的快捷键列表中，我们已经知道如下快捷键：\n\n- Cmd + F（Win 用户是 Ctrl + F）：在当前文件中搜索，光标在搜索框里\n- Cmd + G（Win 用户是 F3）：在当前文件中搜索，光标仍停留在编辑器里\n\n多个搜索结果出来之后，按下 Enter 键之后跳转到下一个搜索结果，按下 Shift + Enter 键之后跳转到上一个搜索结果。\n\n另外，你可能会注意到，搜索框里有很多按钮，每个按钮都对应着不同的功能，如下图所示：\n\n![](http://img.smyhvae.com/20190415_2052.png)\n\n上图中，你可以通过「Tab」键和「Shift + Tab」键在输入框和替换框之间进行切换。\n\n「在选定内容中查找」这个功能还是比较实用的。你也可以在设置项里搜索 `editor.find.autoFindInSelection`，勾选该设置项后，那么，当你选中指定内容后，然后按住「Cmd + F」，就可以**自动**只在这些内容里进行查找。该设置项如下图所示：\n\n![](http://img.smyhvae.com/20191108_1655.png)\n\n### 5、全局搜索\n\n在上面的快捷键列表中，我们已经知道如下快捷键：\n\n- Cmd + Shift + F（Win 用户是 Ctrl + Shift +F）：在全局的文件夹中进行搜索。效果如下：\n\n![20211012_1548](http://img.smyhvae.com/20211012_1548.png)\n\n上图中，你可以点击**红框**部分，展开更多的配置项。然后点击**红圈**部分，进行过滤搜索。注意，第二个红圈那里会经常用到，它可以在搜索时过滤掉 `.git`、`.node_modules`等忽略文件。\n\n上图中，我们还可以点击“在编辑器中打开”，在一个单独的文件中聚合展示搜索结果：\n\n![](https://img.smyhvae.com/20211012_1609.png)\n\n### 6、文件名/文件夹的搜索\n\n前面的快捷键那一段我们讲过，通过 「Cmd + P」可以快速搜索并打开**文件**/文件夹。这种方式，一般用于快速打开最近编辑过的文件。\n\n其实还有一种很巧妙的方式，可以在整个项目里，既能搜到文件，也能搜到**文件夹**。这种方式，常用于**过滤项目的目录**。操作方法很简单：\n\n> 直接在文件资源管理器输入关键字就行。搜索结果会自动出现；使用方向键进行上下移动，可以在搜索的文件和文件夹之间进行跳转。\n>\n> 另外，右上角会看到一个过滤器，点击下图中的红圈部分，则只显示匹配的文件和文件夹。\n\n![20211012_1616](http://img.smyhvae.com/20211012_1616.png)\n\n当然，这招也有一点不足：不能搜中文。\n\n### 7、大纲视图\n\n如下图所示，大纲视图可以展示当前代码的方法结构、文件的目录结构：\n\n![20211012_1628](http://img.smyhvae.com/20211012_1628.png)\n\n![20211012_1636](http://img.smyhvae.com/20211012_1636.png)\n\n### 8、文件对比\n\nVS Code 默认支持**对比两个文件的内容**。选中两个文件，然后右键选择「将已选项进行比较」即可，效果如下：\n\n![](http://img.smyhvae.com/20190329_1756.png)\n\nVS Code 自带的对比功能并不够强大，我们可以安装插件 `compareit`，进行更丰富的对比。比如说，安装完插件 `compareit`之后，我们可以将「当前文件」与「剪切板」里的内容进行对比：\n\n![](http://img.smyhvae.com/20190329_1757.png)\n\n如果你安装了 GitLens 插件，还可以将两个git分支的代码进行比对，非常完美。\n\n### 9、查找某个函数在哪些地方被调用了\n\n比如我已经在 `a.js`文件里调用了 `foo()`函数。那么，如果我想知道 `foo()`函数在其他文件中是否也被调用了，该怎么做呢？\n\n做法如下：在 `a.js` 文件里，选中 `foo()`函数（或者将光标放置在 `foo()`函数上），然后按住快捷键「Shift + F12」，就能看到 `foo()`函数在哪些地方被调用了，比较实用。\n\n### 10、鼠标操作\n\n- 在当前行的位置，鼠标三击，可以选中当前行。\n- 用鼠标单击文件的**行号**，可以选中当前行。\n- 在某个**行号**的位置，**上下移动鼠标，可以选中多行**。\n\n### 11、重构\n\n重构分很多种，我们来举几个例子。\n\n**命名重构**：\n\n当我们尝试去修改某个函数（或者变量名）时，我们可以把光标放在上面，然后按下「F2」键，那么，这个函数（或者变量名）出现的地方都会被修改。\n\n**方法重构**：\n\n选中某一段代码，这个时候，代码的左侧会出现一个「灯泡图标」，点击这个图标，就可以把这段代码提取为一个单独的函数。\n\n### 12：终端配置\n\nVS Code软件自带了终端，但我个人认为不是很好用，而且VS Code 软件关了之后，终端也没了。建议大家使用其他的终端软件，专业的事情交给专业的人做。\n\n- Windows平台的终端：推荐 PowerShell 软件。远程终端推荐 xshell 软件。\n- Mac平台的终端：推荐 [iTerm2 ](https://iterm2.com/)。 iTerm2 是Mac平台最好用的终端软件，没有之一。\n\n**右键行为**：\n\n> 在终端上，单击右键所产生的行为在不同的系统里是不同的。\n\n- Windows：如果有**选定**文本，则复制当前文本；如果没有选定文本，则粘贴。\n- macOS：选中光标所在位置的单词，并显示右键菜单。\n- Linux：显示右键菜单。\n\n### 13、Git 版本管理\n\n在 VS Code中使用Git之前，需要你先安装 Git 环境。\n\nVS Code 自带了 Git 版本管理的功能，如下图所示：\n\n![](http://img.smyhvae.com/20190418_1850.png)\n\n上图中，我们可以在这里进行常见的 git 命令操作。如果你还不熟悉 **Git 版本管理**，可以先去补补课。\n\n我自己用的最多的功能是**diff 代码**和**合并冲突**，自从用上了 VS Code 的这两个功能，简直离不开它。\n\n我们先来看看 diff 代码的效果：\n\n![20211013_1411](https://img.smyhvae.com/20211013_1411.png)\n\n上图中，点击右上角的 `...`，然后点击 `内联视图`，则可以换一种视图 diff 代码：\n\n![](https://img.smyhvae.com/20211013_1415.png)\n\n**Git状态栏**：\n\n![20211013_1421](http://img.smyhvae.com/20211013_1421.png)\n\n在VS Code的左下角会显示Git状态栏。如果当前代码仓库配置了远程仓库，那么“同步更改”会显示以下信息：\n\n- 左边的数字：表示远程分支比本地分支多了XX个 Git commit。\n- 右边的数字：表示本地分支比远程分支多了XX个 Git commit。\n\n点击“同步更改”按钮，会拉取（pull）远程分支到本地分支，并推送（push）本地的Git commit到远程分支。\n\n如果当前代码仓库没有配置远程仓库，则会显示“发布更改”的按钮。点击“发布更改”按钮，会把当前分支push到远程仓库。\n\n---\n\n另外，我建议安装插件 `GitLens`搭配使用，它是 VS Code 中我最推荐的一个插件，简直是 Git 神器，码农必备。\n\n我还要补充一句：\n\n有人说，高手都是直接用命令行操作Git。然而，根据我多年的经验来看，如果你的代码仓库需要管理的分支特别多，与团队的其他成员需要经常协作，那么，我建议你**优先使用** GUI 图形化工具来操作Git，避免出错。\n\n我推荐的GUI版的Git工具有：\n\n- [Tower](https://www.git-tower.com/)\n- [Sourcetree](https://www.sourcetreeapp.com/)\n- [GitKraken](https://www.gitkraken.com/)\n\n### 14、将工作区放大/缩小\n\n我们在上面的设置项里修改字体大小后，仅仅只是修改了代码的字体大小。\n\n如果你想要缩放整个工作区（包括代码的字体、左侧导航栏的字体等），可以按下快捷键「**cmd +/-**」。windows 用户是按下「ctrl +/-」\n\n**当我们在投影仪上给别人演示代码的时候，这一招十分管用**。\n\n如果你想恢复默认的工作区大小，可以在命令面板输入 `重置缩放`（英文是 `reset zoom`）\n\nf### 11、创建多层子文件夹\n\n我们可以在新建文件夹的时候，如果直接输入 `aa/bb/cc`，比如：\n\n![](http://img.smyhvae.com/20190418_2022.png)\n\n那么，就可以创建多层子文件夹，效果如下：\n\n![](http://img.smyhvae.com/20190418_2023.png)\n\n### 15、`.vscode` 文件夹的作用\n\n为了统一团队的 vscode 配置，我们可以在项目的根目录下建立 `.vscode`目录，在里面放置一些配置内容，比如：\n\n- `settings.json`：工作空间设置、代码格式化配置、插件配置。\n- `sftp.json`：ftp 文件传输的配置。\n\n`.vscode`目录里的配置只针对当前项目范围内生效。将 `.vscode`提交到代码仓库，大家统一配置时，会非常方便。\n\n### 16、自带终端\n\n我们可以按下「Ctrl + `」打开 VS Code 自带的终端。我认为内置终端并没有那么好用，我更建议你使用第三方的终端 **item2**。\n\n### 17、markdown 语法支持\n\nVS Code 自带 markdown 语法高亮。也就是说，如果你是用 markdown 格式写文章，则完全可以用 VS Code 进行写作。\n\n写完 md 文件之后，你可以点击右上角的按钮进行预览，如下图所示：\n\n![](http://img.smyhvae.com/20190418_1907.png)\n\n我一般是安装「Markdown Preview Github Styling」插件，以 GitHub 风格预览 Markdown 样式。样式十分简洁美观。\n\n你也可以在控制面板输入 `Markdown: 打开预览`，直接全屏预览 markdown 文件。\n\n### 18、Emmet in VS Code\n\n`Emmet`可以极大的提高 html 和 css 的编写效率，它提供了一种非常简练的语法规则。\n\n举个例子，我们在编辑器中输入缩写代码：`ul>li*6` ，然后按下 Tab 键，即可得到如下代码片段：\n\n```html\n<ul>\n  <li></li>\n  <li></li>\n  <li></li>\n  <li></li>\n  <li></li>\n  <li></li>\n</ul>\n```\n\nVS Code 默认支持 Emmet。更多 Emmet 语法规则，可以自行查阅。\n\n### 19、修改字体，使用「Fira Code」字体\n\n这款字体很漂亮，很适合用来写代码：\n\n![](https://img.smyhvae.com/20200516_1633-2.png)\n\n安装步骤如下：\n\n（1）进入 [https://github.com/tonsky/FiraCode](https://github.com/tonsky/FiraCode) 网站，下载并安装「Fira Code」字体。\n\n（2）打开 VS Code 的「设置」，搜索 `font`，修改相关配置为如下内容：\n\n```json\n\"editor.fontFamily\": \"'Fira Code',Menlo, Monaco, 'Courier New', monospace\", // 设置字体显示\n\"editor.fontLigatures\": false,//控制是否启用字体连字，true启用，false不启用\n```\n\n上方的第二行配置，取决于个人习惯，我是直接设置为 `\"editor.fontLigatures\": null`，因为我不太习惯连字。\n\n### 20、代码格式化\n\nVS Code 默认对 JavaScript、TypeScript、JSON、HTML 提供了开箱即用的代码格式化支持。其他语言则需要先安装相应的插件才能支持。\n\n另外，我们还可以安装 Prettier 插件进行**更精细**的代码格式化。下一段将插件的时候，会讲解。\n\n### 21、智能提示 IntelliSense\n\nVS Code 默认对 JavaScript、TypeScript、JSON、HTML、CSS、SCSS、Less这7种语言（文件）提供了**智能提示**的支持。其他编程语言则需要先安装相应的插件才能支持。\n\n在 VS Code插件职场中，下图是最受欢迎的8种[编程语言插件](https://marketplace.visualstudio.com/search?target=VSCode&category=Programming%20Languages&sortBy=Installs)：\n\n![20211013_1120](https://img.smyhvae.com/20211013_1120.png)\n\n智能提示的功能很强大， 包括函数介绍、代码自动补全等等。\n\n### 22、调试与运行\n\nVS Code **内置**了对 Node.js 运行时的调试支持，可以直接调试 JavaScript 和 TypeScript。其他编程语言的调试，则需要先安装相应的插件才能支持。\n\n在 VS Code插件市场中，下图是最受欢迎的几种调试插件：\n\n![](https://img.smyhvae.com/20211013_1650.png)\n\n### 23、文件传输：sftp\n\n如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器（需要先把服务端的配置搭建好），可以安装 `sftp`这个插件，很好用。在公司会经常用到。\n\n步骤如下：\n\n（1）安装插件 `sftp`。\n\n（2）配置 `sftp.json`文件。 插件安装完成后，输入快捷键「cmd+shift+P」弹出命令面板，然后输入 `sftp:config`，回车，当前工程的 `.vscode`文件夹下就会自动生成一个 `sftp.json`文件，我们需要在这个文件里配置的内容可以是：\n\n- `host`：服务器的 IP 地址\n- `username`：用户名\n- `privateKeyPath`：存放在本地的已配置好的用于登录工作站的密钥文件（也可以是 ppk 文件）\n- `remotePath`：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用 sftp 上传文件之前，要手动在工作站上 mkdir 生成这个根目录\n- `ignore`：指定在使用 sftp: sync to remote 的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号\n\n举例如下：(注意，其中的注释需要去掉)\n\n```json\n{\n  \"host\": \"192.168.xxx.xxx\", //服务器ip\n  \"port\": 22, //端口，sftp模式是22\n  \"username\": \"\", //用户名\n  \"password\": \"\", //密码\n  \"protocol\": \"sftp\", //模式\n  \"agent\": null,\n  \"privateKeyPath\": null,\n  \"passphrase\": null,\n  \"passive\": false,\n  \"interactiveAuth\": false,\n  \"remotePath\": \"/root/node/build/\", //服务器上的文件地址\n  \"context\": \"./server/build\", //本地的文件地址\n\n  \"uploadOnSave\": true, //监听保存并上传\n  \"syncMode\": \"update\",\n  \"watcher\": {\n    //监听外部文件\n    \"files\": false, //外部文件的绝对路径\n    \"autoUpload\": false,\n    \"autoDelete\": false\n  },\n  \"ignore\": [\n    //忽略项\n    \"**/.vscode/**\",\n    \"**/.git/**\",\n    \"**/.DS_Store\"\n  ]\n}\n```\n\n（3）在 VS Code 的当前文件里，选择「右键 -> upload」，就可以将本地的代码上传到 指定的 ftp 服务器上（也就是在上方 `host` 中配置的服务器 ip）。\n\n我们还可以选择「右键 -> Diff with Remote」，就可以将本地的代码和 ftp 服务器上的代码做对比，非常方便。\n\n### 24、沉浸模式/禅模式\n\n程序员写代码需要专注，有时需要进入一种心流。VS Code给我们提供了一种全屏下的沉浸模式，周围的面板都会被隐藏起来，只显示编辑器部分。\n\n操作方法：菜单栏选择「查看-外观-禅模式」即可；或者按下快捷键 `Cmd + K`，放手，再按 `Z`也可以达到目的。\n\n### 25、远程同步 VS Code 配置项\n\n北京时间的[2020年8月14日](https://zhuanlan.zhihu.com/p/184868336)，微软发布 Visual Studio Code 1.48 稳定版。此版本**原生**支持用户同步 VS Code的配置，只需要登录微软账号或者 GitHub 账号即可。\n\n有了这个功能之后，我们可以先在老电脑上登录账号，即可将软件的配置项自动开启云同步。当你下次换一个新的电脑，下载安装 VS Code，点击软件左下角的设置按钮，登录此前的微软账号或GitHub账号，即可自动将旧电脑的软件配置项，同步到新电脑的软件上。极其方便。\n\n### 26、正则表达式批量删除字符串\n\n**需求**：将文本中的字符串 `axxxxb`，批量替换为 `ab`。其中，开头字符 a 和 结尾字符 b 固定，中间xxx长度不确定。\n\n**解决**：传统查找替换无法胜任。可以使用VScode正则表达式功能，查找 `a.*?b`替换为 `ab`即可。其中 `?`是禁止贪婪匹配，否则会误删很多内容。\n\n---\n\n**拓展需求**：需求——将文本中的字符串 `axxxx`，批量替换为 `a`。其中，开头字符 a 固定，后面的xxx长度不确定。\n\n**解决**：传统查找替换无法胜任。可以使用VScode正则表达式功能，查找 `a.*?\\n`替换为 `a\\n`即可。\n\n## 六、三头六臂：VS Code 插件介绍 & 插件推荐\n\nVS Code 有一个很强大的功能就是支持插件扩展，让你的编辑器仿佛拥有了三头六臂。\n\n### 安装插件\n\n![](http://img.smyhvae.com/20191108_1553_2.png)\n\n上图中，点击红框部分，即可在顶部输入框里，查找你想要的插件名，然后进行安装。\n\n插件安装完成后，记得重启软件（或者点击插件位置的“重新加载”），插件才会生效。\n\n另外，我们还可以访问官网的插件市场来安装插件：\n\n- VS Code插件市场（官方）：https://marketplace.visualstudio.com/vscode\n\n**插件的安装目录**：\n\n- Windows：：`%USERPROFILE%\\.vscode\\extensions`\n- macOS：`~/.vscode/extensions`\n- macOS：`~/.vscode/extensions`\n\n### 插件的类型\n\n![20211013_1757_2](http://img.smyhvae.com/20211013_1757_2.png)\n\n插件市场的首页有四个模块，可以作为重要的信息来源：\n\n- Featured：由 VS Code团队精心推荐的插件。\n- Trending：近期热门插件。\n- Most Popular：按总安装量排序的插件。\n- Recently Added：最新发布的插件。\n\n![20211013_1758](http://img.smyhvae.com/20211013_1758.png)\n\n![20211013_1955](http://img.smyhvae.com/20211013_1955.png)\n\n插件市场至少有17种类型的插件：（按照数量排序）\n\n- Themes：主题插件\n- Programming Languages：编程语言插件\n- Snippets：代码片段\n- Extension Packs：插件包，里面包括多个插件\n- Formatters：代码格式化\n- Linters：静态检查\n- Debuggers：调试器\n- Keymaps：快捷键映射\n- Visualization：可视化\n- Language Packs：各国的语言插件\n- Azure：Azure 云计算\n- Data Science：数据科学\n- SCM Providers：源代码控制管理器（source control manager）\n- Notebooks\n- Education：教育\n- Testing：测试相关\n- Machine Learning：机器学习\n- Others：其他\n\n### 插件的过滤显示\n\n在 VS Code中打开插件管理视图，可以针对已安装的插件，进行过滤展示。\n\n1）点击插件视图右上角的 `...`按钮，可以展示不同状态的插件：\n\n![20211013_2011](http://img.smyhvae.com/20211013_2011.png)\n\n2）在搜索框输入字符 `@`，会展示出不同类型的过滤器：\n\n![20211013_2015](http://img.smyhvae.com/20211013_2015.png)\n\n**常见的过滤器如下**：\n\n1）按大类搜：\n\n- `@builtin`：显示 VS Code内置的插件\n- `@disabled`：显示被禁用的插件\n- `@enabled`：显示已启用的插件\n- `@installed`：显示已安装的插件\n- `@outdated`：显示待更新的插件\n\n2）精准搜索：\n\n- `@id`：按id显示插件\n- `@tag`：根据标签显示插件。\n\n3）对插件进行排序：\n\n- `@sort:installs`：根据插件的安装量排序\n- `@sourt:rating`：根据插件的评分排序\n- `@sort:name`：根据插件名字的字母顺序排序\n\n4）组合搜索：（举例）\n\n- `@installed @category:themes`：显示已安装的主题插件。\n- `@sort:installs java`：对 Java 相关的插件按照安装量排序。\n\n下面的内容，我来列举一些常见的插件，这些插件都很实用，小伙伴们可以按需安装。注意：每一类插件里，**顺序越靠前，越实用**。\n\n### 1、基本插件\n\n#### Chinese (Simplified) Language Pack for Visual Studio Code\n\n让软件显示为简体中文语言。\n\n### 2、Git 相关插件\n\n#### GitLens 【荐】\n\n我强烈建议你安装插件 `GitLens`，它是 VS Code 中我最推荐的一个插件，简直是 Git 神器，码农必备。如果你不知道，那真是 out 了。\n\nGitLens 在 Git 管理上有很多强大的功能，比如：\n\n- 将光标放置在代码的当前行，可以看到这样代码的提交者是谁，以及提交时间。这一点，是 GitLens 最便捷的功能。\n- 查看某个 commit 的代码改动记录\n- 查看不同的分支\n- 可以将两个 commit 进行代码对比\n- 甚至可以将两个 branch 分支进行整体的代码对比。这一点，简直是 GitLens 最强大的功能。当我们在不同分支 review 代码的时候，就可以用到这一招。\n\n打开你的 Git仓库，未安装 GitLens 时是这样的：\n\n![](http://img.smyhvae.com/20211009_1400.png)\n\n安装了 GitLens 之后是这样的：\n\n![](http://img.smyhvae.com/20211009_1430.png)\n\n上图中，红框部分就是 GitLens 的功能，诸君可以自由发挥。\n\n补充一个有意思的趣事：Python插件、Ruby插件、GitLens插件、Vetur插件，这四个插件的开发者先后加入了微软。\n\n#### Git History\n\n有些同学习惯使用编辑器中的 Git 管理工具，而不太喜欢要打开另外一个 Git UI 工具的同学，这一款插件满足你查询所有 Git 记录的需求。\n\n#### Local History 【荐】\n\n维护文件的本地历史记录。代码意外丢失时，有时可以救命。\n\n![](http://img.smyhvae.com/20200618_2246.png)\n\n### 3、代码智能提示插件\n\n#### Vetur\n\nVue 多功能集成插件，包括：语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger。VS Code 官方钦定 Vue 插件，Vue 开发者必备。\n\n#### ES7 React/Redux/GraphQL/React-Native snippets\n\nReact/Redux/react-router 的语法智能提示。\n\n安装该插件后，在代码中只需要输入 `clg`即可自动补全 `console.log()`这行代码。\n\n#### JavaScript(ES6) code snippets\n\nES6 语法智能提示，支持快速输入。\n\n#### javascript console utils：快速打印 log 日志【荐】\n\n安装这个插件后，当我们按住快捷键「Cmd + Shift + L」后，即可自动出现日志 `console.log()`。简直是日志党福音。\n\n当我们选中某个变量 `name`，然后按住快捷键「Cmd + Shift + L」，即可自动出现这个变量的日志 `console.log(name)`。\n\n其他的同类插件还有：Turbo Console Log。\n\n不过，生产环境的代码，还是尽量少打日志比较好，避免出现一些异常。\n\n编程有三等境界：\n\n- 第三等境界是打日志，这是最简单、便捷的方式，略显低级，一般新手或资深程序员偷懒时会用。\n- 第二等境界是断点调试，在前端、Java、PHP、iOS 开发时非常常用，通过断点调试可以很直观地跟踪代码执行逻辑、调用栈、变量等，是非常实用的技巧。\n- 第一等境界是测试驱动开发，在写代码之前先写测试。与第二等的断点调试刚好相反，大部分人不是很习惯这种方式，但在国外开发者或者敏捷爱好者看来，这是最高效的开发方式，在保证代码质量、重构等方面非常有帮助，是现代编程开发必不可少的一部分。\n\n#### Code Spell Checker：单词拼写错误检查\n\n这个拼写检查程序的目标是帮助捕获常见的单词拼写错误，可以检测驼峰命名。从此告别 Chinglish.\n\n#### Auto Close Tag、Auto Rename Tag\n\n自动闭合配对的标签、自动重命名配对的标签。\n\n### 4、代码显示增强插件\n\n#### highlight-icemode：选中相同的代码时，让高亮显示更加明显\n\nVSCode 自带的高亮显示，实在是不够显眼。可以用插件支持一下。\n\n所用了这个插件之后，VS Code 自带的高亮就可以关掉了：\n\n在用户设置里添加 `\"editor.selectionHighlight\": false`即可。\n\n参考链接：[vscode 选中后相同内容高亮插件推荐](https://blog.csdn.net/palmer_kai/article/details/79548164)\n\n#### vscode-icons\n\nvscode-icons 会根据文件的后缀名来显示不同的图标，让你更直观地知道每种文件是什么类型的。\n\n#### indent-rainbow：突出显示代码缩进\n\n`indent-rainbow`插件：突出显示代码缩进。\n\n安装完成后，效果如下图所示：\n\n![](http://img.smyhvae.com/20190418_1958.png)\n\n#### TODO Highlight\n\n写代码过程中，突然发现一个 Bug，但是又不想停下来手中的活，以免打断思路，怎么办？按照代码规范，我们一般是在代码中加个 TODO 注释。比如：（注意，一定要写成大写 `TODO`，而不是小写的 `todo`）\n\n```\n//TODO:这里有个bug，我一会儿再收拾你\n```\n\n或者：\n\n```\n//FIXME:我也不知道为啥， but it works only that way.\n```\n\n安装了插件 `TODO Highlight`之后，按住「Cmd + Shift + P」打开命令面板，输入「Todohighlist」，选择相关的命令，我们就可以看到一个 todoList 的清单。\n\n#### Better Comments\n\n为注释添加更醒目、带分类的色彩。\n\n### 5、代码格式化插件\n\n#### Prettier：代码格式化\n\nPrettier 是一个代码格式化工具，**只关注格式化，但不具备校验功能**。在一个多人协同开发的团队中，统一的代码编写规范非常重要。一套规范可以让我们编写的代码达到一致的风格，提高代码的可读性和统一性。自然维护性也会有所提高，代码的展示也会更加美观。\n\n步骤如下：\n\n（1）安装插件 `Prettier`。\n\n（2）在项目的根路径下，新建文件 `.prettierrc`，并在文件中添加如下内容：\n\n```json\n{\n  \"printWidth\": 150,\n  \"tabWidth\": 4,\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"trailingComma\": \"es5\",\n  \"tslintIntegration\": true,\n  \"insertSpaceBeforeFunctionParenthesis\": false\n}\n```\n\n上面的内容，是我自己的配置，你可以参考。更多配置，可见官方文档：[https://prettier.io/docs/en/options.html](https://prettier.io/docs/en/options.html)\n\n（3）Mac用户按快捷键「Option + Shift + F」，Win 用户按快捷键「Alt + shift + F」，即可完成代码的格式化。如果你的VS Code 设置的是自动格式化代码，那么这一步可以忽略。\n\n#### ESLint：代码格式的校验\n\n日常开发中，建议用 Prettier 做**代码格式化**，然后用 eslint 做**格式校验**。很多人把这两个插件的功能弄混了。\n\n一般做法是：格式化建议是由程序员手动触发，格式校验由系统强制校验。通过 Prettier **手动**触发格式化，是为了让用户有感知；通过eslint 做**强制**校验之后，如果代码的格式不符合要求，系统就禁止你提交代码。\n\n#### Beautify\n\n代码格式化工具。\n\n备注：相比之下，Prettier 是当前最流行的代码格式化工具，比 Beautify 用得更多。\n\n#### Paste JSON as Code\n\n此插件可以将剪贴板中的 JSON 字符串转换成工作代码。支持多种语言。\n\n#### JS-CSS-HTML Formatter【荐】\n\n保存文件时，自动格式化 HTML、CSS、JS代码。\n\n### 6、图片相关插件\n\n#### Polacode-2020：生成代码截图 【荐】\n\n可以把代码片段保存成美观的图片，主题不同，代码的配色方案也不同，也也可以自定义设置图片的边框颜色、大小、阴影。\n\n尤其是在我们做 PPT 分享时需要用到代码片段时，或者需要在网络上优雅地分享代码片段时，这一招很有用。\n\n生成的效果如下：\n\n![](http://img.smyhvae.com/20200619_1403.png)\n\n其他同类插件：`CodeSnap`。我们也可以通过 [https://carbon.now.sh/](https://carbon.now.sh/)这个网站生成代码图片\n\n有人可能会说：直接用 QQ 截图不行吗？可以是可以，但不够美观、不够干净。\n\n#### Image Preview 【荐】\n\n图片预览。鼠标移动到图片 url 上的时候，会自动显示图片的预览和图片尺寸。\n\n### 7、CSS相关插件\n\n#### CSS Peek\n\n增强 HTML 和 CSS 之间的关联，快速查看该元素上的 CSS 样式。\n\n#### Vue CSS Peek\n\nCSS Peek 对 Vue 没有支持，该插件提供了对 Vue 文件的支持。\n\n#### Color Info\n\n这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。\n\n### 8、Mardown 相关插件\n\n#### Markdown Preview Github Styling 【荐】\n\n以 GitHub 风格预览 Markdown 样式，十分简洁优雅。就像下面这样，左侧书写 Markdown 文本，右侧预览 Markdown 的渲染效果：\n\n![](http://img.smyhvae.com/20200618_2025.png)\n\n#### Markdown Preview Enhanced\n\n预览 Markdown 样式。\n\n#### Markdown All in One\n\n这个插件将帮助你更高效地在 Markdown 中编写文档。\n\n### 9、通用工具类插件\n\n#### sftp：文件传输 【荐】\n\n如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装 `sftp`这个插件，很好用。在公司会经常用到。\n\n详细配置已经在上面讲过。\n\n#### Live Server 【荐】\n\n在本地启动一个服务器，代码写完后可以实现「热更新」，实时地在网页中看到运行效果。就不需要每次都得手动刷新页面了。\n\n使用方式：安装插件后，开始写代码；代码写完后，右键选择「Open with Live Server」。\n\n#### open in browser\n\n安装 `open in browser`插件后，在 HTML 文件中「右键选择 --> Open in Default Browser」，即可在浏览器中预览网页。\n\n#### Project Manager\n\n工作中，我们经常会来回切换多个项目，每次都要找到对应项目的目录再打开，比较麻烦。Project Manager 插件可以解决这样的烦恼，它提供了专门的视图来展示你的项目，我们可以把常用的项目保存在这里，需要时一键切换，十分方便。\n\n#### WakaTime 【荐】\n\n统计在 VS Code 里写代码的时间。统计效果如下：\n\n![](http://img.smyhvae.com/20200618_2300.png)\n\n#### Code Time\n\n`Code Time`插件：记录编程时间，统计代码行数。\n\n安装该插件后，VS Code 底部的状态栏右下角可以看到时间统计。点击那个位置之后，选择「Code Time Dashboard」，即可查看统计结果。\n\n备注：团长试了一下这个 code time 插件，发现统计结果不是很准。\n\n#### File Tree to Text Generator：快速生成文件的目录树\n\n如题。\n\n#### minapp：小程序支持\n\n小程序开发必备插件。\n\n#### Search node_modules\n\n`node_modules`模块里面的文件夹和模块实在是太多了，根本不好找。好在安装 `Search node_modules` 这个插件后，输入快捷键「Cmd + Shift + P」，然后输入 `node_modules`，在弹出的选项中选择 `Search node_modules`，即可搜索 node_modules 里的模块。\n\n![](http://img.smyhvae.com/20200618_2100.png)\n\n#### RemoteHub\n\n不要惊讶，RemoteHub 和 GitLens 是同一个作者开发出来的。\n\n`RemoteHub`插件的作用是：可以在本地查看 GitHub 网站上的代码，而不需要将代码下载到本地。\n\n![](http://img.smyhvae.com/20190418_1937.png)\n\n这个插件目前使用的人还不多，赶紧安装起来尝尝鲜吧。\n\n#### Live Share：实时编码分享\n\n`Live Share`这个神奇的插件是由微软官方出品，它的作用是：**实时编码分享**。也就是说，它可以实现你和你的同伴一起写代码。这绝对就是**结对编程**的神器啊。\n\n安装方式：\n\n打开插件管理，搜索“live share”，安装。安装后重启 VS Code，在左侧会多出一个按钮：\n\n![](http://img.smyhvae.com/20190418_2012.png)\n\n上图中，点击红框部分，登录后就可以分享你的工作空间了。\n\n![](http://img.smyhvae.com/20190418_2005.png)\n\n#### Import Cost\n\n在项目开发过程中，我们会引入很多 npm 包，有时候可能只用到了某个包里的一个方法，却引入了整个包，导致代码体积增大很多。`Import Cost`插件可以在代码中友好的提示我们，当前引入的包会增加多少体积，这很有助于帮我们优化代码的体积。\n\n### 10、主题插件\n\n给你的 VS Code 换个皮肤吧，免费的那种。\n\n- Dracula Theme\n- Material Theme\n- Nebula Theme\n- [One Dark Pro](https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme)\n- One Monokai Theme\n- Monokai Pro\n- Ayu\n- [Snazzy Plus](https://marketplace.visualstudio.com/items?itemName=akarlsten.vscode-snazzy-akarlsten)\n- [Dainty](https://marketplace.visualstudio.com/items?itemName=alexanderte.dainty-vscode)\n- `SynthWave '84`\n- GitHub Plus Theme：白色主题\n- Horizon Theme：红色主题\n\n## 七、无缝切换：VS Code 配置云同步\n\n我们可以将配置云同步，这样的话，当我们换个电脑时，即可将配置一键同步到本地，就不需要重新安装插件了，也不需要重新配置软件。\n\n下面讲的两个同步方法，都可以，看你自己需要。方法1是 VS Code自带的同步功能，操作简单。方法2 需要安装插件，支持更多的自定义配置。\n\n### 方法1：使用 VS Code 自带的同步功能\n\n1、**配置同步**：\n\n（1）在菜单栏选择「 Code --> 首选项 --> 打开设置同步」：\n\n![](https://img.smyhvae.com/20211008_1713.png)\n\n（2）选择需要同步的配置：\n\n![](http://img.smyhvae.com/20211008_1716.png)\n\n（3）通过Microsoft或者GitHub账号登录。 上图中，点击“登录并打开”，然后弹出如下界面：\n\n![](http://img.smyhvae.com/20211008_1717.png)\n\n上图中，使用 微软账号或者 GitHub账号登录：\n\n![](https://img.smyhvae.com/20211008_1718.png)\n\n（4）同步完成后，菜单栏会显示“首先项同步已打开”，最左侧也会多出一个同步图标，如下图所示：\n\n![](https://img.smyhvae.com/20211008_1720.png)\n\n2、**管理同步**：\n\n（1）点击菜单栏「Code --> 首选项 --> 设置同步已打开」，会弹出如下界面，进行相应的同步管理即可：\n\n![](https://img.smyhvae.com/20211008_1736.png)\n\n（2）换另外一个电脑时，登录相同的账号，即可完成同步。\n\n参考链接：\n\n- [VS Code原生的配置同步功能——Settings Sync](https://blog.csdn.net/baidu_33340703/article/details/106967884)\n\n### 方法2：使用插件 `settings-sync`\n\n使用方法2，我们还可以把配置分享其他用户，也可以把其他用户的配置给自己用。\n\n1、**配置同步**：（将自己本地的配置云同步到 GitHub）\n\n（1）安装插件 `settings-sync`。\n\n（2）安装完插件后，在插件里使用 GitHub 账号登录。\n\n（3）登录后在 vscode 的界面中，可以选择一个别人的 gist；也可以忽略掉，然后创建一个属于自己的 gist。\n\n（4）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「更新/上传配置」，这样就可以把最新的配置上传到 GitHub。\n\n2、**管理同步**：（换另外一个电脑时，从云端同步配置到本地）\n\n（1）当我们换另外一台电脑时，可以先在 VS Code 中安装 `settings-sync` 插件。\n\n（2）安装完插件后，在插件里使用 GitHub 账号登录。\n\n（3）登录之后，插件的界面上，会自动出现之前的同步记录：\n\n![](http://img.smyhvae.com/20200521_1530.png)\n\n上图中，我们点击最新的那条记录，就可将云端的最新配置同步到本地：\n\n![](http://img.smyhvae.com/20200521_1550.png)\n\n如果你远程的配置没有成功同步到本地，那可能是网络的问题，此时，可以使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」，多试几次。\n\n**使用其他人的配置**：\n\n如果我们想使用别人的配置，首先需要对方提供给你 gist。具体步骤如下：\n\n（1）安装插件 `settings-sync`。\n\n（2）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」\n\n（3）在弹出的界面中，选择「Download Public Gist」，然后输入别人分享给你的 gist。注意，这一步不需要登录 GitHub 账号。\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/课件/guid/tool/VS Code的使用.md"}},{"pageContent":"# Git使用指南\n\n## 安装\n\n1. 先去官网下载这个软件, 准备安装到本电脑中\n   > [git-scm.com/](https://link.juejin.cn?target=https%3A%2F%2Fgit-scm.com%2F \"https://git-scm.com/\")\n2. 根据自己电脑系统下载此软件到本机\n   > Windows 系统直接下载 .exe 文件即可，macOS 系统使用 [Homebrew](https://link.juejin.cn?target=https%3A%2F%2Fbaijiahao.baidu.com%2Fs%3Fid%3D1668544039877443967%26wfr%3Dspider%26for%3Dpc \"https://baijiahao.baidu.com/s?id=1668544039877443967&wfr=spider&for=pc\") 命令行安装，终端输入 git --version 确认安装\n\n![image-20230612100943906.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b965f0202334842b029f372fff23ae7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1691&h=893&s=373076&e=png&b=f1f1ea)\n\n3. 默认选择默认安装路径即可，如若想更改路径，务必使用**英文路径**\n4. 对于 Windows 系统，查看安装是否成功: 在任意文件夹右键, 查看是否有Git Base Here 选项, 有就成功了\n\n![image-20230612101818017.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ecc82bd4d384d599021998eff925f5f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1256&h=544&s=182944&e=png&b=fcfcfc)\n\n## 介绍\n\nGit 的三个区域：\n\n- **工作区** ：处理工作的区域\n- **暂存区** ：临时存放的区域\n- **本地git仓库** ：最终的存放区域\n\n在文件夹的体现如下：\n\n- **工作区** ：在你电脑里看到的目录\n- **暂存区** ：在.git文件夹内的index中 (二进制记录)\n- **版本库** ：指的整个.git文件夹 (也认为是本地仓库)\n\n在代码中的体现如下：\n\n![image-20230612154411204-1687173588607.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae33cb79a42d49b7959adfe1d01bf132~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1256&h=621&s=112102&e=png&b=fdfcfc)\n\n# Git使用\n\n> 官方文档：[教程链接](https://link.juejin.cn?target=https%3A%2F%2Fgit-scm.com%2Fbook%2Fzh%2Fv2%2F%25E8%25B5%25B7%25E6%25AD%25A5-%25E5%2585%25B3%25E4%25BA%258E%25E7%2589%2588%25E6%259C%25AC%25E6%258E%25A7%25E5%2588%25B6 \"https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6\")\n>\n> 菜鸟教程：[教程链接](https://link.juejin.cn?target=https%3A%2F%2Fwww.runoob.com%2Fgit%2Fgit-tutorial.html \"https://www.runoob.com/git/git-tutorial.html\")\n\n## Git配置\n\n安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 因为每一个 Git 提交都会使用这些信息\n\n命令格式如下：**中文自己看情况换**\n\n> `git config`：固定命令，设置git相关配置\n>\n> `--global`：全局配置；一次配置，整机在使用git时都生效\n\ngit config --global user.name 你的用户名\ngit config --global user.email 你的邮箱地址\n\n运行命令效果如下：\n\n![image-20230612130038686.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c47580d485364928bc724fbba3237743~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=770&h=197&s=21309&e=png&b=000000)\n\n配置后, 可以运行如下命令查看是否成功\n\n```bash\ngit config --list\n#如果信息太多，可以输入 q 退出\n```\n\n运行命令效果如下：\n\n![image-20230612130350943.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be5717a3f7a34f8eb904a9e2b5f53996~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=958&h=439&s=42349&e=png&b=000000)\n\n> 出现以上内容即为注册成功。如果后续想要修改，只需要重新执行一下命令即可\n\n## 文件右侧标记\n\n> 一般使用 VSCode 打开一个包含git仓库的文件夹时，会有这些标记\n\n![image-20220625155941259.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ce5fa18d6454dd9aa64271ab18dc5e8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=553&h=268&s=15446&e=png&b=252526)\n\n右侧没有标记的时候为 `未修改` 或 此文件/文件夹，被git忽略不跟踪变化\n\n- M： **已修改** （Modified） - 文件已被修改但还没有被添加到暂存区\n- A： **已添加** （Added） - 文件已经被添加到暂存区，但还没有被提交\n- D： **已删除** （Deleted） - 文件已经被删除，并且已经被标记为删除，但还没有提交\n- R： **已重命名** （Renamed） - 文件已经被重命名，这也算作是一种修改，需要被添加到暂存区\n- C： **已复制** （Copied） - 文件已经被复制，这也算作是一种修改，需要被添加到暂存区\n- U： **已更新但未融合** （Updated but Unmerged） - 这表示一个文件已经被更新了，但在合并时发生了冲突，需要手动解决冲突后再标记为已解决\n\n## Git基础命令\n\n### 初始化空的Git仓库\n\n新建一个文件夹或现有的文件夹并不是 git 仓库，因为文件夹内不包含 .git 文件夹，没有被 git 管理\n\n可以在新文件夹或现有文件夹，运行如下命令得到 .git 文件夹，初始化成功则可让 git 开始准备管理\n\n```bash\n# 初始化 git 仓库, 产物: .git 文件夹 (所在文件夹\"内\"被管理)\ngit init\n\n```\n\n例如，在新文件夹中输入git init命令用于初始化空的git版本库\n\n![image-20230612141325305.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f600ec0c2aaa47fcb20bfbda4d3786db~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=975&h=136&s=15077&e=png&b=000000)\n\n初始化空的 git 仓库成功后，在项目文件夹中，开启显示隐藏文件，即可查看 .git 文件夹\n\n- 对于 Windows 系统，在查看里面勾选隐藏的项目选项\n- 对于 macOS 系统，使用快捷键 `Command + Shift + .`切换隐藏文件显示\n\n### 记录更新到Git仓库\n\n每当完成了一个阶段的目标，想要记录下它时，就将它提交到仓库\n\n核心操作：`工作区开发`--->`将修改后的文件添加到暂存区`--->`将暂存区的文件记录到版本库`\n\n- 把工作区变化放到暂存区中，执行如下命令\n\n```bash\n# 将 index.html 添加到暂存区\ngit add index.html\n\n# 将css目录下一切添加到暂存区\ngit add css\n```\n\n- 如下命令，可以一次性把所有变化文件放入暂存区\n\n```bash\ngit add .\n```\n\n- 把暂存区内容，提交到版本库，命令如下（此处文字说明可以不加引号）\n\n```bash\ngit commit -m '提交的内容说明'\n\n```\n\n过程图示：\n\n![image-20230612154411204-1687173588607.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae33cb79a42d49b7959adfe1d01bf132~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1256&h=621&s=112102&e=png&b=fdfcfc)\n\n> 以上命令相当于存档了一次，在版本库中产生一次提交记录并生成版本号\n>\n> 本次存档，不耽误我们在工作区 (项目文件夹) 下继续编写项目\n\n### Git日志及状态查看\n\n- 查看所有提交的日志记录，命令如下\n\n```bash\ngit log\n```\n\n运行命令效果如下：\n\n![image-20230612212059053.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12a32701f95f47b68743f9616783a63d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=846&h=308&s=32544&e=png&b=000000)\n\n- 当我们的日志越来越多，可能想要简化查看，可以输入如下命令\n\n> `--oneline`：在一行显示简略信息\n\n```bash\ngit log --oneline\n```\n\n运行命令效果如下：\n\n![image-20230612212137406.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99219baf1c1349db8e6761df62fd9dd1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=728&h=105&s=15476&e=png&b=000000)\n\n- 如果改的代码过多，忘记改过哪些了，可以运行如下命令来查看 git 仓库变化，只能看未提交的所有变更的文件状态\n\n```bash\ngit status\n```\n\n运行命令效果如下：\n\n![image-20230612212456778.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7466cc34e76c4f9e837a2a1bbce3d857~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=875&h=305&s=30542&e=png&b=000000)\n\n- 暂存并再次提交，产生一次版本记录\n\n```bash\ngit status\n\n```\n\n过程图示：\n\n![image-20230612154411204.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02257e8b46404c0980b8ac68fe07f4b2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1256&h=621&s=121037&e=png&b=fdfcfc)\n\n### Git版本回退\n\n时光机，回到过去~\n\n- 回退命令语法如下\n\n```bash\ngit reset --hard 版本号\n```\n\n- 查看版本号（每次的版本号随机生成）\n\n```bash\ngit log --oneline\n```\n\n![image-20230612212700778.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/935df632f35f4e5396627b114e5607e6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=723&h=140&s=21033&e=png&b=000000)\n\n- 尝试回退到 `477321b` 这次记录上\n\n```bash\ngit reset --hard 477321b\n```\n\n- 观察工作区，回退成功\n\n![image-20230612212808682.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28101f170cdd4821a446fd1bcdc739a1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=722&h=187&s=28346&e=png&b=000000)\n\n- 如果想要在回到最近一次提交的记录，但发现 `git log`看不到未来的记录了，问题不大。**输入git reflog命令，可以查看 git 所有的操作记录，包括你的reset记录**\n\n```bash\ngit reflog\n\n```\n\n运行命令效果如下：\n\n![image-20230612212857923.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46125c80682e434997028ab35dda4988~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=736&h=156&s=31014&e=png&b=000000)\n\n> 拓展命令：\n>\n> - git bash（终端）清屏：`clear `\n> - git bash（终端）另起一页：`Ctrl + L`\n\n### Git忽略文件\n\n有的时候，我们某些文件或文件夹不想让 git 进行跟踪管理。这时候可以在 .git 文件夹同级目录下新增 `.gitignore`的忽略文件并写入忽略规则（此处的文件名就是 .gitignore ，不是后缀）\n\n项目文件夹结构如下：\n\n![image-20230612213354387.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3742e0da132340899e330a9562a541bd~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=686&h=215&s=20403&e=png&b=ffffff)\n\n```bash\n# .gitignore内容：\npassword.txt\n\n其余用法：\n# 忽略文件夹\ncss\n# 忽略文件夹下的某个文件\ncss/index.js\n# 忽略文件夹下某类文件\ncss/*.js\n\n```\n\n根目录新建 password.txt，查看 git 追踪到了哪些变化\n\n```bash\ngit status\n```\n\n运行命令效果如下：\n\n![image-20230612214049685.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70d3ce513f4f4ed688b2d2fa0553dfc4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=943&h=204&s=19819&e=png&b=000000)\n\n> 发现只新增了.gitignore ，符合规则的都被忽略掉了\n\n`.gitignore`文件在项目中可以根据脚手架自动生成，无需自己编写，当然如果你非要写，以下是Vue官方自动生成的 `.gitignore`文件代码，可供复制使用\n\n```bash\n# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n\n```\n\n## Git分支\n\n### 分支本质\n\n分支其实就是一个叫**HEAD**的指针标记，每次代码提交，此**HEAD**指针都会往后移动一次，保证指向的 (并且工作区里的) 都是最后一次提交\n\n例如：当我们输入命令：`git reset --hard a3bcab2`，**HEAD**指针会移动，而且**HEAD**移动后，会影响工作区里的代码\n\n### 创建分支\n\n- **创建分支命令如下**\n\n```bash\n# 创建分支\ngit branch 分支名\n\n```\n\n该命令创建分支后不会自动切换分支，我们可以运行命令查看现在这个 .git 版本库里所有分支\n\n- **查看当前版本库所有分支命令如下**\n\n# 查看当前版本库所有分支，绿色带\\*代表现在所处的分支\n\ngit branch\n\n运行命令效果如下：\n\n![image-20230612215435954.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84fdb5bdfd8e4b8e87498f16c4113c5c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=758&h=176&s=18242&e=png&b=000000)\n\n- **手动切换到分支上**\n\n# 切换分支命令\n\ngit checkout 分支名\n\n运行命令效果如下：\n\n![image-20230612215712754.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3bbcf972ef440758d6327e6e142e8b6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=729&h=226&s=31046&e=png&b=000000)\n\n> 第一次创建并切换到 reg 分支，你会发现 master 分支上的所有代码 (和当前节点所有提交记录) 都被复制了过来\n> 了，我们只需要在这个基础上接着往后开发就行\n\n过程图示：\n\n![image-20230612215806700.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/339ad9c27506449baebc1edd5075992a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1244&h=611&s=131989&e=png&b=fdfdfd)\n\n### 分支下开发流程\n\n我们现在就可以在当前 reg 分支下来编写注册页面的逻辑代码，例如新建 `reg.html`文件，并随便写点内容。随后暂存并提交一次，这次提交的记录会出现在这里，如图\n\n![image-20220626005643763.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5b7ae62526b448d85035bf0501ed3da~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1262&h=586&s=124210&e=png&b=fcfbfb)\n\n以后在当前 reg 分支下开发，就会在 reg 范围内，每次提交产生一次版本记录，不会影响到别的分支\n\n### 分支合并\n\n我们可以把分支里写好的代码，合并到主分支或其他分支上，步骤如下：\n\n- 首先，切换到你要合并到的目标分支上（以master主分支为例）\n\n# 切换分支\n\ngit checkout master\n\n切换分支后，**HEAD**指针位置如下：\n\n![image-20230612220823875.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/506743c99da84c3c8298456406b2168a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1254&h=587&s=162561&e=png&b=fdfdfd)\n\n**合并命令语法**\n\ngit branch -d 分支名\n\n这里我们执行命令 `git merge reg`，执行后效果如图：\n\n![image-20220626011937230.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/422e99c4f9b64b33aa740218922357a8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1266&h=606&s=125759&e=png&b=fcfcfc)\n\n可见，reg 代码提交记录已经复制到了 master (主分支) 中\n\n### 分支删除\n\n假如注册功能开发完毕，代码已经合并到 master 分支上，我们已经不需要 reg 分支\n\n- **命令如下**\n\n```bash\ngit branch -d 分支名\n\n```\n\n如果分支的修改没有被合并到其他分支上，Git 会提示一个类似以下的错误信息：\n\n`error: The branch 'branch_name' is not fully merged. If you are sure you want to delete it, run 'git branch -D branch_name'.`\n\n在这种情况下，Git 建议你确认是否要删除这个分支。如果你确定要删除该分支并且不在乎丢失该分支的修改，你可以使用 `git branch -D <branch_name>`命令来**强制删除**该分支。但请注意，这样会丢失掉分支上的未合并修改\n\n### 分支合并时的冲突问题\n\n在两个分支修改了同一个文件并提交过，在合并的时候，就会产生冲突\n\n这里模拟一次简单的冲突：\n\n- 在 master 分支下，修改 `login.html`的某行代码，并完成一次暂存提交\n\n![image-20230612221800522.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61534650ad8549e185e72f3561c0016a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=740&h=284&s=37177&e=png&b=000000)\n\n- 切换到 reg 分支下，也修改 `login.html`的对应行代码，并完成一次暂存提交\n\n![image-20230612222009473.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ee908999ca34052ac74183a2d150457~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=706&h=280&s=36067&e=png&b=000000)\n\n- 再切换回到 master 分支下，用合并命令，把 reg 分支下代码和变化合并过来，**不出意外就会出现冲突了**\n\n![image-20230612222117265.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f8ffb16b9fa4d14b8bd3946a3dade34~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=833&h=299&s=35038&e=png&b=000000)\n\n发生冲突后，VSCode界面\n\n![image-20230612222156560.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b1b2a0253da4e17adab3d8d61348ddf~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=617&h=206&s=33508&e=png&b=23272e)\n\n> 此时我们要进行抉择： **采用当前更改** 、 **采用传入更改** 、**全部保留**\n\n选择保留方式后，需要再次暂存提交一次\n\n![image-20230612222444912.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ac609157d4741e39e207d982cca49b6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=800&h=234&s=33073&e=png&b=000000)\n\n> 此时结束冲突状态，变回正常状态\n\n- 打印冲突合并后的日志记录\n\n![image-20230612222705106.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c097571c37e48eba8da302f47441a7c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=793&h=661&s=71158&e=png&b=000000)\n\n> 总结：当我们合并遇到冲突了，应手动解决，然后暂存，提交一次即可\n\n## Git分支流程图详解（拓展）\n\n- **HEAD**头指针，它指向当前所在的分支或者某个具体的提交记录。每次提交会产生新的记录**master**和**HEAD**会后移\n\n![image-20230612224348269.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9639818947c94faf980d326508c8ea21~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=700&h=391&s=50853&e=png&b=fcfcfc)\n\n- 以当前节点为基准创建新的分支 (包含之前的所有提交记录)，`git branch reg` 就会在当前的提交记录上创建一个新的指针，名称为**reg**\n\n![image-20230612224959233.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7612d4bbdc83415e83ac8a94048dd86f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=684&h=448&s=47340&e=png&b=fdfdfd)\n\n- `git checkout reg`切换的是**HEAD**指针指向 (切换分支)\n\n![image-20230612225147670.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9595baac5fc4c7a843ebcced8cde384~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=673&h=466&s=39148&e=png&b=fdfdfd)\n\n- 注册页面新建后，`git add .`添加到暂存区，`git commit -m` 产生了一次提交记录\n\n![image-20230612225547703.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e702e79fc14a4fd79a863c63fa4db5cc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=822&h=534&s=50289&e=png&b=fdfdfd)\n\n- 注册页面的样式新建后暂存提交，产生了一次提交记录\n\n![image-20230613003559070.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3187bb9e91d49099b65d326c9069dfa~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=968&h=485&s=47899&e=png&b=fdfdfd)\n\n- 合并分支，例如把 A 合并到 B上\n\n  - `git checkout B`，切换到目标分支 B\n  - `git merge A`，把 A 分支记录合并到所在 B 分支下\n\n  先切换到主分支 `git checkout master`\n\n![image-20230613004008281.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26efb48153c94dd894888bf37bf68d0a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=951&h=558&s=47458&e=png&b=fdfdfd)\n\n- 合并**reg**分支 `git merge reg`\n\n![image-20230613004234355.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c8ba272cd55497183236fdb8320c507~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=870&h=563&s=52972&e=png&b=fdfdfd)\n\n- 在**reg**分支下，修改了 `index.html`文件，并暂存提交，产生了记录\n\n![image-20230613004635286.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6cbd349513b4f758edf55ab7c2fa47e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=939&h=507&s=56307&e=png&b=fdfdfd)\n\n- 切换到**master**分支，并修改 `index.html`文件(同一个文件)，暂存提交，产生了记录\n\n![image-20230613010644386.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d596cdad0d7340f3ab2a1b64c9f5e545~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=948&h=618&s=70461&e=png&b=fcfcfc)\n\n- 在**master**分支中，想要把**reg**合并过来。由于修改了同一个文件，会报错，需要解决冲突\n\n![image-20230613010950109.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17f70c3240d346e59c00847f768f7e19~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1083&h=466&s=60751&e=png&b=fdfdfd)\n\n- 手动解决冲突后，会产生一个新的提交记录\n\n![image-20230613011347885.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8797be1e0abe479d9a7a73a81806ab1a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1275&h=460&s=62962&e=png&b=fdfdfd)\n\n- 删除**reg**分支，全部过程结束\n\n![image-20230613011445775.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb459f69afc4465c9c7fdb5b18ce9c7f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1303&h=378&s=54548&e=png&b=fdfdfd)\n\n## Git远程仓库\n\n### 介绍\n\n远程仓库是指托管在因特网或其他网络上的 Git 仓库，可以存储我们版本库的所有记录和存档记录\n\n远程仓库在团队协作中发挥着重要的作用。它不仅可以充当备份存储，保护你的代码免受数据丢失的风险，还可以让团队成员之间轻松地共享代码、查看代码变更、进行代码审查等\n\n![image-20230615093344985.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13a4c887c55546daafb77886906c97fd~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1251&h=499&s=155129&e=png&b=feefea)\n\n主流的远程仓库有 GitHub (gay hub)全球最大的同行交友社区，以及服务器在国内的 gitee（码云）。由于 GitHub 服务器在国外，需要科学上网或者使用其他加速工具，方便起见，这里以码云为例，供初学者参考，GitHub 流程与 gitee 类似\n\n### 注册\n\n注册登录 gitee.com 网站以后，添加主邮箱为自己本地 git 仓库设置的邮箱，注意一定要相同，否则无法正确提交\n\n如果忘记了本地设置的邮箱地址：\n\n- 可以打开控制台输入 `git config --list` 重新查看邮箱地址\n- 当然也可以使用 `git config --global user.email 你的邮箱地址`重新覆盖原来的邮箱地址\n\n**邮箱设置界面不要勾选不公开我的邮箱地址，否则也无法正常提交**\n\n![image-20230615094323926.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b12fe36771343d9b420251a0238b33a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1221&h=748&s=90210&e=png&b=ffffff)\n\n### 仓库新建\n\n可以选择创建一个远程仓库的项目 (可以多个)，创建界面如下\n\n![image-20230615095044748.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/432b12e869a649f9822330c8e94a0c74~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1152&h=859&s=74998&e=png&b=ffffff)\n\n勾选完成后选择创建，创建后, 会得到一个远程仓库的地址链接, 一般是以 `.git`结尾的地址\n\n地址分为两种最常用的两种传输协议：\n\n- HTTPS协议：需要输入用户名和密码 `https://gitee.com/(userName)/(repositoryName).gitssh`\n- SSH协议：需要配置密钥，可免密码登录 `git@gitee.com:userName/repositoryName.git`\n\n选择SSH路径，界面如下\n\n![image-20230615095628604.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5b124240c3f4aa6a5277f0681a36569~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1509&h=871&s=78185&e=png&b=ffffff)\n\n### SSH配置\n\n我们可以在本机一次性配置 SSH 以后免密登录，SSH 密钥组成和作用如下：\n\n- 作用：实现本地仓库和 gitee 平台之间免登录的加密数据传输\n- 组成：`id_rsa` (私钥文件，存放于客户端的电脑中即可)、`id_rsa.pub` (公钥文件，需要配置到 gitee 平台中)\n\n> 私钥加密的信息，只能通过公钥解密。公钥加密的信息，只能通过私钥解密。安全性高！\n\nSSH 密钥创建与使用步骤：\n\n- 先在本机生成一个密钥 (以后也可以重新生成、重新配置)，打开一个终端，输入以下命令：\n\n  ```bash\n  ssh-keygen -t rsa -C \"你注册账号的邮箱\"\n  ```\n\n- 连续敲击 3 次回车，即可在 `C:\\Users\\用户名文件夹.ssh`目录中生成 `id_rsa`和 `id_rsa.pub`两个文件\n- 使用 VSCode 打开 `id_rsa.pub`文件，复制里面的文本内容\n- 粘贴配置到 码云 -> 设置 -> ssh 公钥 中即可\n- 如果为 mac ，可进入以下教程查看：[mac获取公钥](https://juejin.cn/post/6844904169191522317 \"https://juejin.cn/post/6844904169191522317\")\n\n### 初始化空仓库\n\n先给本地仓库配置个远程仓库的地址, 建立仓库之间的链接\n\n由于每次 push 操作都需要带上远程仓库的地址，十分麻烦，我们可以给仓库设置一个别名\n\n```bash\n# 给远程仓库设置一个别名\ngit remote add 仓库别名 仓库地址\ngit remote add origin git@gitee.com:(username)/repository.git\n\n# 删除 origin 这个别名\ngit remote remove origin\n\n# 使用 -u 记录 push 到远端分支的默认值，将来直接 git push 即可\ngit push -u 仓库别名 分支名\n\n\n```\n\n![image-20230615101817727.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/286cb8c8f7014178a0f9d661d72b1b86~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1046&h=500&s=52493&e=png&b=ffffff)\n\n下面为实际操作举例：\n\n- 随便新建一个项目文件夹，初始化 git，随后在项目文件中随便填充点内容，这里我新增一个 `.gitignore`文件，随后暂存提交到本地 git 库\n\n  ![image-20230615103357225.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ed212afea8340b1b0bb8416e4da2cfc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1095&h=399&s=53082&e=png&b=000000)\n\n- 输入以下命令：\n\n  ```bash\n  # 注意：这里的existing_git_repo是你的项目根路径\n  # 如果你是在项目文件夹开启的终端，忽略此行\n  cd existing_git_repo\n\n  # 添加远程仓库关联，仓库别名origin，可以随意更改，后接ssh地址\n  # 此处的ssh是自动生成的，可以去gitee空仓库的代码页直接复制即可\n  git remote add origin git@gitee.com:li-houyi/test-factory.git\n\n  # 第一次推送到远程时需要指定具体的分支，因为远程仓库并没有这个分支\n  # 使用 -u 记录 push 到远端分支的默认值，将来直接 git push 即可\n  git push -u origin \"master\"\n\n  ```\n\n- 出现此页面即为成功：\n\n  ![image-20230615104040319.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b79a2854794940cd8b865dbf3ec742e4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=799&h=322&s=41134&e=png&b=000000)\n\n  > 注意：推送的本地仓库一定要非空并且本地暂存提交过，不然会报错！这点也很好理解，你传个空的项目到一个空仓库，这可不得给你报错吗\n\n- 推送成功后重新进入 gitee 仓库页面查看是否正确推送\n\n  ![image-20230615105531979.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e41eac290dc4f149a74464f41c0db49~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1167&h=399&s=43890&e=png&b=fcfcfc)\n\n空仓库创建成功后可以在管理页面将仓库开源，当然也可以不设置开源（默认私有）\n\n### 克隆项目\n\n如果你想要从远程仓库克隆一份项目代码到本地进行开发，可以使用 `git clone` 命令\n\n```bash\ngit clone [options] <repository-url> [directory]\n# directory（可选）克隆后的本地仓库所处的目录名称（默认创建与远程仓库名字相同的目录）\n\n```\n\n**常见选项：**\n\n- `-b <branch>` 或 `--branch <branch>`：指定要克隆的远程仓库的特定分支，它不会影响克隆操作所获取的分支数量，而只是指定了默认要检出的分支（不指定则默认克隆远程仓库的主分支）\n- `--depth <depth>`：指定克隆的深度，即只克隆指定数量的提交历史\n- `--single-branch`：仅克隆指定分支以及该分支上的历史记录，不下载其他分支\n- `--recurse-submodules`：初始化并克隆子模块的内容\n- `-n` 或 `--no-checkout`：克隆后不立即检出任何分支，保留 HEAD 指向原始仓库的默认分支\n- `-o <name>` 或 `--origin <name>`：自定义远程仓库的别名。\n- `-u <remote> <branch>` 或 `--set-upstream-to=<remote>/<branch>`：设置追踪关系，使得本地分支自动与指定的远程分支关联\n\n如果项目只有一个分支，那么以上代码执行完毕就已经克隆结束了（git clone 默认拉取 master 分支），**不过实际开发中，并非只有一个分支，于是我们还需执行以下步骤：**\n\n- 在本地建分支，分支名与远程分支名相同，查看远程分支名使用 `git branch -r`\n\n```bash\ngit checkout -b 对应远程分支名\n```\n\n- 拉取远程分支 ( **不要在 master 分支直接拉取对应分支的代码，切换到新建的分支** )\n\n```bash\n# 每次拉取都需要指定远程仓库名和分支名\ngit pull 远程仓库名 分支名\n\n```\n\n- 以上两行命令可以合并写做一行（创建并拉取远程分支代码）\n\n```bash\ngit checkout -b 分支名 origin/分支名\n\n```\n\n- 拓展: 设置 git pull 默认拉取的分支（设置本地分支与远程分支相关联）\n\n```bash\ngit branch --set-upstream-to=origin/远程分支名 本地分支名\n\n```\n\n### Git远程仓库流程回顾\n\n- Step1：\n\n![image-20230616072225869.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f4681eae7324e7289273c0dfafcce42~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1293&h=742&s=106266&e=png&b=ffffff)\n\n- Step2：\n\n![image-20230616072307518.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cab60b7a65848359254d6a7f324d211~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1269&h=734&s=138485&e=png&b=ffffff)\n\n- Step3：\n\n![image-20230616072523621.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c08d5b4d515d4443b12c0ad5c16e922c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1410&h=781&s=214562&e=png&b=fefefe)\n\n- Step4：\n\n![image-20230616072547086.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b68c1379c384c38adea3aeddb42a8da~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1279&h=715&s=86253&e=png&b=ffffff)\n\n# Git常用命令总览\n\n> 本命令**默认远程仓库名**为 `origin`、**默认远程仓库主分支名**为 `master`、`<>`为必填项，`[]`为可选项\n\n![git.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e98276c847f4cc6a24482d08394cd3a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2455&h=4096&s=945536&e=png&b=fef7f6)\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/课件/guid/tool/git的使用.md"}},{"pageContent":"\n\n\n## 常见配置\n\n\n**自动保存**：\n\n```\n \"files.autoSave\": \"onFocusChange\"\n```\n\n参考链接：<https://blog.csdn.net/WestLonly/article/details/78048049>\n\n\n\n**在新的窗口中打开文件**：\n\n```json\n\"workbench.editor.enablePreview\": false,\n```\n\n## 常见操作\n\n### 如何查看代码结构\n\n- 方法一：「Cmd + Shift + O」\n\n- 方法二：安装插件`Code Outline`\n\n参考链接：<https://www.zhihu.com/question/264045094>\n\n\n\n### 在本地开启服务器\n\n```bash\n# 安装\nnpm install -g live-server\n\n# 启动\nlive-server\n```\n\n\n参考链接：[Visual Studio Code + live-server编辑和浏览HTML网页](http://www.cnblogs.com/1zhk/p/5699379.html)\n\n\n## 常用插件\n\n方式一：打开VS Code，左侧有五个按钮，点击最下方的按钮，然后就可以开始安装相应的插件了。\n\n方式二：在vscode中输入快捷键「ctrl+shift+P」，弹出指令窗口，输入`extension:install`，回车，左侧即打开扩展安装的界面。\n\n\n### sftp：文件传输\n\n\n输入快捷键「ctrl+shift+P」，弹出指令窗口，输入`sftp:config`，回车，当前工作工程的`.vscode`文件夹下就会自动生成一个`sftp.json`文件，我们需要在这个文件里配置的是：\n\n- `host`：服务器的IP地址\n\n- `username`：工作站自己的用户名\n\n- `privateKeyPath`：存放在本地的已配置好的用于登录工作站的密钥文件（也可以是ppk文件）\n\n- `remotePath`：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用sftp上传文件之前，要手动在工作站上mkdir生成这个根目录\n\n- `ignore`：指定在使用sftp: sync to remote的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号\n\n\n举例如下：(注意，其中的注释不能保留)\n\n```json\n{\n    \"host\": \"\",     //服务器ip\n    \"port\": 22,     //端口，sftp模式是22\n    \"username\": \"\", //用户名\n    \"password\": \"\", //密码\n    \"protocol\": \"sftp\", //模式\n    \"agent\": null,\n    \"privateKeyPath\": null,\n    \"passphrase\": null,\n    \"passive\": false,\n    \"interactiveAuth\": false,\n    \"remotePath\": \"/root/node/build/\",  //服务器上的文件地址\n    \"context\": \"./server/build\",        //本地的文件地址\n\n    \"uploadOnSave\": true,   //监听保存并上传\n    \"syncMode\": \"update\",\n    \"watcher\": {            //监听外部文件\n        \"files\": false,     //外部文件的绝对路径\n        \"autoUpload\": false,\n        \"autoDelete\": false\n    },\n    \"ignore\": [             //忽略项\n        \"**/.vscode/**\",\n        \"**/.git/**\",\n        \"**/.DS_Store\"\n    ]\n}\n```\n\n\n### Sass Formatter\n\nSass 文件格式化。\n\n\n### Code Outline：显示代码结构\n\n\n安装好插件「Code Outline」后，可以在左侧的资源管理器中，显示当前文件的代码结构：\n\n![](http://img.smyhvae.com/20180420_0925.png)\n\n参考链接：\n\n- <https://www.zhihu.com/question/50273450>\n\n- <http://itopic.org/vscode.html>\n\n- <https://github.com/varHarrie/varharrie.github.io/issues/10>\n\n### vscode-fileheader：添加顶部注释模板(签名)\n\n（1）安装插件vscode -fileheader，并重启。\n\n（2）在首选项-》设置-》中搜索fileheader，找到头部模板修改。\n\n默认的快捷键是：「Ctrl + option + I」。\n\n参考链接：\n\n- <https://www.zhihu.com/question/62385647>\n\n\n### Express\n\n在本地开启Node服务器：\n\n![](http://img.smyhvae.com/20180611_2230.png)\n\n然后在浏览器的地址栏输入`http://localhost/` + 文件的相对路径，就可以通过服务器的形式打开这个文件。\n\n### Copy Relative Path\n\n> 这个插件很有用，使用频率很高。\n\n复制文件的相对路径：（相对于根路径而言）\n\n![](http://img.smyhvae.com/20180611_2235.png)\n\n\n### open in browser\n\n在浏览器中打开。\n\n\n### Auto Rename Tag\n\n适用于 JSX、Vue、HTML。在修改标签名时，能在你修改开始（结束）标签的时候修改对应的结束（开始）标签，帮你减少 50% 的击键。\n\n\n###Project Manager\n\n项目管理，让我们方便的在命令面板中切换项目文件夹，当然，你也可以直接打开包含多个项目的父级文件夹，但这样可能会让 VSCode 变慢。\n\n\n\n### highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】\n\nVSCode自带的高亮显示，实在是不够显眼。用插件支持一下吧。\n\n所用了这个插件之后，VS Code自带的高亮就可以关掉了：\n\n在用户设置里添加`\"editor.selectionHighlight\": false`即可。\n\n\n参考链接：[vscode 选中后相同内容高亮插件推荐](https://blog.csdn.net/palmer_kai/article/details/79548164)\n\n\n### highlight-words：全局高亮（跨文件多色彩）\n\n\n参考链接：[Visual Studio Code全局高亮着色插件(跨文件多色彩)经验纪要](https://zhuanlan.zhihu.com/p/31163793)\n\n\n### color-exchange：颜色格式转换【荐】\n\n\n安装完插件后，在css中输入颜色，然后按`cmd + .`，就能进行颜色的格式转换。\n\n20181013_1450.png\n\n我在写这一段时，安装的人还不多，赶紧上车。\n\n\n\n## Vue 相关的插件\n\n### vetur：vue 文件的基本语法高亮\n\n安装完 vetur 后还需要加上这样一段配置下：\n\n```\n\"emmet.syntaxProfiles\": {\n  \"vue-html\": \"html\",\n  \"vue\": \"html\"\n}\n```\n\n参考链接：\n\n- <https://www.clarencep.com/2017/03/18/edit-vue-file-via-vscode/>\n\n\n- <https://github.com/varHarrie/varharrie.github.io/issues/10>\n\n\n\n### 参考链接\n\n- <https://www.jianshu.com/p/0724921285d4>\n\n- <https://www.cnblogs.com/AmosLee94/p/8338013.html>\n\n\n\n\n## 常用快捷键\n\n\n| Win快捷键 |Mac快捷键| 作用 | 备注 |\n|:-------------|:-------------|:-----|:-----|\n| Shift + Alt + F |Shift + option + F| 代码格式化 |  |\n| Ctrl + Shift + N | |在当前行上面增加一行并跳至该行  |   |\n|  **Ctrl + Shift + D** | |复制当前行到下一行  |   |\n\n\n\n\n\n### 如何同时打开多个窗口\n\n\n\n\n\n\n\n\n\n\n\n\n## 问题\n\n问题1\n\n解决；You can kill the Microsoft.VSCode.Cpp.IntelliSense.Msvc process to save the file successfully. 也就是 IntelliSense 这个进程。\n\n\n\n\n## 参考链接\n\n- [能让你开发效率翻倍的 VSCode 插件配置（上）](https://zhuanlan.zhihu.com/p/30976584)\n\n\n### 某网友的VS Code 插件截图\n\n![](http://img.smyhvae.com/20180611_2255.png)\n\n\n\n\n\n\n\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/课件/guid/tool/vscode配置.md"}},{"pageContent":"# 什么是前端？\n\n## 1.1 前端的定义\n\n在我们访问一个网站时，所有能够直接看到、点击、输入和互动的部分，都是由前端来实现的。前端主要是指用户可视界面的开发，包含页面结构、样式、动态效果和互动功能，最终目标是为用户提供友好且美观的交互界面。\n\n## 1.2 前端的三大核心技术\n\n前端开发的实现主要依赖以 下三大核心技术：\n\nHTML（HyperText Markup Language）：前端开发的基础，用于定义网页的结构和内容。HTML 定义了网站的每个元素，如文本、图像、视频、链接等，让网页有“骨架”。\n\nCSS（Cascading Style Sheets）：用于网页的样式设计，定义 HTML 元素的显示方式，包括颜色、字体、布局等。CSS 让网页更加美观、有层次感。\n\nJavaScript：赋予网页动态交互功能，使网页可以响应用户操作。比如按钮的点击、表单验证、图片轮播等功能都需要 JavaScript 支持。\n\n这些技术的结合，让开发者可以构建功能丰富、互动性强的网页。随着前端技术的不断发展，HTML、CSS 和 JavaScript 的应用也越来越广泛和深入。\n\n## 1.3 前端框架和工具\n\n为了提升开发效率和用户体验，前端开发衍生出了一系列强大的框架和工具：\n\n框架和库：如 React、Vue.js、Angular 等，它们提供了大量预设的组件和功能，帮助开发者快速构建复杂的界面。\n\n预处理器和后处理器：如 Sass、Less（CSS 预处理器）、PostCSS 等，用于提升 CSS 的灵活性和可维护性。\n\n构建工具：如 Webpack、Parcel 等，用于打包、压缩和优化前端代码，提升网页加载速度。\n\n# 2.什么是后端？\n\n## 2.1 后端的定义\n\n与前端的用户交互界面不同，后端负责应用的业务逻辑、数据处理和管理。后端如同应用的“后台”，用户无法直接看到，但它负责网站或应用的核心功能和数据流转。后端的职责是确保数据存储安全、业务逻辑运行流畅，并根据请求将数据发送给前端。\n\n## 2.2 后端的组成要素\n\n后端主要由以下几个部分构成：\n\n服务器：为用户提供数据和计算资源的设备，托管网站和应用。服务器接收前端发送的请求，并根据业务逻辑返回相应的数据。\n\n数据库：用于存储和管理应用数据的系统，常见的数据库有 MySQL、MongoDB、PostgreSQL 等。数据库将结构化的或非结构化的数据保存下来，以便随时查询和更新。\n\n服务器端编程语言：用于编写业务逻辑代码，将应用的需求转化为功能，常见的后端语言有 Java、Python、PHP、Ruby、Node.js 等。\n\n## 2.3 后端框架和工具\n\n为了提升开发效率和代码的稳定性，后端开发者通常使用各种框架和工具：\n\n后端框架：如 Express（基于 Node.js）、Django（基于 Python）、Laravel（基于 PHP）等，这些框架提供了丰富的工具和功能，加速开发并提升代码的可维护性。\n\nAPI：应用程序接口（API）是前后端沟通的桥梁，常见的 API 技术包括 RESTful API 和 GraphQL，通过这些接口，前端可以请求数据，而后端负责返回所需的数据。\n\n# 3.前后端的区别\n\n了解了前端和后端的概念后，我们再来深入探讨一下两者的区别。前端和后端分别处理不同的任务，它们相辅相成，共同构成了一个完整的应用。\n\n| 比较维度 | 前端                                    | 后端                                                   |\n| -------- | --------------------------------------- | ------------------------------------------------------ |\n| 目标     | 提供美观、友好、流畅的用户界面          | 处理业务逻辑，管理数据，确保功能正常运行               |\n| 技术栈   | HTML、CSS、JavaScript、Vue.js、React 等 | Node.js、Java、Python、PHP、数据库（MySQL、MongoDB）等 |\n| 执行环境 | 用户的浏览器中                          | 服务器上                                               |\n| 面向对象 | 面向用户，提供良好的交互体验            | 面向数据和逻辑，确保数据的正确性和安全性               |\n| 关注点   | 页面布局、样式、交互                    | 数据管理、业务逻辑                                     |\n\n# 4.什么是前后端分离？\n\n在了解了前后端的区别后，现代 Web 开发中越来越强调的“前后端分离”概念就很容易理解了。前后端分离意味着前端和后端各自独立开发、部署和维护，两者通过 API 进行数据交换。这种开发模式带来了很多好处\n\n## 4.1 前后端耦合与前后端分离\n\n传统前后端耦合方式：早期的 Web 开发中，前端页面和后端逻辑紧密耦合在一起。每当用户请求一个页面，服务器会先处理业务逻辑，将数据填充到 HTML 模板中生成页面，再返回给浏览器。这种方式虽然简单，但页面每次请求都需要刷新，体验不佳。 浏览器的展示是由后端来决定的 其实就是服务器决定的。\n\n- 前后端分离模式：前后端分离的模式中，前端通过 AJAX、Fetch 或者 Axios 等方式调用后端提供的 API，获取数据并渲染页面。这样，前端的页面和后端的逻辑完全分离，只通过 API 进行数据交换，页面只需要局部刷新而无需整体加载。\n\n<img src='https://i-blog.csdnimg.cn/direct/a2a2c15734234908b3dae119e0878bb1.png'>\n\n## 4.2 前后端分离的好处\n\n- 提升用户体验：前端可以动态获取数据并局部刷新页面，减少了页面跳转和加载时间，用户体验更流畅。\n- 提高开发效率：前后端开发可以并行进行，前端专注界面和交互，后端专注数据和逻辑，减少了开发依赖性。\n- 便于技术升级和维护：前后端代码独立，便于维护和更新。前端可以随时切换技术框架，而后端则可以逐步优化，不会相互影响。\n\n## 4.3 前后端分离的实现方式\n\nRESTful API：通过 REST 风格的接口，前端可以按需请求资源，如 CRUD（增删查改）操作，非常适合大部分 Web 应用。\n\nGraphQL：一种灵活的查询语言，让前端可以按需请求数据字段，减少了冗余数据的传输，适合复杂应用的数据请求。\n\n5. 前后端分离的示例场景\n   为了更好理解前后端分离的应用场景，以下是一个电子商务网站的示例：\n\n前端：用户访问一个在线商城，页面的商品展示和购物车动态更新，这些交互由前端处理。用户点击商品、添加到购物车等操作会触发 JavaScript 动作，并通过 Axios 发送请求。\n\n后端：接收到请求后，后端服务器查询数据库，返回商品数据。后端还负责处理库存管理、支付逻辑等，确保商品库存与订单信息准确无误。\n\n通过 API，前端可以迅速获取最新的商品信息，局部刷新商品列表，不需要刷新整个页面，提升了购物体验。\n\n总结\n前端：定义页面结构、样式和交互，让用户看到并与应用互动的部分。\n后端：负责业务逻辑和数据处理，确保应用核心功能的正常运行。\n前后端分离：是一种现代化开发模式，通过 API 将前端与后端分离，提升开发效率和用户体验。\n通过深入了解前端、后端及前后端分离的概念，希望你能对 Web 开发的整体架构有更系统的认识。接下来的学习中，我们将带你进一步了解前端开发的具体技术，实现从零到项目开发的顺利过渡\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/课件/guid/tool/前端是什么.md"}},{"pageContent":"# 浏览器插件\n\n[极简插件](https://chrome.zzzmh.cn/about)\n\n可以前往极简插件网站下载浏览器插件\n\n在我们的日常工作中，安装一些浏览器插件可以更方便一些日常工作。这篇经验就来介绍一下怎么在谷歌浏览器里面安装插件。\n\n1、打开谷歌浏览器。\n\n![](http://exp-picture.cdn.bcebos.com/354e7a781423beb9cc4b087830d6e1d06ce8b3d3.jpg?x-bce-process=image%2Fcrop%2Cx_0%2Cy_0%2Cw_1920%2Ch_1023%2Fformat%2Cf_auto%2Fquality%2Cq_80)\n\n2、点击右上角的三个点，找到设置。\n\n![](http://exp-picture.cdn.bcebos.com/ba97ffd06de89a614650682945e8b004551badd3.jpg?x-bce-process=image%2Fcrop%2Cx_0%2Cy_0%2Cw_1919%2Ch_1029%2Fformat%2Cf_auto%2Fquality%2Cq_80)\n\n3、在左侧的菜单中找到“扩展程序”，单击一下。\n\n![](http://exp-picture.cdn.bcebos.com/65390a23beb9763e9ab7926c6ad06de89b61b0d3.jpg?x-bce-process=image%2Fcrop%2Cx_0%2Cy_0%2Cw_1920%2Ch_1023%2Fformat%2Cf_auto%2Fquality%2Cq_80)\n\n4、打开右上角的“开发者模式”。\n\n![](http://exp-picture.cdn.bcebos.com/2083a5d6e1d06de82514af9fca93cee8b104acd3.jpg?x-bce-process=image%2Fcrop%2Cx_0%2Cy_0%2Cw_1920%2Ch_1023%2Fformat%2Cf_auto%2Fquality%2Cq_80)\n\n5、把插件直接拖拽到浏览器的空白处。\n\n![](http://exp-picture.cdn.bcebos.com/777f3fc2bbd6e1d0d39db3db0d254193cfe8afd3.jpg?x-bce-process=image%2Fcrop%2Cx_0%2Cy_0%2Cw_1920%2Ch_1023%2Fformat%2Cf_auto%2Fquality%2Cq_80)\n\n6、点击“添加扩展程序”。\n\n![](http://exp-picture.cdn.bcebos.com/1562a0b9763e21c207a3c86ae6e89a618725b1d3.jpg?x-bce-process=image%2Fcrop%2Cx_0%2Cy_0%2Cw_1920%2Ch_1023%2Fformat%2Cf_auto%2Fquality%2Cq_80)\n\n7、如图所示，这就是添加成功的样子。\n\n![](http://exp-picture.cdn.bcebos.com/bff8683e21c2bbd65ca54452116186254093aed3.jpg?x-bce-process=image%2Fcrop%2Cx_0%2Cy_0%2Cw_1920%2Ch_1023%2Fformat%2Cf_auto%2Fquality%2Cq_80)\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/课件/guid/tool/浏览器插件.md"}},{"pageContent":"# 谷歌浏览器\n\n## 首先 我们先下载谷歌\n\n<a href=\"https://www.google.cn/intl/zh-CN/chrome/\" target=\"_blank\">谷歌浏览器官网下载地址</a>\n\n## 常见的浏览器\n\n浏览器是网页运行的平台，常见的浏览器有谷歌（Chrome）、Safari、火狐（Firefox）、IE、Edge、Opera 等。如下图所示：\n\n![](http://img.smyhvae.com/20191204_1900.png)\n\n我们重点需要学习的是 Chrome 浏览器。\n\n## 浏览器的市场占有份额\n\n浏览器的市场占有份额：[https://tongji.baidu.com/research/site?source=index#browser](https://tongji.baidu.com/research/site?source=index#browser)\n\n![](http://img.smyhvae.com/20200322_1058.png)\n\n上面这张图的统计时间是 2020 年 2 月。\n\n## 浏览器的组成\n\n浏览器分成两部分：\n\n- 1、渲染引擎（即：浏览器内核）\n- 2、JS 引擎\n\n### 1、渲染引擎（浏览器内核）\n\n浏览器所采用的「渲染引擎」也称之为「浏览器内核」，用于解析 HTML 和 CSS、布局、渲染等工作。渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。\n\n**渲染引擎是浏览器兼容性问题出现的根本原因。**\n\n渲染引擎的英文叫做 Rendering Engine。通俗来说，它的作用就是：读取网页内容，计算网页的显示方式并显示在页面上。\n\n常见浏览器的内核如下：\n\n|     浏览器     |  内核   |\n| :------------: | :-----: |\n|     chrome     |  Blink  |\n|      欧鹏      |  Blink  |\n| 360 安全浏览器 |  Blink  |\n| 360 极速浏览器 |  Blink  |\n|     Safari     | Webkit  |\n|  Firefox 火狐  |  Gecko  |\n|       IE       | Trident |\n\n备注：360 的浏览器，以前使用的 IE 浏览器的 Trident 内核，但是现在已经改为使用 chrome 浏览器的 Blink 内核。\n\n另外，移动端的浏览器内核是什么？大家可以自行查阅资料。\n\n### 2、JS 引擎\n\n也称为 JS 解释器。 用来解析和执行网页中的 JavaScript 代码。\n\n浏览器本身并不会执行 JS 代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时会逐行解释每一句源码，转换为机器语言，然后由计算机去执行。\n\n常见浏览器的 JS 引擎如下：\n\n|        浏览器        | JS 引擎                                                                         |\n| :------------------: | :------------------------------------------------------------------------------ |\n|     chrome、欧鹏     | V8                                                                              |\n| Mozilla Firefox 火狐 | SpiderMonkey（1.0-3.0）/ TraceMonkey（3.5-3.6）/ JaegerMonkey（4.0-）           |\n|        Safari        | JavaScriptCore，也称为 Nitro，是 WebKit 引擎的一部分                            |\n|          IE          | Trident                                                                         |\n|         Edge         | Chakra。此外，ChakraCore 是 Chakra 的开源版本，可以在不同的平台上使用。         |\n|        Opera         | Linear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-） |\n\n补充说明：\n\n1、SpiderMonkey 是第一款 JavaScript 引擎，由 JS 语言的作者 Brendan Eich 开发。\n\n2、先以 WebKit 为例，WebKit 上由两部分组成：\n\n- WebCore：负责解析 HTML 和 CSS、布局、渲染等工作。\n- JavaScriptCore：负责解析和执行 JavaScript 代码。\n\n参考链接：\n\n- [主流浏览器内核及 JS 引擎](https://juejin.im/post/5ada727c518825670b33a584)\n\n## 浏览器工作原理\n\n> 这一小段有些深入，小白可以暂时跳过，以后学习 JS 的时候再回来看。\n\n浏览器主要由下面这个七个部分组成：\n\n![](http://img.smyhvae.com/20180124_1700.png)\n\n1、User Interface（UI 界面）：包括地址栏、前进/后退按钮、书签菜单等。也就是浏览器主窗口之外的其他部分。\n\n2、Browser engine （浏览器引擎）：用来查询和操作渲染引擎。是 UI 界面和渲染引擎之间的**桥梁**。\n\n3、Rendering engine（渲染引擎）：用于解析 HTML 和 CSS，并将解析后的内容显示在浏览器上。\n\n4、Networking （网络模块）：用于发送网络请求。\n\n5、JavaScript Interpreter（JavaScript 解析器）：用于解析和执行 JavaScript 代码。\n\n6、UI Backend（UI 后端）：用于绘制组合框、弹窗等窗口小组件。它会调用操作系统的 UI 方法。\n\n7、Data Persistence（数据存储模块）：比如数据存储 cookie、HTML5 中的 localStorage、sessionStorage。\n\n参考链接：（关于浏览器的工作管理，下面这篇文章，是精品中的精品，是必须要知道的）\n\n- 英文版：[How Browsers Work: Behind the scenes of modern web browsers](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/)\n- 中文版：[浏览器的工作原理：新式网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)\n\n## 为什么选择谷歌浏览器(浏览器内核详解)\n\n首先给出答案，因为大多浏览器使用的都是 webkit 内核，我们为了代码能兼容更多的平台，所以有限选择谷歌浏览器\n\n<img src='https://pic3.zhimg.com/v2-f464eaf0dc47177ef67649c1c1eb6e22_r.jpg'>\n\n- **IE/Edge：**微软的 IE 浏览器浏览器更新至 IE10 后，伴随着 WIN10 系统的上市，迁移到了全新的浏览器 Edge。除了 JS 引擎沿用之前 IE9 就开始使用的查克拉(Chakra)，渲染引擎使用了新的内核 EdgeHTML（本质上不是对 Trident 的完全推翻重建，而是在 Trident 基础上删除了过时的旧技术支持的代码，扩展和优化了对新的技术的支持，所以被看做是全新的内核）\n- **Safari**：Safari 自 2003 年面世，就一直是苹果公司的产品自带的浏览器，它使用的是苹果研发和开源的 Webkit 引擎。Webkit 引擎包含 WebCore[排版引擎](https://zhida.zhihu.com/search?content_id=110303645&content_type=Article&match_order=1&q=排版引擎&zhida_source=entity)及 JavaScriptCore[解析引擎](https://zhida.zhihu.com/search?content_id=110303645&content_type=Article&match_order=1&q=解析引擎&zhida_source=entity)，均是从 KDE 的 KHTML 及 KJS 引擎衍生而来。Webkit2 发布于 2010 年，它实现了元件的抽象画，提高了元件的重复利用效率，提供了更加干净的网页渲染和更高效的渲染效率。另外，Webkit 也是苹果 Mac OS X 系统引擎框架版本的名称，主要用于 Safari、Dashboard、Mail。\n- **Chrome**：提到 Chrome 浏览器，一般人会认为使用的 Webkit 内核，这种说法不完全准确。Chrome 发布于 2008 年，使用的渲染内核是 Chromium，它是 fork 自 Webkit，但把 Webkit 梳理得更有条理可读性更高，效率提升明显。2013 年，由于 Webkit2 和 Chromium 在沙箱设计上的冲突，谷歌联手 Opera 自研和发布了 Blink 引擎，逐步脱离了 Webkit 的影响。所以，可以这么认为：Chromium 扩展自 Webkit 止于 Webkit2，其后 Chrome 切换到了 Blink 引擎。另外，Chrome 的 JS 引擎使用的 V8 引擎，应该算是最著名和优秀的开源 JS 引擎，大名鼎鼎的 Node.js 就是选用 V8 作为底层架构。\n- **Firefox**：火狐的内核 Gecko 也是[开源引擎](https://zhida.zhihu.com/search?content_id=110303645&content_type=Article&match_order=1&q=开源引擎&zhida_source=entity)，任何程序员都能为其提供扩展和建议。火狐的 JS 引擎历经 SpiderMonkey、TraceMonkey 到现在的 JaegerMonkey。其中 JaegerMonkey 部分技术借鉴了 V8、JSCore 和 Webkit，算是集思广益。\n- **Opera**：Opera 在 2013 年 V12.16 之前使用的是 Opera Software 公司开发的 Presto 引擎，之后连同谷歌研发和选择 Blink 作为 Opera 浏览器的排版内核。\n\n## 国内浏览器情况\n\n> 国内浏览器厂商（QQ、2345、搜狗、猎豹、UC、360）也有一定的市场占有率。且大多数为双核\n\n### 总结国内厂商内核来看，一般为三类：\n\n一、使用的 Trident 单核，如：2345、[世界之窗](https://zhida.zhihu.com/search?content_id=110303645&content_type=Article&match_order=1&q=世界之窗&zhida_source=entity)；\n二、使用 Trident+Webkit/Blink 双核，如：qq、UC、猎豹、360、百度；\n三、使用 Webkit/Blink 单核，如：搜狗、[遨游](https://zhida.zhihu.com/search?content_id=110303645&content_type=Article&match_order=1&q=遨游&zhida_source=entity)。\n\n双核浏览器通过 WebKit 内核来访问一些不需要进行网上交易的网站，使用起来速度更快更方便;[双核浏览器](https://zhida.zhihu.com/search?content_id=110303645&content_type=Article&match_order=2&q=双核浏览器&zhida_source=entity)在进行支付系统或者是网上银行的访问时，则使用的是 Trident 内核。这就是双核浏览器的高速模式和兼容模式。双核浏览器是一个不仅仅具有 ie 浏览器内核同时兼容非 ie 浏览器内核的浏览器，可以让用户在浏览器当中体验不同的需求\n\n## 浏览器内核技术\n\n浏览器内核主要包括以下三个技术分支：排版渲染引擎、 JavaScript 引擎，以及其他。\n\n微软对排版渲染引擎相关专利的申请最多，达到浏览器内核相关专利申请总量的 93.3%。这与排版渲染引擎的功能密不可分。其主要负责取得网页的内容(HTML、XML、图像等)、整理信息，以及计算网页的显示方式，然后输出至显示器。所有的网页浏览器、[电子邮件客户端](https://zhida.zhihu.com/search?content_id=110303645&content_type=Article&match_order=1&q=电子邮件客户端&zhida_source=entity)以及其他需要编辑、显示网络内容的应用程序都需要排版渲染引擎，特别是排版渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。由于在网页显示中所起的重要作用，微软一直侧重于涉及排版渲染引擎的专利申请。在 2006 年和 2009 年，配新版本的研发带来了排版渲染引擎专利申请量的顶峰这充分显示了微软在新版本的改进中对浏览器排版渲染引擎技术的重视。\n\nJavaScript 引擎是用来渲染 JavaScript 的，JavaScript 的渲染速度越快，动态网页的展示也越快。众所周知，微软的 IE 浏览器实现完全支持客户端 JavaScript 语言标准的时间晚于其他浏览器。因此，在这一技术分支下，相较其他浏览器企业而言，微软公司并不具有优势。在 2001~2004 年，在浏览器内核技术分支下，微软的中国专利申请量并不多，方面是由于内核为开放内核，另一方面则是由于 IE 本身一直与 Windows 捆绑销售，使得 Trident 内核长期一家独大，微软很长时间都没有更新 Trident 内核，从而导致 Trident 内核几乎与 W3C 标准脱节。\n\n2005 年至今，由于 IE 浏览器存在缺陷，从而使得很多用户转向其他浏览器。微软公司显然注意到了这一点，逐步重视浏览器内核的改进升级，并将由此带来的相关专利在中国进行了布局。最明显的是，2006 年和 2009 年的专利申请量大幅上升，其中关于浏览器内核中排版渲染引擎的专利申请均达到了 17 件；在 2008 年还有一件关于 JavaScript 引擎的专利申请，以上均表明 I 内核在 2005 年之后有了明显改进\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/guide/课件/guid/tool/谷歌浏览器.md"}},{"pageContent":"---\npageType: home\n\nhero:\n  name: stay hungry\n  text: stay foolish!\n  tagline: 个人的学习记录博客，欢迎您的访问😎\n  actions:\n    - theme: brand\n      text: Quick Start\n      link: /guide/\n    - theme: alt\n      text: GitHub\n      link: https://github.com/Manshawar\n  image:\n    src: /rspress-icon.png\n    alt: Logo\nfeatures:\n  - title: Blazing fast build speed\n    details: The core compilation module is based on the Rust front-end toolchain, providing a more ultimate development experience.\n    icon: 🏃🏻‍♀️\n  - title: Support for MDX content writing\n    details: MDX is a powerful way to write content, allowing you to use React components in Markdown.\n    icon: 📦\n  - title: Built-in full-text search\n    details: Automatically generates a full-text search index for you during construction, providing out-of-the-box full-text search capabilities.\n    icon: 🎨\n  - title: Simpler I18n solution\n    details: With the built-in I18n solution, you can easily provide multi-language support for documents or components.\n    icon: 🌍\n  - title: Static site generation\n    details: In production, it automatically builds into static HTML files, which can be easily deployed anywhere.\n    icon: 🌈\n  - title: Providing multiple custom capabilities\n    details: Through its extension mechanism, you can easily extend theme UI and build process.\n    icon: 🔥\n---\n","metadata":{"source":"/Users/manshawar/code/express-ts-template/Manshawar-cyber/apps/rspress/docs/index.mdx"}}]